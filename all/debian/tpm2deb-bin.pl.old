#!/usr/bin/perl
#
# tpm2deb-bin.pl
# machinery to create debian packages from TeX Live depot
# (c) 2005, 2006 Norbert Preining
#
# $Id: tpm2deb.pl 2080 2006-12-15 12:03:49Z preining $
#
# configuration is done via the file tpm2deb.cfg
#

BEGIN {   # get our other local perl modules.
	($mydir = $0) =~ s,/[^/]*$,,;
	if ($mydir eq $0) { $mydir = `pwd` ; chomp($mydir); }
	if (!($mydir =~ m,/.*,,)) { $mmydir = `pwd`; chomp($mmydir); $mydir = "$mmydir/$mydir" ; }
	unshift (@INC, $mydir);
	unshift (@INC, "$mydir/../build/tools");
}

use strict "vars";
# use strict "refs"; # not possible with merge_into
use warnings;
no warnings 'once';
no warnings 'uninitialized';

#use Strict;
use Getopt::Long;
use File::Basename;
use File::Copy;
use File::Path;
use File::Temp qw/ tempfile tempdir /;
use Storable;
## not needed, atm we are calling eperl binary use Parse::ePerl;
#use XML::DOM;
use Cwd;
#use FileUtils qw(canon_dir cleandir make_link newpath member
#		 normalize substitute_var_val dirname diff_list remove_list
#		 rec_rmdir sync_dir walk_dir start_redirection stop_redirection);
#use Tpm;


#
# Configuration for destination of files
# DONT USER DOUBLE QUOTES; THESE VARIABLES HAVE TO GET REEVALUATED
# AFTER $tmpdir IS SET!!
#
my $sysdebdest = '$tmpdir/debian';
my $sysbasedir = '$debdest/$package';
my $sysbindest = '$basedir/usr/bin';
my $sysrundest = '$basedir/usr/share';
my $sysdocdest = '$basedir/usr/share/doc/$package';
my $sysetcdest = '$basedir/etc/texmf';

my $debdest;
my $basedir;
my $bindest;
my $rundest;
my $docdest;
my $etcdest;

my @configfiles;

my $texmfdist = "texmf-texlive";
my $opt_nosource=0;
my $optdestination="";

my $opt_debug;
my $opt_master;
our $Master;
my $globalreclevel=1;

my $result = GetOptions ("debug!", 	# debug mode
	"nosource!" => \$opt_nosource,			# don't include source files
	"master=s" => \$opt_master,	# location of Master
	"dest=s" => \$optdestination,	# where to write files
	"reclevel=i" => \$globalreclevel,	# recursion level
	);
 
# Norbert, is $, intended here, or should it rather be m{/.*$}?
if (!($opt_master =~ m,/.*$,,)) {
	$Master = `pwd`;
	chomp($Master);
	$Master .= "/$opt_master";
} else {
	$Master = $opt_master;
}
my $TpmGlobalPath = $Master;
my $DataGlobalPath = $Master;

#
# put Master/Tools/ into the include path to find TeX Live perl modules
#
unshift (@INC, "$Master/Tools");
#
# these we can only load now that we have correctly set the path to Master
#
require Strict;
require XML::DOM;
require FileUtils;
import FileUtils qw(canon_dir cleandir make_link newpath member
	normalize substitute_var_val dirname diff_list remove_list
	rec_rmdir sync_dir walk_dir start_redirection stop_redirection);
require Tpm;

my $parser = new XML::DOM::Parser;
my $startdir=getcwd();
chdir($startdir);
File::Basename::fileparse_set_fstype('unix');

use tpm2debcommon;

&main(@ARGV);

1;


sub main {
	my (@packages) = @_;
	${Tpm::MasterDir} = $TpmGlobalPath;
	my $arch = "all";
	$Tpm::CurrentArch = "i386-linux";
	initialize_config_file_data("debian/tpm2deb.cfg");
	load_collection_tpm_data();
	build_data_hash();
	check_consistency();
	foreach my $package (@packages) {
		# 
		# various variables have to be set
		#
		#$arch = get_arch($package);
		print "Working on $package, arch=$arch\n";
		make_deb($package);
	}
}


#
# make_deb
#
sub make_deb {
	# my function
	#
	# do_special ($originalfilename, $finaldestinationfilename)
	#
	# Do special actions as specified in the config file, like install info
	# etc
	my @SpecialActions = ();
	sub do_special {
		my ($origfn, $finalfn) = @_;
		SPECIALS: foreach my $special (@{$TeXLive{'all'}{'special_actions_config'}}) {
			my ($pat, $act) = ($special =~ m/(.*):(.*)/);
			if ($origfn =~ m|$pat$|) {
				if ($act eq "install-info") {
					push @SpecialActions, "install-info:$origfn";
				} else {
					print "Unknown special action $act, terminating!\n";
					exit 1;
				}
			}
		}
	}
	# real start
	my ($package) = @_;
	my $foo;
	my $tmpdir;
	if ($optdestination ne "") {
		$tmpdir = $optdestination;
	} else {
		$tmpdir = ".";
	}
	$opt_debug && print "tmpdir = $tmpdir\n";
	$foo="\$debdest = \"$sysdebdest\""; eval $foo;
	$foo="\$basedir = \"$sysbasedir\""; eval $foo;
	$foo="\$bindest = \"$sysbindest\""; eval $foo;
	$foo="\$rundest = \"$sysrundest\""; eval $foo;
	$foo="\$docdest = \"$sysdocdest\""; eval $foo;
	$foo="\$etcdest = \"$sysetcdest\""; eval $foo;
	$opt_debug && print "\nProcess $package\n";
	if ($opt_debug) {
		print "debdest = $debdest\n";
		print "basedir = $basedir\n";
		print "bindest = $bindest\n";
		print "rundest = $rundest\n";
		print "docdest = $docdest\n";
		print "etcdest = $etcdest\n";
	}
	my %lists = %{&get_all_files($package,$globalreclevel)};
	my $title = $TeXLive{'binary'}{$package}{'title'};
	my $description = $TeXLive{'binary'}{$package}{'description'};
	eval { mkpath($rundest) };
	if ($@) {
		die "Couldn't create dir: $@";
	}  
	if ($opt_debug) {
		print "SOURCEFILES: ", @{$lists{'SourceFiles'}}, "\n";
		print "RUNFILES: ", @{$lists{'RunFiles'}}, "\n";
	}
	# clean @configfiles
	@configfiles = ();
	&mkpath($docdest);
	if (!$opt_nosource) {
		DOSFILE: foreach my $f (@{$lists{'SourceFiles'}}) {
			foreach my $pat (@{$TeXLive{'all'}{'file_blacklist'}}) { 
				if ($f =~ m|^${pat}$|) { next DOSFILE ; }
			}
			my $ret = do_remap_and_copy($f,$rundest);
			do_special($f,$ret);
		}
	}
	DORFILE: foreach my $f (@{$lists{'RunFiles'}}) {
		foreach my $pat (@{$TeXLive{'all'}{'file_blacklist'}}) {
			if ($f =~ m|^${pat}$|) { next DORFILE ; }
		}
		my $ret = do_remap_and_copy($f,$rundest);
		do_special($f,$ret);
	}
	my %DocDirHash = ();
	my @LinkedDocDir = ();
	DODFILE: foreach my $f (@{$lists{'DocFiles'}}) {
		foreach my $pat (@{$TeXLive{'all'}{'file_blacklist'}}) {
			if ($f =~ m|^${pat}$|) { next DODFILE ; }
		}
		my $ret = do_remap_and_copy($f,$rundest,'^[^/]*/doc/(.*)$','$docdest/$1');
		do_special($f,$ret);
	}
	DOBFILE: foreach my $f (@{$lists{'BinFiles'}}) {
		$opt_debug && print "BINFILE: $f\n";
		foreach my $pat (@{$TeXLive{'all'}{'file_blacklist'}}) {
			if ($f =~ m|^${pat}$|) { next DOBFILE ; }
		}
		my $ret = do_remap_and_copy($f,$bindest,'^bin/[^/]*/(.*)$','$bindest/$1');
		do_special($f,$ret);
	}
	if ($package eq 'texlive-base') {
		# now activate the language.us file!
		&mkpath("$basedir/var/lib/tex-common/language-cnf/");
		open(LISTFILE, ">$basedir/var/lib/tex-common/language-cnf/$package.list")
		    or die("Cannot open $basedir/var/lib/tex-common/language-cnf/$package.list");
		print LISTFILE "09$package\n";
		close LISTFILE;
		&mkpath("$etcdest/language.d");
		open(FOO,">$etcdest/language.d/09$package.cnf")
		    or die("Cannot open $etcdest/language.d/09$package.cnf");
		print FOO <<EOF;
% 09$package.cnf
%
% You really can change stuff in this file, but it is NOT RECOMMENDED
% to play around with this file if you do not know what you are doing!
% Please leave this comment!
% -_- DebPkgProvidedMaps -_-
%
EOF
		open (BAR,"$DataGlobalPath/texmf/tex/generic/config/language.us")
		or die("Cannot open $DataGlobalPath/texmf/tex/generic/config/language.us");
		while (<BAR>) { print FOO $_; }
		close (BAR);
		close (FOO);
	}
	#
	# EXECUTE ACTIONS
	#
	my @Executes = get_all_executes($package,$globalreclevel);
	my $gotmapfiles = 0;
	my $firstlang =1;
	my %langhash = ();
	my %formathash = ();
	$opt_debug && print "Executes= @Executes\n";
	my %Job;
	foreach (@Executes) {
		my @p = /([^=]+)=([^ ]+)\s+([^=]+)=([^ ]+)\s*([^=]*)=?(.*)/;
		$Job{'parameter'} = $Job{'function'} = $Job{'mode'} = '';
		$Job{$p[0]}=$p[1];
		$Job{$p[2]}=$p[3];
		$Job{$p[4]}=$p[5];
		my $instcmd;
		my $rmcmd;
		if ($Job{'function'} eq 'addMap') {
			if (!$gotmapfiles) {
				&mkpath("$etcdest/updmap.d/");
				open(UPDMAPCFG, ">$etcdest/updmap.d/10$package.cfg")
				    or die("Cannot open $etcdest/updmap.d/10$package.cfg");
				print UPDMAPCFG <<EOF;
# 10$package.cfg
# You can change/add entries to this file and changes will be preserved
# over upgrades, even if you have removed the main package prior
# (not if you purged it). YOu should leave the following pseudo comment
# present in the file!
# -_- DebPkgProvidedMaps -_-
#
EOF
				$gotmapfiles = 1;
			}
			my $name=$Job{'parameter'};
			if ($Job{'mode'} eq 'mixed') {
				print UPDMAPCFG "Mixed";
			}
			print UPDMAPCFG "Map $name\n";
		} elsif ($Job{'function'} eq 'BuildFormat') {
			my $name=$Job{'parameter'};
			$formathash{$name} = 1;
		} elsif ($Job{'function'} eq 'BuildLanguageDat') {
			my $name=$Job{'parameter'};
			$langhash{$name} = 1;
		}
	}
	#
	# additional files to be created
	#
	my @formats = keys %formathash;
	#
	# Formats
	#
	if ($#formats >= 0) {
		&mkpath("$etcdest/fmt.d/");
		&mkpath("$basedir/var/lib/tex-common/fmtutil-cnf/");
		open(LISTFILE, ">>$basedir/var/lib/tex-common/fmtutil-cnf/$package.list")
		    or die("Cannot open $basedir/var/lib/tex-common/fmtutil-cnf/$package.list");
		print LISTFILE "10$package\n";
		close LISTFILE;
		open(FOO, ">$etcdest/fmt.d/10$package.cnf") 
		    or die("Cannot open $etcdest/fmt.d/10$package.cnf") ;
		print FOO <<EOF;
# 
# 10$package.cnf
#
# You really can change stuff in this file, but it is NOT RECOMMENDED
# to play around with this file if you do not know what you are doing!
# Please leave this comment!
# -_- DebPkgProvidedMaps -_-
#
EOF
		foreach my $f (@formats) {
		open(INFILE,"<$DataGlobalPath/texmf/fmtutil/format.$f.cnf")
		    or die("Cannot open $DataGlobalPath/texmf/fmtutil/format.$f.cnf");
			my @lines = <INFILE>;
			close(INFILE);
			print FOO @lines;
		}
		close(FOO);
	}
	#
	# Map files
	#
	if ($gotmapfiles) {
		# We have to call update-updmap and updmap-sys, but also create
		# a file in /var/lib/tex-common/fontmap-cfg/pkgname.list
		#/ containing all the files put into /etc/texmf/updmap.d/
		&mkpath("$basedir/var/lib/tex-common/fontmap-cfg/");
		open(LISTFILE, ">$basedir/var/lib/tex-common/fontmap-cfg/$package.list")
		    or die("Cannot open $basedir/var/lib/tex-common/fontmap-cfg/$package.list");
		print LISTFILE "10$package\n";
		close LISTFILE;
		close UPDMAPCFG;
	}
	#
	# Languages
	#
	my @langs = keys %langhash;
	if ($#langs >= 0) {
		&mkpath("$etcdest/language.d/");
		&mkpath("$basedir/var/lib/tex-common/language-cnf/");
		open(LISTFILE, ">>$basedir/var/lib/tex-common/language-cnf/$package.list")
		    or die("$basedir/var/lib/tex-common/language-cnf/$package.list");
		print LISTFILE "10$package\n";
		close LISTFILE;
		open(LANGMAPCNF, ">$etcdest/language.d/10$package.cnf")
		    or die("Cannot open $etcdest/language.d/10$package.cnf");
		print LANGMAPCNF <<EOF;
% 10$package.cnf
%
% You really can change stuff in this file, but it is NOT RECOMMENDED
% to play around with this file if you do not know what you are doing!
% Please leave this comment!
% -_- DebPkgProvidedMaps -_-
%
EOF
		foreach my $lang (keys %langhash) {
			open(INFILE,"<$DataGlobalPath/texmf/tex/generic/config/language.$lang.dat")
			    or die("Cannot open $DataGlobalPath/texmf/tex/generic/config/language.$lang.dat");
			while (<INFILE>) {
				#
				# do NOT disable any language, users should only choose
				# those languages they are interested in. AND, I should
				# make a debconf question which languages should be
				# installed/activated!!!
				# if ("$lang" eq "py") { print LANGMAPCNF "% "; }
				print LANGMAPCNF "$_";
			}
			close(INFILE);
		}
		close(LANGMAPCNF);
	}
	#
	# Work on @SpecialActions
	#
	my @infofiles = ();
	foreach my $l (@SpecialActions) {
		my ($act, $fname) = ($l =~ m/(.*):(.*)/);
		if ($act eq "install-info") {
			push @infofiles, "$fname";
		} else {
			print "Unknown action, huuu, where does this come from: $act, exit!\n";
			exit 1;
		}
	}
	if ($#infofiles >=0) {
		open(INFOLIST, ">$debdest/$package.info")
		    or die("Cannot open $debdest/$package.info");
		foreach my $f (@infofiles) {
			print INFOLIST "$f\n";
		}
		close(INFOLIST);
	}
	#
	# create the maintainer scripts
	#
	make_maintainer($package,$debdest);
}

#
# make_maintainer
#
# create maintainer scripts
#
sub make_maintainer {
	# my functions
	sub merge_into {
		my ($fname, $fhandle) = @_;
		if (-r "$fname") {
			open(FOO,"<$fname")
			    or die("Cannot open $fname");
			while (<FOO>) { print $fhandle $_; }
		}
	}
	# real start
	my ($package,$destination) = @_;
	my @Executes = get_all_executes($package,$globalreclevel);
	$debdest = $destination;
	&mkpath($debdest);
	my $gotmapfiles = 0;
	my $firstlang = 1;
	my %langhash = ();
	my %formathash = ();
	my %Job;
	$opt_debug && print "Executes= @Executes\n";
	foreach (@Executes) {
		my @p = /([^=]+)=([^ ]+)\s+([^=]+)=([^ ]+)\s*([^=]*)=?(.*)/;
		$Job{'parameter'} = $Job{'function'} = $Job{'mode'} = '';
		$Job{$p[0]}=$p[1];
		$Job{$p[2]}=$p[3];
		$Job{$p[4]}=$p[5];
		my $instcmd;
		my $rmcmd;
		if ($Job{'function'} eq 'addMap')
		{
			if (!$gotmapfiles) {
				$gotmapfiles = 1;
			}
		}
		elsif ($Job{'function'} eq 'BuildFormat')
		{
			my $name=$Job{'parameter'};
			$formathash{$name} = 1;
		} elsif ($Job{'function'} eq 'BuildLanguageDat') {
			my $name=$Job{'parameter'};
			$langhash{$name} = 1;
		}
	}
	my @formats = keys %formathash;
	my @alines = ();
	my @blines = ();
	my $allformatsbuild = 0;
	#
	# it doesn't hurt to call all three of them in any case!
	#
	$package eq "texlive-common" || push @alines, "update-texmf";
	$package eq "texlive-common" || push @alines, "update-language";
	$package eq "texlive-common" || push @alines, "update-fmtutil";
	$package eq "texlive-common" || push @alines, "update-updmap --quiet";
	#
	# POSTINST HANDLING
	#
	if ($package eq "texlive") {
		# do nothing, texlive does not include any real files, so 
		# no call to mktexlsr necessary
	} elsif (($package =~ m/texlive-doc-/) || ($package eq "texlive-common")) {
		push @blines, "if which mktexlsr > /dev/null ; then update_lsr_files ; fi";
	} else {
		push @blines, "update_lsr_files";
	}
	if ($package eq 'texlive-base') {
		push @blines, "rm -f /var/lib/texmf/web2c/latex.fmt /var/lib/texmf/web2c/latex.log /var/lib/texmf/web2c/pdflatex.fmt /var/lib/texmf/web2c/pdflatex.log";
		push @blines, "build_format --all";
		$allformatsbuild = 1;
	}
	if ($package eq 'texlive-base-bin') {
		push @blines, "rm -f /var/lib/texmf/web2c/latex.fmt /var/lib/texmf/web2c/latex.log /var/lib/texmf/web2c/pdflatex.fmt /var/lib/texmf/web2c/pdflatex.log";
		push @blines, "build_format --all";
		$allformatsbuild = 1;
	}
	#
	# Formats
	#
	my @doneformats = ();
	if ($#formats >= 0) {
		foreach my $f (@formats) {
			open(INFILE,"<$DataGlobalPath/texmf/fmtutil/format.$f.cnf")
			    or die("Cannot open $DataGlobalPath/texmf/fmtutil/format.$f.cnf");
			my @lines = <INFILE>;
			close(INFILE);
			my @actualformats = grep(!/(^\s*#)|(^\s*$)/, @lines);
			foreach my $l (@actualformats) {
				my @bar = reverse(split(' ',$l));
				my $fmt = pop(@bar);
				#
				# remove old fmt file if it is present
				#
				push @alines, "rm -f /var/lib/texmf/web2c/$fmt.*";
				$allformatsbuild || push @blines, "build_format --byfmt $fmt";
				push @doneformats, $fmt;
			}
		}
	}
	my @extraformats = ();
	if ((defined($TeXLive{'binary'}{$package}{'extra_format'})) && (!$allformatsbuild)) {
		foreach my $fmt (keys %{$TeXLive{'binary'}{$package}{'extra_format'}}) {
			if (!ismember($fmt,@doneformats)) {
				push @extraformats, $fmt;
			}
		}
	}
	foreach my $fmt (@extraformats) {
		push @alines, "rm -f /var/lib/texmf/web2c/$fmt.*";
		if ($TeXLive{'binary'}{$package}{'extra_format'}{$fmt} eq "0") {
			push @blines, "build_format --byfmt $fmt";
		} elsif ($TeXLive{'binary'}{$package}{'extra_format'}{$fmt} eq "1") {
			push @blines, "build_format_if_format_exists --byfmt $fmt";
		} else {
			push @blines, "build_format_if_file_exists --byfmt $fmt $TeXLive{'binary'}{$package}{'extra_format'}{$fmt}";
		}
	}
	#
	# Map files
	#
	if ($gotmapfiles) {
		# We have to call update-updmap and updmap-sys, but also create
		# a file in /var/lib/tex-common/fontmap-cfg/pkgname.list
		#/ containing all the files put into /etc/texmf/updmap.d/
		push @blines, "create_fontmaps";
	}
	#
	# Languages
	#
	my @langs = keys %langhash;
	if ($#langs >= 0) {
		#
		# Again a problem with texmf-config settings and fmtutil-sys not
		# finding language.dat in the right position.
		#
		push @blines, "build_format_if_format_exists --byhyphen latex `kpsewhich language.dat`";
	}
	if (($#alines >= 0) || 
		($#blines >= 0) || 
		(-r "$debdest/postinst.pre") || 
		(-r "$debdest/postinst.post") || 
		(-r "$debdest/$package.postinst.pre") || 
		(-r "$debdest/$package.postinst.post")) {
		open(POSTINST, ">$debdest/$package.postinst")
		    or die("Cannot open $debdest/$package.postinst");
		print POSTINST "#!/bin/sh -e\n";
		merge_into("$debdest/common.functions", POSTINST);
		merge_into("$debdest/common.functions.postinst", POSTINST);
		#
		# first we merge the .pre parts into the scripts
		#
		merge_into("$debdest/postinst.pre", POSTINST);
		merge_into("$debdest/$package.postinst.pre", POSTINST);
		print POSTINST <<'EOF';
case "$1" in
	configure|abort-upgrade|abort-remove|abort-deconfigure)
EOF
		foreach my $a (@alines) {
			print POSTINST "\t", $a, "\n";
		}
		foreach my $b (@blines) {
			print POSTINST "\t", $b, "\n";
		}
		print POSTINST <<'EOF';
	;;
	*)
		echo "postinst called with unknown argument '$1'" >&2
	exit 1
	;;
esac

EOF
		print POSTINST "\n#DEBHELPER#\n";
		merge_into("$debdest/$package.postinst.post", POSTINST);
		merge_into("$debdest/postinst.post", POSTINST);
		print POSTINST "exit 0\n";
		close POSTINST;
	}
	#
	# END OF POSTINST STUFF
	#
	#
	# PREINST STUFF
	#
	# only create the preinst file *if* there is a content!
	# if there is a debhelper entry, it will create it if necessary
	if ((-r "$debdest/$package.preinst.pre") || 
		(-r "$debdest/$package.preinst.post") ||
		(-r "$debdest/preinst.pre") ||
		(-r "$debdest/preinst.post") ||
		($#configfiles >= 0)) {
		open(PREINST, ">$debdest/$package.preinst")
                    or die("Cannot open $debdest/$package.preinst");
		print PREINST "#!/bin/sh -e\n";
		merge_into("$debdest/common.functions", PREINST);
		merge_into("$debdest/common.functions.preinst", PREINST);
		merge_into("$debdest/preinst.pre", PREINST);
		merge_into("$debdest/$package.preinst.pre", PREINST);
		foreach my $cf (@configfiles) {
			print PREINST "handle_config_file_preinst $cf\n"
		}
		print PREINST "\n#DEBHELPER#\n";
		merge_into("$debdest/$package.preinst.post", PREINST);
		merge_into("$debdest/preinst.post", PREINST);
		print PREINST "exit 0\n";
		close PREINST;
	}
	#
	# END OF PREINST STUFF
	#
	#
	# PRERM STUFF
	#
	# only create the prerm file *if* there is a content!
	# if there is a debhelper entry, it will create it if necessary
	if ((-r "$debdest/$package.prerm.pre") || 
		(-r "$debdest/$package.prerm.post") ||
		(-r "$debdest/prerm.pre") ||
		(-r "$debdest/prerm.post")) {
		open(PRERM, ">$debdest/$package.prerm")
                    or die("Cannot open $debdest/$package.prerm");
		print PRERM "#!/bin/sh -e\n";
		merge_into("$debdest/common.functions", PRERM);
		merge_into("$debdest/common.functions.prerm", PRERM);
		merge_into("$debdest/prerm.pre", PRERM);
		merge_into("$debdest/$package.prerm.pre", PRERM);
		print PRERM "\n#DEBHELPER#\n";
		merge_into("$debdest/$package.prerm.post", PRERM);
		merge_into("$debdest/prerm.post", PRERM);
		print PRERM "exit 0\n";
		close PRERM;
	}
	#
	# END OF PRERM STUFF
	#
	# POSTRM STUFF
	# on remove:
	# 		call update-updmap and updmap-sys
	# 		call update-language and fmtutil-sys --byhyphen
	# 		call update-fmtutil and remove old formats
	# on purge etc:
	# 		do nothing
	#
	@alines = ();
	@blines = ();
	#
	# Formats
	# 
    if ($package eq "texlive") {
	        # do nothing, texlive does not include any real files, so
			# no call to mktexlsr necessary
	} else {
		push @blines, "check_run_without_errors mktexlsr";
	}
	if ($#formats >= 0) {
		foreach my $f (@formats) {
		open(INFILE,"<$DataGlobalPath/texmf/fmtutil/format.$f.cnf")
		    or die("Cannot open $DataGlobalPath/texmf/fmtutil/format.$f.cnf");
			my @lines = <INFILE>;
		my @actualformats = grep(!/(^\s*#)|(^\s*$)/, @lines);
		foreach my $l (@actualformats) {
			my @bar = reverse(split(' ',$l));
			my $fmt = pop(@bar);
		push @alines, "rm -f /var/lib/texmf/web2c/$fmt.*";
		}
			close(INFILE);
	}
	}
	foreach my $fmt (@extraformats) {
		push @alines, "rm -f /var/lib/texmf/web2c/$fmt.*";
	}
	if (($#formats >= 0) || ($#extraformats >= 0)) {
		push @alines, "check_run_without_errors update-fmtutil";
	}
	#
	# Map files
	#
	if ($gotmapfiles) {
		push @alines, "check_run_without_errors update-updmap";
		push @blines, "check_run_without_errors updmap-sys";
	}
	#
	# Languages
	# 
	@langs = keys %langhash;
	if ($#langs >= 0) {
		#
		# Again a problem with texmf-config settings and fmtutil-sys not
		# finding language.dat in the right position.
		#
		push @alines, "check_run_without_errors update-language";
		push @blines, "if which fmtutil-sys >/dev/null ; then";
		push @blines, "\tbuild_format_if_format_exists --byhyphen latex `kpsewhich language.dat`";
		push @blines, "fi";
	}
	if (($#alines >= 0) || 
		($#blines >= 0) || 
		(-r "$debdest/$package.postrm.pre") || 
		(-r "$debdest/$package.postrm.pre") || 
		(-r "$debdest/postrm.pre") || 
		(-r "$debdest/postrm.post")) {
		open(POSTRM, ">$debdest/$package.postrm")
                    or die("Cannot open $debdest/$package.postrm");
		print POSTRM "#!/bin/sh -e\n";
		merge_into("$debdest/common.functions", POSTRM);
		merge_into("$debdest/common.functions.postrm", POSTRM);
		#
		# first we merge the .pre parts into the scripts
		#
		merge_into("$debdest/postrm.pre", POSTRM);
		merge_into("$debdest/$package.postrm.pre", POSTRM);
		#
		print POSTRM <<'EOF';

case "$1" in
  remove|disappear)
EOF
		foreach my $a (@alines) {
			print POSTRM "\t", $a, "\n";
		}
		foreach my $b (@blines) {
			print POSTRM "\t", $b, "\n";
		}
		print POSTRM <<'EOF';
	;;
	purge|upgrade|failed-upgrade|abort-upgrade|abort-install)
	;;
	*)
		echo "postrm called with unknown argument '$1'" >&2
	exit 1
	;;
esac

EOF
		print POSTRM "\n#DEBHELPER#\n";
		merge_into("$debdest/$package.postrm.post", POSTRM);
		merge_into("$debdest/postrm.post", POSTRM);
		print POSTRM "exit 0\n";
		close POSTRM;
	}
	#
	# END OF POSTRM STUFF
	#
}


#
# do_remap_and_copy
#
sub do_remap_and_copy {
	# my functions
	#
	# here the mapping from texlive pathes to debian pathes is done
	#
	sub make_destinationname {
		my ($o) = @_;
		$o =~ s#texmf-dist#$texmfdist#;
		$o =~ s#texmf-doc#$texmfdist#;
		#
		# we do map *ALL* files into $texmfdist, not only the dist files
		#
		$o =~ s#texmf/#$texmfdist/#;
		return($o);
	}
	# real start
	my ($f,$standarddest,$finalremap,$finaldest) = @_;
	my $gotremapped = 0;
	my $returnvalue = "**NOTSET**";

	my $destname = make_destinationname($f);
	$opt_debug && print "DESTINATION NAME = $destname\n";
	MAPPINGS: foreach my $maplines (@{$TeXLive{'all'}{'filemappings'}}) {
		my ($pat, $dest) = ($maplines =~ m/(.*):(.*)/);
		if ($f =~ m|$pat$|) {
			$gotremapped = 1;
			my $act = $TeXLive{'all'}{'file_map_actions'}{$pat};
			my $newdest;
			my $foo="\$newdest = \"$dest\"";
			eval $foo;
			$opt_debug && print "REMAP HIT f=$f\nnewdest=$newdest\npat=$pat\ndest=$dest\n";
			# if you add possible actions here, also add them to the list in tpm2deb.cfg
			if ($act eq "remap") {
				&mkpath(dirname($newdest));
				mycopy("$DataGlobalPath/$f",$newdest);
				$returnvalue = $newdest;
			} elsif ($act eq "copy") {
				# mapping;origfile;copy;TEXMF-tree-base
				# eg
				# mapping;temxf/tex/latex/pict2e/pict2e.cfg;copy;/etc/texmf
				#
				# first install it into the normal path
				mycopy("$DataGlobalPath/$f","$standarddest/$destname");
				&mkpath("$basedir/$newdest");
				# remove the leading texmf{-dist,-doc,}/
				my $o = $f;
				$o =~ s#texmf-dist#texmf#;
				$o =~ s#texmf-doc#texmf#;
				$o =~ s#texmf/##;
				mycopy("$DataGlobalPath/$f","$basedir$newdest/$o");
				$returnvalue = "$basedir$newdest/$o";
			} elsif ($act eq "config-copy") {
				# mapping;origfile;config-copy;TEXMFSYSCONFIGPATH
				# eg
				# mapping;temxf/tex/generic/language.dat;config-copy;/etc/texmf
				#
				# first install it into the normal path
				mycopy("$DataGlobalPath/$f","$standarddest/$destname");
				&mkpath("$basedir/$newdest");
				# remove the leading texmf{-dist,-doc,}/
				my $o = $f;
				$o =~ s#texmf-dist#texmf#;
				$o =~ s#texmf-doc#texmf#;
				$o =~ s#texmf/##;
				mycopy("$DataGlobalPath/$f","$basedir$newdest/$o");
				$returnvalue = "$standarddest/$destname";
				push @configfiles, "$newdest/$o";
			} elsif ($act eq "link") {
				&mkpath(dirname("$standarddest/$destname"));
				symlink($newdest, "$standarddest/$destname") or
					die "Cannot symlink $standarddest/$destname -> $newdest: $!\n"; 
				$returnvalue = $newdest;
			} elsif ($act eq "config-link") {
				# config-link is LIKE remap-link, only that we maybe can 
				# add some automatic specialities for config-file 
				# maintainer script magic
				# remap and link from the original destination
				&mkpath(dirname("$basedir$newdest"));
				mycopy("$DataGlobalPath/$f","$basedir/$newdest");
				# we have to strip of the $debdest part
				&mkpath(dirname("$standarddest/$destname"));
				symlink($newdest, "$standarddest/$destname") or
					die "Cannot symlink $standarddest/$destname -> $newdest: $!\n"; 
				$returnvalue = $newdest; ## ?? or $destname????
				push @configfiles, $newdest;
			} elsif ($act eq "remap-link") {
				# remap and link from the original destination
				&mkpath(dirname($newdest));
				mycopy("$DataGlobalPath/$f",$newdest);
				# we have to strip of the $debdest part
				$foo = $newdest;
				$foo =~ s/^$basedir//;
				&mkpath(dirname("$standarddest/$destname"));
				symlink($foo, "$standarddest/$destname") or
					die "Cannot symlink $standarddest/$destname -> $newdest: $!\n"; 
				$returnvalue = $newdest; ## ?? or $destname????
			} elsif ($act eq "add-link") {
				#print "DEBUG: f=$f\nDEBUG: destname=$destname\nDEBUG: newdest=$newdest\n";
				mycopy("$DataGlobalPath/$f","$standarddest/$destname");
				&mkpath(dirname($newdest));
				$b = "$standarddest/$destname";
				symlink($b,$newdest) or
					die "Cannot symlink, $newdest -> $b: $!\n";
				$returnvalue = "$standarddest/$destname";
			} elsif ($act eq "replace-link") {
				my ($a,$b) = split(/%/,$newdest);
				&mkpath(dirname($a));
				symlink($b,$a) or die "Cannot symlink $a -> $b: $!\n";
				$returnvalue = $b;
			} elsif ($act eq "") {
				$returnvalue = "";
				# do nothing, the file is killed
			} else {
				print "maplines=$maplines\nact = $TeXLive{'all'}{'file_map_actions'}{$pat}\n";
				print "Unknown action $act in config file, terminating!\n";
				exit 1;
			}
			last MAPPINGS;
		}
	}
	if ($gotremapped == 0) {
		if ($finalremap ne "" && $destname =~ m|$finalremap|) {
			my $foo="\$finaldest = \"$finaldest\"";
			eval $foo;
			&mkpath(dirname($finaldest));
			mycopy("$DataGlobalPath/$f",$finaldest);
			$returnvalue = $finaldest;
		} else {
			$opt_debug && print "NORMAL COPY: $standarddest/$destname\n";
			&mkpath(dirname("$standarddest/$destname"));
			mycopy("$DataGlobalPath/$f","$standarddest/$destname");
			$returnvalue = "$standarddest/$destname";
		}
	}
	return($returnvalue);
}

### Local Variables:
### perl-indent-level: 4
### tab-width: 4
### indent-tabs-mode: t
### End:
# vim:set tabstop=4: #
