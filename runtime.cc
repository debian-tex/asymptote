/***** Autogenerated from runtime.in; changes will be overwritten *****/

#line 1 "runtime.in"
/*****
 * runtime.in
 * Tom Prince 2005/4/15
 *
 * Generate the runtime functions used by the vm::stack machine.
 *
 *****/

/* Autogenerated routines are specified like this (separated by a formfeed):
type asyname:cname(cparams)
{
  C code
}

*/

// Use Void f() instead of void f() to force an explicit Stack argument.


#line 63 "runtime.in"
#include <cfloat>
#include <time.h>
#include <sys/times.h>
#include <locale.h>
  
#include "angle.h"
#include "pair.h"
#include "triple.h"
#include "transform.h"
#include "path.h"
#include "path3.h"
#include "pen.h"
#include "guide.h"
#include "picture.h"
#include "drawpath.h"
#include "drawpath3.h"
#include "drawsurface.h"
#include "drawfill.h"
#include "drawclipbegin.h"
#include "drawclipend.h"
#include "drawlabel.h"
#include "drawverbatim.h"
#include "drawgsave.h"
#include "drawgrestore.h"
#include "drawlayer.h"
#include "drawimage.h"
#include "drawgroup.h"
#include "fileio.h"
#include "genv.h"
#include "builtin.h"
#include "texfile.h"
#include "pipestream.h"
#include "parser.h"
#include "stack.h"
#include "util.h"
#include "locate.h"
#include "mathop.h"
#include "callable.h"
#include "stm.h"
#include "lexical.h"
#include "process.h"
#include "arrayop.h"
#include "predicates.h"
#include "Delaunay.h"
   
#ifdef HAVE_LIBFFTW3
#include "fftw++.h"
#endif
  
#if defined(HAVE_LIBREADLINE) && defined(HAVE_LIBCURSES)
#include <readline/readline.h>
#include <readline/history.h>
#endif

#if defined(USEGC) && defined(GC_DEBUG) && defined(GC_BACKTRACE)
extern "C" {
void *GC_generate_random_valid_address(void);
void GC_debug_print_heap_obj_proc(void *);
}
#endif

using namespace vm;
using namespace camp;
using namespace settings;

namespace run {
using camp::pair;
using vm::array;
using vm::frame;
using vm::stack;
using camp::transform;
using absyntax::runnable;

typedef double real;

#define CURRENTPEN processData().currentpen

typedef array boolarray;
typedef array Intarray;
typedef array Intarray2;
typedef array realarray;
typedef array realarray2;
typedef array pairarray;
typedef array pairarray2;
typedef array triplearray;
typedef array triplearray2;
typedef array patharray;
typedef array patharray2;
typedef array guidearray;
typedef array transformarray;
typedef array penarray;
typedef array penarray2;
typedef array stringarray;
typedef array stringarray2;
  
typedef callable callableBp;
typedef callable callableReal;
typedef callable callableTransform;
}

using vm::array;
using types::function;

#define PRIMITIVE(name,Name,asyName)  using types::prim##Name;
#include <primitives.h>
#undef PRIMITIVE

using types::boolArray;
using types::IntArray;
using types::IntArray2;
using types::realArray;
using types::realArray2;
using types::pairArray;
using types::pairArray2;
using types::tripleArray;
using types::tripleArray2;
using types::pathArray;
using types::pathArray2;
using types::guideArray;
using types::transformArray;
using types::penArray;
using types::penArray2;
using types::stringArray;
using types::stringArray2;
using types::formal;

function *voidFunction()
{
  return new function(primVoid());
}

function *breakpointFunction()
{
  return new function(primString(),primString(),primInt(),primInt(),
  primCode());
}

function *realRealFunction()
{
  return new function(primReal(),primReal());
}

function *transformFunction()
{
  return new function(primTransform());
}

function *realTripleFunction()
{
  return new function(primReal(),primTriple());
}

const size_t camp::ColorComponents[]={0,0,1,3,4,0};

namespace vm {
}

namespace run {
  
const char *arrayempty="cannot take min or max of empty array";

static inline Int Round(double x) 
{
  return Int(x+((x >= 0) ? 0.5 : -0.5));
}

inline Int sgn(double x) 
{
  return (x > 0.0 ? 1 : (x < 0.0 ? -1 : 0));
}

void outOfBounds(const char *op, size_t len, Int n)
{
  ostringstream buf;
  buf << op << " array of length " << len << " with out-of-bounds index " << n;
  error(buf);
}

inline item& arrayRead(array *a, Int n)  
{
  size_t len=checkArray(a);
  bool cyclic=a->cyclic();
  if(cyclic && len > 0) n=imod(n,len);
  else if(n < 0 || n >= (Int) len) outOfBounds("reading",len,n);
  return (*a)[(unsigned) n];
}

// Helper function to create deep arrays.
static array* deepArray(Int depth, Int *dims)
{
  assert(depth > 0);
  
  if (depth == 1) {
    return new array(dims[0]);
  } else {
    Int length = dims[0];
    depth--; dims++;

    array *a = new array(length);

    for (Int index = 0; index < length; index++) {
      (*a)[index] = deepArray(depth, dims);
    }
    return a;
  }
}
  
array *nop(array *a) 
{
  return a;
}
  
array *Identity(Int n)
{
  size_t N=(size_t) n;
  array *c=new array(N);
  for(size_t i=0; i < N; ++i) {
    array *ci=new array(N);
    (*c)[i]=ci;
    for(size_t j=0; j < N; ++j)
      (*ci)[j]=0.0;
   (*ci)[i]=1.0;
  }
  return c;
}

array *copyArray(array *a)
{
  size_t size=checkArray(a);
  array *c=new array(size);
  for(size_t i=0; i < size; i++) 
    (*c)[i]=(*a)[i];
  return c;
}

inline size_t checkdimension(array *a, size_t dim)
{
  size_t size=checkArray(a);
  if(dim && size != dim) {
    ostringstream buf;
    buf << "array of length " << dim << " expected" << endl;
    error(buf);
  }
  return size;
}

double *copyArrayC(array *a, size_t dim=0)
{
  size_t size=checkdimension(a,dim);
  double *c=new double[size];
  for(size_t i=0; i < size; i++) 
    c[i]=read<double>(a,i);
  return c;
}

triple *copyTripleArrayC(array *a, size_t dim=0)
{
  size_t size=checkdimension(a,dim);
  triple *c=new triple[size];
  for(size_t i=0; i < size; i++) 
    c[i]=read<triple>(a,i);
  return c;
}

array *copyArray2(array *a)
{
  size_t size=checkArray(a);
  array *c=new array(size);
  for(size_t i=0; i < size; i++) {
    array *ai=read<array*>(a,i);
    size_t aisize=checkArray(ai);
    array *ci=new array(aisize);
    (*c)[i]=ci;
    for(size_t j=0; j < aisize; j++) 
      (*ci)[j]=(*ai)[j];
  }
  return c;
}

array *copyArray3(array *a)
{
  size_t size=checkArray(a);
  array *c=new array(size);
  for(size_t i=0; i < size; i++) {
    array *ai=read<array*>(a,i);
    size_t aisize=checkArray(ai);
    array *ci=new array(aisize);
    (*c)[i]=ci;
    for(size_t j=0; j < aisize; j++) {
      array *aij=read<array*>(ai,j);
      size_t aijsize=checkArray(aij);
      array *cij=new array(aijsize);
      (*ci)[j]=cij;
      for(size_t k=0; k < aijsize; k++) 
	(*cij)[k]=(*aij)[k];
    }
  }
  return c;
}

double *copyArray2C(array *a, bool square=true, size_t dim2=0)
{
  size_t n=checkArray(a);
  size_t m=(square || n == 0) ? n : checkArray(read<array*>(a,0));
  if(n > 0 && dim2 && m != dim2) {
    ostringstream buf;
    buf << "second matrix dimension must be " << dim2 << endl;
    error(buf);
  }
  
  double *c=new double[n*m];
  for(size_t i=0; i < n; i++) {
    array *ai=read<array*>(a,i);
    size_t aisize=checkArray(ai);
    if(aisize == m) {
      double *ci=c+i*m;
      for(size_t j=0; j < m; j++) 
	ci[j]=read<double>(ai,j);
    } else
      error(square ? "matrix must be square" : "matrix must be rectangular");
  }
  return c;
}

static const char *incommensurate="Incommensurate matrices";
static const char *singular="Singular matrix";
static size_t *pivot,*Row,*Col;

triple operator *(const array& t, const triple& v)
{
  size_t n=checkArray(&t);
  if(n != 4) error(incommensurate);
  array *t0=read<array*>(t,0);
  array *t1=read<array*>(t,1);
  array *t2=read<array*>(t,2);
  array *t3=read<array*>(t,3);
  
  if(checkArray(t0) != 4 || checkArray(t1) != 4 || 
     checkArray(t2) != 4 || checkArray(t3) != 4)
    error(incommensurate);

  double x=v.getx();
  double y=v.gety();
  double z=v.getz();
  
  double f=read<real>(t3,0)*x+read<real>(t3,1)*y+read<real>(t3,2)*z+
    read<real>(t3,3);
  if(f == 0.0) run::dividebyzero();
  f=1.0/f;
  
  return triple((read<real>(t0,0)*x+read<real>(t0,1)*y+read<real>(t0,2)*z+
		 read<real>(t0,3))*f,
		(read<real>(t1,0)*x+read<real>(t1,1)*y+read<real>(t1,2)*z+
		 read<real>(t1,3))*f,
		(read<real>(t2,0)*x+read<real>(t2,1)*y+read<real>(t2,2)*z+
		 read<real>(t2,3))*f);
}

triple multshiftless(const array& t, const triple& v)
{
  size_t n=checkArray(&t);
  if(n != 4) error(incommensurate);
  array *t0=read<array*>(t,0);
  array *t1=read<array*>(t,1);
  array *t2=read<array*>(t,2);
  array *t3=read<array*>(t,3);
  
  if(checkArray(t0) != 4 || checkArray(t1) != 4 || 
     checkArray(t2) != 4 || checkArray(t3) != 4)
    error(incommensurate);

  double x=v.getx();
  double y=v.gety();
  double z=v.getz();
  
  double f=read<real>(t3,0)*x+read<real>(t3,1)*y+read<real>(t3,2)*z+
    read<real>(t3,3);
  if(f == 0.0) run::dividebyzero();
  f=1.0/f;
  
  return triple((read<real>(t0,0)*x+read<real>(t0,1)*y+read<real>(t0,2)*z)*f,
		(read<real>(t1,0)*x+read<real>(t1,1)*y+read<real>(t1,2)*z)*f,
		(read<real>(t2,0)*x+read<real>(t2,1)*y+read<real>(t2,2)*z)*f);
}

static inline void inverseAllocate(size_t n)
{
  pivot=new size_t[n];
  Row=new size_t[n];
  Col=new size_t[n];
}

static inline void inverseDeallocate()
{
  delete[] pivot;
  delete[] Row;
  delete[] Col;
}

void writestring(stack *s)
{
  callable *suffix=pop<callable *>(s,NULL);
  string S=pop<string>(s);
  vm::item it=pop(s);
  bool defaultfile=isdefault(it);
  camp::file *f=defaultfile ? &camp::Stdout : vm::get<camp::file*>(it);
  if(!f->isOpen()) return;
  if(S != "") f->write(S);
  if(f->text()) {
    if(suffix) {
      s->push(f);
      suffix->call(s);
    } else if(defaultfile) f->writeline();
  }
}

void checkSquare(array *a) 
{
  size_t n=checkArray(a);
  for(size_t i=0; i < n; i++)
    if(checkArray(read<array*>(a,i)) != n)
      error("matrix a must be square");
}

// Crout's algorithm for computing the LU decomposition of a square matrix.
// cf. routine ludcmp (Press et al.,  Numerical Recipes, 1991).
Int LUdecompose(double *a, size_t n, size_t* index, bool warn=true)
{
  double *vv=new double[n];
  Int swap=1;
  for(size_t i=0; i < n; ++i) {
    double big=0.0;
    double *ai=a+i*n;
    for(size_t j=0; j < n; ++j) {
      double temp=fabs(ai[j]);
      if(temp > big) big=temp;
    }
    if(big == 0.0) {
      delete[] vv;
      if(warn) error(singular);
      else return 0;
    }
    vv[i]=1.0/big;
  }
  for(size_t j=0; j < n; ++j) {
    for(size_t i=0; i < j; ++i) {
      double *ai=a+i*n;
      double sum=ai[j];
      for(size_t k=0; k < i; ++k) {
	sum -= ai[k]*a[k*n+j];
      }
      ai[j]=sum;
    }
    double big=0.0;
    size_t imax=j;
    for(size_t i=j; i < n; ++i) {
      double *ai=a+i*n;
      double sum=ai[j];
      for(size_t k=0; k < j; ++k)
	sum -= ai[k]*a[k*n+j];
      ai[j]=sum;
      double temp=vv[i]*fabs(sum);
      if(temp >= big) {
	big=temp;
	imax=i;
      }
    }
    double *aj=a+j*n;
    double *aimax=a+imax*n;
    if(j != imax) {
      for(size_t k=0; k < n; ++k) {
	double temp=aimax[k];
	aimax[k]=aj[k];
	aj[k]=temp;
      }
      swap *= -1;
      vv[imax]=vv[j];
    }
    if(index) 
      index[j]=imax;
    if(j != n) {
      double denom=aj[j];
      if(denom == 0.0) {
	delete[] vv;
	if(warn) error(singular);
	else return 0;
      }
      for(size_t i=j+1; i < n; ++i)
	a[i*n+j] /= denom;
    }
  }
  delete[] vv;
  return swap;
}

void dividebyzero(size_t i)
{
  ostringstream buf;
  if(i > 0) buf << "array element " << i << ": ";
  buf << "Divide by zero";
  error(buf);
}
  
void integeroverflow(size_t i)
{
  ostringstream buf;
  if(i > 0) buf << "array element " << i << ": ";
  buf << "Integer overflow";
  error(buf);
}
  
#if defined(HAVE_LIBREADLINE) && defined(HAVE_LIBCURSES)
struct historyState {
  bool store;
  HISTORY_STATE state;
};
  
typedef mem::map<CONST string, historyState> historyMap_t;
historyMap_t historyMap;
static HISTORY_STATE history_save;

// Store a deep copy of the current readline history in dest.
void store_history(HISTORY_STATE *dest)
{
  HISTORY_STATE *src=history_get_history_state();
  if(src) {
    *dest=*src;
    for(Int i=0; i < src->length; ++i)
      dest->entries[i]=src->entries[i];
    free(src);
  }
}

stringarray* get_history(Int n) 
{
  int N=intcast(n);
  if(N <= 0) N=history_length;
  else N=Min(N,history_length);
  array *a=new array((size_t) N);
  int offset=history_length-N+1;
  for(int i=0; i < N; ++i) {
    HIST_ENTRY *last=history_get(offset+i);
    string s=last ? last->line : "";
    (*a)[i]=s;
  }	
  return a;
}

string historyfilename(const string &name) 
{
  return historyname+"_"+name;
}
#endif

#if defined(HAVE_LIBREADLINE) && defined(HAVE_LIBCURSES)
int readline_startup_hook()
{
#ifdef __CYGWIN__
  rl_set_key("\\M-[3~",rl_delete,rl_get_keymap());
  rl_set_key("\\M-[2~",rl_overwrite_mode,rl_get_keymap());
#endif    
  return 0;
}

void init_readline(bool tabcompletion=true) 
{
  static bool first=true;
  if(first) {
    first=false;
#ifdef __CYGWIN__
    rl_startup_hook=readline_startup_hook;
#endif    
  }
  rl_bind_key('\t',tabcompletion ? rl_complete : rl_insert);
}
#endif

void cleanup()
{
  processDataStruct &pd=processData();
  pd.atExitFunction=NULL;
  pd.atUpdateFunction=NULL;
  pd.atBreakpointFunction=NULL;
  
#if defined(HAVE_LIBREADLINE) && defined(HAVE_LIBCURSES)
  store_history(&history_save);
  int nlines=intcast(getSetting<Int>("historylines"));
  for(historyMap_t::iterator h=historyMap.begin(); h != historyMap.end(); 
      ++h) {
    history_set_history_state(&h->second.state);
    stifle_history(nlines);
    if(h->second.store) write_history(historyfilename(h->first).c_str());
  }
  history_set_history_state(&history_save);
#endif
}

void purge()
{
#ifdef USEGC
  GC_gcollect();
#endif
}

void updateFunction(stack *Stack)
{
  callable *atUpdateFunction=processData().atUpdateFunction;
  if(atUpdateFunction && !nullfunc::instance()->compare(atUpdateFunction))
    atUpdateFunction->call(Stack);
}

void exitFunction(stack *Stack)
{
  callable *atExitFunction=processData().atExitFunction;
  if(atExitFunction && !nullfunc::instance()->compare(atExitFunction))
    atExitFunction->call(Stack);
  cleanup();
}

default_t def;
string emptystring;
array *emptyarray=new array(0);
string commentchar="#";
pair zero;

void breakpoint(stack *Stack, runnable *r)
{
  callable *atBreakpointFunction=processData().atBreakpointFunction;
  if(atBreakpointFunction &&
     !nullfunc::instance()->compare(atBreakpointFunction)) {
    position curPos=getPos();
    Stack->push<string>(curPos.filename());
    Stack->push<Int>((Int) curPos.Line());
    Stack->push<Int>((Int) curPos.Column());
    Stack->push(r ? r : item(def));
    atBreakpointFunction->call(Stack); // returns a string
  } else Stack->push<string>("");
}

}

namespace types {
extern const char *names[];
}

void checkformat(const char *ptr, bool intformat) 
{
  while(*ptr != '\0') {
    if(*ptr != '%') /* While we have regular characters, print them.  */
      ptr++;
    else { /* We've got a format specifier. */
      ptr++;
      
      while(*ptr && strchr ("-+ #0'I", *ptr)) /* Move past flags.  */
	*ptr++;

      if(*ptr == '*')
	ptr++;
      else while(isdigit(*ptr)) /* Handle explicit numeric value.  */
	ptr++;
	  
      if(*ptr == '.') {
	*ptr++; /* Go past the period.  */
	if(*ptr == '*') {
	  ptr++;
	} else
	  while(isdigit(*ptr)) /* Handle explicit numeric value.  */
	    *ptr++;
      }
      while(*ptr && strchr ("hlL", *ptr))
	*ptr++;
	  
      if(*ptr == '%') ++ptr;
      else if(*ptr != '\0') {
	if(intformat) {
	  switch(*ptr) {
	  case 'd':
	  case 'i':
	  case 'o':
	  case 'u':
	  case 'x':
	  case 'X':
	  case 'c':
	    break;
	  default:
	    ostringstream buf;
	    buf << "Invalid format '" << *ptr << "' for type " 
		<< types::names[types::ty_Int];
	    error(buf);
	    break;
	  }
	} else {
	  switch(*ptr) {
	  case 'f':
	  case 'F':
	  case 'e':
	  case 'E':
	  case 'g':
	  case 'G':
	    break;
	  default:
	    ostringstream buf;
	    buf << "Invalid format '" << *ptr << "' for type "
		<< types::names[types::ty_real];
	    error(buf);
	    break;
	  }
	}
      }
    } /* End of else statement */
  }
}
  
// Return an angle in the interval [0,360).
inline double principalBranch(double deg)
{
  if(deg < 0) deg += 360; 
  return deg;
}

static string defaulttransparency=string("Compatible");

static const string defaulttimeformat=string("%a %b %d %T %Z %Y");
#ifdef HAVE_STRFTIME
static const size_t nTime=256;
static char Time[nTime];
#endif  

void clear(string file, Int line, bool warn=false) 
{
  bpinfo bp(file,line);
  for(mem::list<bpinfo>::iterator p=bplist.begin(); p != bplist.end(); ++p) {
    if(*p == bp) {
      cout << "cleared breakpoint at " << file << ": " << line << endl;
      bplist.remove(bp);
      return;
    }
  }
  if(warn)
    cout << "No such breakpoint at "  << file << ": " << line << endl;
}

Int windingnumber(array *p, camp::pair z)
{
  size_t size=checkArray(p);
  Int count=0;
  for(size_t i=0; i < size; i++) 
    count += read<path *>(p,i)->windingnumber(z);
  return count;
}

string convertname(string name, const string& format, bool check=true)
{
  if(name.empty())
    return buildname(outname(),format,"",false);
  else
    if(check) checkLocal(name);
  return format.empty() ? name : format+":"+name;
}

callable *Func;
stack *FuncStack;
double wrapFunction(double x)
{
  FuncStack->push(x);
  Func->call(FuncStack);
  return pop<double>(FuncStack);
}

callable *compareFunc;
bool compareFunction(const vm::item& i, const vm::item& j)
{
  FuncStack->push(i);
  FuncStack->push(j);
  compareFunc->call(FuncStack);
  return pop<bool>(FuncStack);
}

void unused(void *)
{
}

pair readpair(stringstream& s, bool tex)
{
  static const double f=12.0/100.0;
  double x,y;
  s >> y;
  s >> x;
  return tex ? pair(f*x,-f*y) : pair(x,y);
}

// Ignore unclosed begingroups but not spurious endgroups.
const char *nobegin="endgroup without matching begingroup";
  
// Return the component of vector v perpendicular to a unit vector u.
inline triple perp(triple v, triple u)
{
  return v-dot(v,u)*u;
}

string ASYo="/ASYo {( ) print 12 string cvs print} bind def";
string pathforall="{(M) print ASYo ASYo} {(L) print ASYo ASYo} {(C) print ASYo ASYo ASYo ASYo ASYo ASYo} {(c) print} pathforall";
string currentpoint="print currentpoint ASYo ASYo ";

array *readpath(const string& psname, bool tex, bool keep)
{
  array *P=new array(0);
  ostringstream pipe;
  pipe << "'" << getSetting<string>("gs")
       << "' -q -dNOPAUSE -dBATCH";
  if(safe) pipe << " -dSAFER";
#ifdef __CYGWIN__
  string null="NUL";
#else
  string null="/dev/null";
#endif
  pipe << " -sDEVICE=epswrite -sOutputFile="+null+" '" << psname << "'";
  iopipestream gs(pipe.str().c_str(),"gs","Ghostscript");
  stringstream buf;
  while(true) {
    string out;
    gs >> out;
    buf << out;
    string s=buf.str();
    if(gs.tailequals(s.c_str(),s.size(),"E",1)) break;
  }
  if(verbose > 2) cout << endl;
    
  mem::vector<solvedKnot> nodes;
  solvedKnot node;
  bool cyclic=false;
  bool active=false;
  
  pair offset;
  while(!buf.eof()) {
    char c;
    buf >> c;
    switch(c) {
    case 'M':
      {
	if(active) {
	  node.post=node.point;
	  nodes.push_back(node);
	  P->push(path(nodes,nodes.size(),cyclic));
	  nodes.clear();
	}
	active=false;
	cyclic=false;
	node.pre=node.point=readpair(buf,tex)-offset;
	break;
      }
    case 'L':
      {
	pair point=readpair(buf,tex)-offset;
	static const double third=1.0/3.0;
	pair delta=(point-node.point)*third;
	node.post=node.point+delta;
	nodes.push_back(node);
	active=true;
	node.pre=point-delta;
	node.point=point;
	break;
      }
    case 'C':
      {
	pair point=readpair(buf,tex)-offset;
	pair pre=readpair(buf,tex)-offset;
	node.post=readpair(buf,tex)-offset;
	nodes.push_back(node);
	active=true;
	node.pre=pre;
	node.point=point;
	break;
      }
    case 'c':
      {
	cyclic=true;
	break;
      }
    case 'Z':
      {
	offset=readpair(buf,tex);
	break;
      }
    }
  }
  
  if(!keep)
    unlink(psname.c_str());
  return P;
}

  
// Autogenerated routines:



namespace run {

// Initializers
#line 961 "runtime.in"
void IntZero(stack *Stack)
{
#line 962 "runtime.in"
  {Stack->push<Int>(0); return;}
}

#line 967 "runtime.in"
void realZero(stack *Stack)
{
#line 968 "runtime.in"
  {Stack->push<real>(0.0); return;}
}

#line 972 "runtime.in"
void boolFalse(stack *Stack)
{
#line 973 "runtime.in"
  {Stack->push<bool>(false); return;}
}

#line 977 "runtime.in"
void pushNullArray(stack *Stack)
{
#line 978 "runtime.in"
  {Stack->push<array*>(0); return;}
}

#line 982 "runtime.in"
void pushNullRecord(stack *Stack)
{
#line 983 "runtime.in"
  {Stack->push<frame*>(0); return;}
}

#line 987 "runtime.in"
void pushNullFunction(stack *Stack)
{
#line 988 "runtime.in"
  {Stack->push(nullfunc::instance()); return;}
}


// Default operations

// Put the default value token on the stack (in place of an argument when
// making a function call).
#line 997 "runtime.in"
void pushDefault(stack *Stack)
{
#line 998 "runtime.in"
  {Stack->push(def); return;}
}


// Test if the value on the stack is the default value token.
#line 1004 "runtime.in"
void isDefault(stack *Stack)
{
  item i=vm::pop(Stack);
#line 1005 "runtime.in"
  {Stack->push<bool>(isdefault(i)); return;}
}


// Logical operations
#line 1011 "runtime.in"
// bool !(bool b);
void gen8(stack *Stack)
{
  bool b=vm::pop<bool>(Stack);
#line 1012 "runtime.in"
  {Stack->push<bool>(!b); return;}
}

#line 1017 "runtime.in"
void boolMemEq(stack *Stack)
{
  frame * b=vm::pop<frame *>(Stack);
  frame * a=vm::pop<frame *>(Stack);
#line 1018 "runtime.in"
  {Stack->push<bool>(a == b); return;}
}

#line 1022 "runtime.in"
void boolMemNeq(stack *Stack)
{
  frame * b=vm::pop<frame *>(Stack);
  frame * a=vm::pop<frame *>(Stack);
#line 1023 "runtime.in"
  {Stack->push<bool>(a != b); return;}
}

#line 1027 "runtime.in"
void boolFuncEq(stack *Stack)
{
  callable * b=vm::pop<callable *>(Stack);
  callable * a=vm::pop<callable *>(Stack);
#line 1028 "runtime.in"
  {Stack->push<bool>(a->compare(b)); return;}
}

#line 1032 "runtime.in"
void boolFuncNeq(stack *Stack)
{
  callable * b=vm::pop<callable *>(Stack);
  callable * a=vm::pop<callable *>(Stack);
#line 1033 "runtime.in"
  {Stack->push<bool>(!(a->compare(b))); return;}
}


// Bit operations
#line 1039 "runtime.in"
// Int AND(Int a, Int b);
void gen13(stack *Stack)
{
  Int b=vm::pop<Int>(Stack);
  Int a=vm::pop<Int>(Stack);
#line 1040 "runtime.in"
    {Stack->push<Int>(a & b); return;}
}

#line 1045 "runtime.in"
// Int OR(Int a, Int b);
void gen14(stack *Stack)
{
  Int b=vm::pop<Int>(Stack);
  Int a=vm::pop<Int>(Stack);
#line 1046 "runtime.in"
    {Stack->push<Int>(a | b); return;}
}

#line 1050 "runtime.in"
// Int XOR(Int a, Int b);
void gen15(stack *Stack)
{
  Int b=vm::pop<Int>(Stack);
  Int a=vm::pop<Int>(Stack);
#line 1051 "runtime.in"
    {Stack->push<Int>(a ^ b); return;}
}

#line 1055 "runtime.in"
// Int NOT(Int a);
void gen16(stack *Stack)
{
  Int a=vm::pop<Int>(Stack);
#line 1056 "runtime.in"
    {Stack->push<Int>(~a); return;}
}


// Casts
#line 1062 "runtime.in"
void pairToGuide(stack *Stack)
{
  pair z=vm::pop<pair>(Stack);
#line 1063 "runtime.in"
  {Stack->push<guide*>(new pairguide(z)); return;}
}

#line 1068 "runtime.in"
void pathToGuide(stack *Stack)
{
  path p=vm::pop<path>(Stack);
#line 1069 "runtime.in"
  {Stack->push<guide*>(new pathguide(p)); return;}
}

#line 1073 "runtime.in"
void guideToPath(stack *Stack)
{
  guide * g=vm::pop<guide *>(Stack);
#line 1074 "runtime.in"
  {Stack->push<path>(g->solve()); return;}
}


// Picture operations
#line 1080 "runtime.in"
void newPicture(stack *Stack)
{
#line 1081 "runtime.in"
  {Stack->push<picture*>(new picture()); return;}
}

#line 1086 "runtime.in"
// bool empty(picture *f);
void gen21(stack *Stack)
{
  picture * f=vm::pop<picture *>(Stack);
#line 1087 "runtime.in"
  {Stack->push<bool>(f->null()); return;}
}

#line 1091 "runtime.in"
// void erase(picture *f);
void gen22(stack *Stack)
{
  picture * f=vm::pop<picture *>(Stack);
#line 1092 "runtime.in"
  f->nodes.clear();
}

#line 1096 "runtime.in"
// pair min(picture *f);
void gen23(stack *Stack)
{
  picture * f=vm::pop<picture *>(Stack);
#line 1097 "runtime.in"
  {Stack->push<pair>(f->bounds().Min()); return;}
}

#line 1101 "runtime.in"
// pair max(picture *f);
void gen24(stack *Stack)
{
  picture * f=vm::pop<picture *>(Stack);
#line 1102 "runtime.in"
  {Stack->push<pair>(f->bounds().Max()); return;}
}

#line 1106 "runtime.in"
// void label(picture *f, string *s, string *size, transform t, pair position,	   pair align, pen p);
void gen25(stack *Stack)
{
  pen p=vm::pop<pen>(Stack);
  pair align=vm::pop<pair>(Stack);
  pair position=vm::pop<pair>(Stack);
  transform t=vm::pop<transform>(Stack);
  string * size=vm::pop<string *>(Stack);
  string * s=vm::pop<string *>(Stack);
  picture * f=vm::pop<picture *>(Stack);
#line 1108 "runtime.in"
  f->append(new drawLabel(*s,*size,t,position,align,p));
}

#line 1112 "runtime.in"
// bool labels(picture *f);
void gen26(stack *Stack)
{
  picture * f=vm::pop<picture *>(Stack);
#line 1113 "runtime.in"
  {Stack->push<bool>(f->havelabels()); return;}
}

#line 1117 "runtime.in"
// patharray* _texpath(string *s, pen p=CURRENTPEN);
void gen27(stack *Stack)
{
  pen p=vm::pop<pen>(Stack,CURRENTPEN);
  string * s=vm::pop<string *>(Stack);
#line 1118 "runtime.in"
  array *P=new array(0);
  if(s->empty()) {Stack->push<patharray*>(P); return;}
  
  string prefix=outname();
  spaceToUnderscore(prefix);
  string psname=auxname(prefix,"ps");

  string texname=auxname(prefix,"tex");
  string dviname=auxname(prefix,"dvi");
  bbox b;
  texfile tex(texname,b,true);
  tex.miniprologue();
  
  tex.setfont(p);
  tex.verbatimline("\\special{ps:");
  tex.verbatimline(ASYo);
  tex.verbatimline("/ASY1 true def");
  tex.verbatimline("/v {neg exch 4 copy 4 2 roll 2 copy 6 2 roll 2 copy (M) print ASYo ASYo (L) print ASYo add ASYo (L) print add ASYo add ASYo (L) print add ASYo ASYo (c) print} bind def");
  tex.verbatimline("/show {ASY1 {(Z) "+currentpoint+
		   "/ASY1 false def} if currentpoint newpath moveto false charpath "+
		   pathforall+"} bind def}");
  tex.verbatim(*s);
  tex.verbatimline("\\special{ps: (E) print}");
  tex.epilogue(true);
  tex.close();
  
  ostringstream cmd;
  cmd << "'" << texprogram(true) << "'"
      << " \\nonstopmode\\input '" << texname << "'";
  bool quiet=verbose <= 2;
  int status=System(cmd,quiet ? 1 : 0,"texpath",texpathmessage());
  if(!status && getSetting<bool>("twice"))
    status=System(cmd,quiet ? 1 : 0,"texpath",texpathmessage());
  if(status) {
    if(quiet) {
      ostringstream cmd;
      cmd << "'" << texprogram() << "'"
	  << " \\scrollmode\\input '" << texname << "'";
      System(cmd,0);
    }
  }
    
  if(!status) {  
    ostringstream cmd;
    cmd << "'" << getSetting<string>("dvips") << "' -R -Pdownload35 -D600 "
	<< getSetting<string>("dvipsOptions");
    if(verbose <= 2) cmd << " -q";
    cmd  << " -o '" << psname << "' '" << dviname << "'";
    status=System(cmd,0,true,"dvips");
  }

  if(status != 0)
    error("texpath failed");
    
  bool keep=getSetting<bool>("keep");
  if(!keep) { // Delete temporary files.
    unlink(texname.c_str());
    if(!getSetting<bool>("keepaux")) unlink(auxname(prefix,"aux").c_str());
    unlink(auxname(prefix,"log").c_str());
    unlink(dviname.c_str());
  }
  {Stack->push<patharray*>(readpath(psname,true,keep)); return;}
}

#line 1183 "runtime.in"
// patharray* _strokepath(path g, pen p=CURRENTPEN);
void gen28(stack *Stack)
{
  pen p=vm::pop<pen>(Stack,CURRENTPEN);
  path g=vm::pop<path>(Stack);
#line 1184 "runtime.in"
  array *P=new array(0);
  if(g.size() == 0) {Stack->push<patharray*>(P); return;}
  
  string prefix=outname();
  spaceToUnderscore(prefix);
  string psname=auxname(prefix,"ps");
  bbox b;
  psfile ps(psname, false);
  ps.prologue(b);
  ps.verbatimline(ASYo);
  ps.verbatimline("/stroke {(Z) "+currentpoint+pathforall+"} bind def");
  ps.resetpen();
  ps.setpen(p);
  ps.write(g);
  ps.strokepath();
  ps.stroke();
  ps.verbatimline("(M) "+currentpoint+"(E) print");
  ps.epilogue();
  ps.close();
  {Stack->push<patharray*>(readpath(psname,false,getSetting<bool>("keep"))); return;}
}

#line 1207 "runtime.in"
// void _draw(picture *f, path g, pen p);
void gen29(stack *Stack)
{
  pen p=vm::pop<pen>(Stack);
  path g=vm::pop<path>(Stack);
  picture * f=vm::pop<picture *>(Stack);
#line 1208 "runtime.in"
  f->append(new drawPath(g,p));
}

#line 1212 "runtime.in"
// void fill(picture *f, patharray *g, pen p=CURRENTPEN, bool copy=true);
void gen30(stack *Stack)
{
  bool copy=vm::pop<bool>(Stack,true);
  pen p=vm::pop<pen>(Stack,CURRENTPEN);
  patharray * g=vm::pop<patharray *>(Stack);
  picture * f=vm::pop<picture *>(Stack);
#line 1213 "runtime.in"
  array *(*copyarray)(array *a)=copy ? copyArray: nop;
  f->append(new drawFill(*copyarray(g),false,p));
}

#line 1218 "runtime.in"
// void latticeshade(picture *f, patharray *g, bool stroke=false,		  pen fillrule, penarray2 *p, bool copy=true);
void gen31(stack *Stack)
{
  bool copy=vm::pop<bool>(Stack,true);
  penarray2 * p=vm::pop<penarray2 *>(Stack);
  pen fillrule=vm::pop<pen>(Stack);
  bool stroke=vm::pop<bool>(Stack,false);
  patharray * g=vm::pop<patharray *>(Stack);
  picture * f=vm::pop<picture *>(Stack);
#line 1220 "runtime.in"
  array *(*copyarray)(array *a)=copy ? copyArray: nop;
  f->append(new drawLatticeShade(*copyarray(g),stroke,fillrule,*copyarray(p)));
}

#line 1225 "runtime.in"
// void axialshade(picture *f, patharray *g, bool stroke=false, pen pena, pair a,		pen penb, pair b, bool copy=true);
void gen32(stack *Stack)
{
  bool copy=vm::pop<bool>(Stack,true);
  pair b=vm::pop<pair>(Stack);
  pen penb=vm::pop<pen>(Stack);
  pair a=vm::pop<pair>(Stack);
  pen pena=vm::pop<pen>(Stack);
  bool stroke=vm::pop<bool>(Stack,false);
  patharray * g=vm::pop<patharray *>(Stack);
  picture * f=vm::pop<picture *>(Stack);
#line 1227 "runtime.in"
  array *(*copyarray)(array *a)=copy ? copyArray: nop;
  f->append(new drawAxialShade(*copyarray(g),stroke,pena,a,penb,b));
}

#line 1232 "runtime.in"
// void radialshade(picture *f, patharray *g, bool stroke=false, pen pena,		 pair a, real ra, pen penb, pair b, real rb, bool copy=true);
void gen33(stack *Stack)
{
  bool copy=vm::pop<bool>(Stack,true);
  real rb=vm::pop<real>(Stack);
  pair b=vm::pop<pair>(Stack);
  pen penb=vm::pop<pen>(Stack);
  real ra=vm::pop<real>(Stack);
  pair a=vm::pop<pair>(Stack);
  pen pena=vm::pop<pen>(Stack);
  bool stroke=vm::pop<bool>(Stack,false);
  patharray * g=vm::pop<patharray *>(Stack);
  picture * f=vm::pop<picture *>(Stack);
#line 1234 "runtime.in"
  array *(*copyarray)(array *a)=copy ? copyArray: nop;
  f->append(new drawRadialShade(*copyarray(g),stroke,pena,a,ra,penb,b,rb));
}

#line 1239 "runtime.in"
// void gouraudshade(picture *f, patharray *g, bool stroke=false, pen fillrule,		  penarray *p, pairarray *z, Intarray *edges, bool copy=true);
void gen34(stack *Stack)
{
  bool copy=vm::pop<bool>(Stack,true);
  Intarray * edges=vm::pop<Intarray *>(Stack);
  pairarray * z=vm::pop<pairarray *>(Stack);
  penarray * p=vm::pop<penarray *>(Stack);
  pen fillrule=vm::pop<pen>(Stack);
  bool stroke=vm::pop<bool>(Stack,false);
  patharray * g=vm::pop<patharray *>(Stack);
  picture * f=vm::pop<picture *>(Stack);
#line 1241 "runtime.in"
  array *(*copyarray)(array *a)=copy ? copyArray: nop;
  checkArrays(p,z);
  checkArrays(z,edges);
  f->append(new drawGouraudShade(*copyarray(g),stroke,fillrule,*copyarray(p),
				 *copyarray(z),*copyarray(edges)));
}

#line 1249 "runtime.in"
// void gouraudshade(picture *f, patharray *g, bool stroke=false, pen fillrule,		  penarray *p, Intarray *edges, bool copy=true);
void gen35(stack *Stack)
{
  bool copy=vm::pop<bool>(Stack,true);
  Intarray * edges=vm::pop<Intarray *>(Stack);
  penarray * p=vm::pop<penarray *>(Stack);
  pen fillrule=vm::pop<pen>(Stack);
  bool stroke=vm::pop<bool>(Stack,false);
  patharray * g=vm::pop<patharray *>(Stack);
  picture * f=vm::pop<picture *>(Stack);
#line 1251 "runtime.in"
  array *(*copyarray)(array *a)=copy ? copyArray: nop;
  size_t n=checkArrays(p,edges);
  size_t m=checkArray(g);
  array *z=new array(n);
  Int k=0;
  Int in=(Int) n;
  for(size_t j=0; j < m; ++j) {
    path *P=read<path *>(g,j);
    assert(P);
    Int stop=Min(P->size(),in-k);
    mem::vector<solvedKnot>& nodes=P->Nodes();
    for(Int i=0; i < stop; ++i)
      (*z)[k++]=nodes[i].point;
  }
  checkArrays(p,z);
  
  f->append(new drawGouraudShade(*copyarray(g),stroke,fillrule,*copyarray(p),
				*z,*copyarray(edges)));
}

#line 1272 "runtime.in"
// void tensorshade(picture *f, patharray *g, bool stroke=false, pen fillrule,		 penarray2 *p, patharray *b=NULL, pairarray2 *z=emptyarray,		 bool copy=true);
void gen36(stack *Stack)
{
  bool copy=vm::pop<bool>(Stack,true);
  pairarray2 * z=vm::pop<pairarray2 *>(Stack,emptyarray);
  patharray * b=vm::pop<patharray *>(Stack,NULL);
  penarray2 * p=vm::pop<penarray2 *>(Stack);
  pen fillrule=vm::pop<pen>(Stack);
  bool stroke=vm::pop<bool>(Stack,false);
  patharray * g=vm::pop<patharray *>(Stack);
  picture * f=vm::pop<picture *>(Stack);
#line 1275 "runtime.in"
  array *(*copyarray)(array *a)=copy ? copyArray: nop;
  array *(*copyarray2)(array *a)=copy ? copyArray2: nop;
  if(b == NULL) b=g;
  size_t n=checkArrays(p,b);
  size_t nz=checkArray(z);
  if(nz != 0)
    checkEqual(nz,n);
  f->append(new drawTensorShade(*copyarray(g),stroke,fillrule,*copyarray2(p),
				*copyarray(b),*copyarray2(z)));
}

// Clip a picture to a superpath using the given fill rule.
// Subsequent additions to the picture will not be affected by the clipping.
#line 1289 "runtime.in"
// void clip(picture *f, patharray *g, bool stroke=false, pen fillrule,	  bool copy=true);
void gen37(stack *Stack)
{
  bool copy=vm::pop<bool>(Stack,true);
  pen fillrule=vm::pop<pen>(Stack);
  bool stroke=vm::pop<bool>(Stack,false);
  patharray * g=vm::pop<patharray *>(Stack);
  picture * f=vm::pop<picture *>(Stack);
#line 1291 "runtime.in"
  array *(*copyarray)(array *a)=copy ? copyArray: nop;
  drawClipBegin *begin=new drawClipBegin(*copyarray(g),stroke,fillrule,true);
  f->enclose(begin,new drawClipEnd(true,begin));
}

#line 1297 "runtime.in"
// void beginclip(picture *f, patharray *g, bool stroke=false, pen fillrule);
void gen38(stack *Stack)
{
  pen fillrule=vm::pop<pen>(Stack);
  bool stroke=vm::pop<bool>(Stack,false);
  patharray * g=vm::pop<patharray *>(Stack);
  picture * f=vm::pop<picture *>(Stack);
#line 1298 "runtime.in"
  f->append(new drawClipBegin(*copyArray(g),stroke,fillrule,false));
}

#line 1302 "runtime.in"
// void endclip(picture *f);
void gen39(stack *Stack)
{
  picture * f=vm::pop<picture *>(Stack);
#line 1303 "runtime.in"
  f->append(new drawClipEnd(false));
}

#line 1307 "runtime.in"
// void gsave(picture *f);
void gen40(stack *Stack)
{
  picture * f=vm::pop<picture *>(Stack);
#line 1308 "runtime.in"
  f->append(new drawGsave());
}

#line 1312 "runtime.in"
// void grestore(picture *f);
void gen41(stack *Stack)
{
  picture * f=vm::pop<picture *>(Stack);
#line 1313 "runtime.in"
  f->append(new drawGrestore());
}

#line 1317 "runtime.in"
// void begingroup(picture *f);
void gen42(stack *Stack)
{
  picture * f=vm::pop<picture *>(Stack);
#line 1318 "runtime.in"
  f->append(new drawBegin());
}

#line 1322 "runtime.in"
// void endgroup(picture *f);
void gen43(stack *Stack)
{
  picture * f=vm::pop<picture *>(Stack);
#line 1323 "runtime.in"
  f->append(new drawEnd());
}

#line 1327 "runtime.in"
// void add(picture *dest, picture *src);
void gen44(stack *Stack)
{
  picture * src=vm::pop<picture *>(Stack);
  picture * dest=vm::pop<picture *>(Stack);
#line 1328 "runtime.in"
  dest->add(*src);
}

#line 1332 "runtime.in"
// void prepend(picture *dest, picture *src);
void gen45(stack *Stack)
{
  picture * src=vm::pop<picture *>(Stack);
  picture * dest=vm::pop<picture *>(Stack);
#line 1333 "runtime.in"
  dest->prepend(*src);
}

#line 1337 "runtime.in"
// void postscript(picture *f, string s);
void gen46(stack *Stack)
{
  string s=vm::pop<string>(Stack);
  picture * f=vm::pop<picture *>(Stack);
#line 1338 "runtime.in"
  f->append(new drawVerbatim(PostScript,s));
}

#line 1342 "runtime.in"
// void tex(picture *f, string s);
void gen47(stack *Stack)
{
  string s=vm::pop<string>(Stack);
  picture * f=vm::pop<picture *>(Stack);
#line 1343 "runtime.in"
  f->append(new drawVerbatim(TeX,s));
}

#line 1347 "runtime.in"
// void postscript(picture *f, string s, pair min, pair max);
void gen48(stack *Stack)
{
  pair max=vm::pop<pair>(Stack);
  pair min=vm::pop<pair>(Stack);
  string s=vm::pop<string>(Stack);
  picture * f=vm::pop<picture *>(Stack);
#line 1348 "runtime.in"
  f->append(new drawVerbatim(PostScript,s,min,max));
}

#line 1352 "runtime.in"
// void tex(picture *f, string s, pair min, pair max);
void gen49(stack *Stack)
{
  pair max=vm::pop<pair>(Stack);
  pair min=vm::pop<pair>(Stack);
  string s=vm::pop<string>(Stack);
  picture * f=vm::pop<picture *>(Stack);
#line 1353 "runtime.in"
  f->append(new drawVerbatim(TeX,s,min,max));
}

#line 1357 "runtime.in"
// void texpreamble(string s);
void gen50(stack *Stack)
{
  string s=vm::pop<string>(Stack);
#line 1358 "runtime.in"
  string t=s+"\n";
  processDataStruct &pd=processData();
  pd.TeXpipepreamble.push_back(t);
  pd.TeXpreamble.push_back(t);
}

#line 1365 "runtime.in"
// void deletepreamble();
void gen51(stack *)
{
#line 1366 "runtime.in"
  if(getSetting<bool>("inlinetex")) {
    unlink(auxname(outname(),"pre").c_str());
  }
}

#line 1372 "runtime.in"
// void _labelpath(picture *f, string s, string size, path g, string justify,		pair offset, pen p);
void gen52(stack *Stack)
{
  pen p=vm::pop<pen>(Stack);
  pair offset=vm::pop<pair>(Stack);
  string justify=vm::pop<string>(Stack);
  path g=vm::pop<path>(Stack);
  string size=vm::pop<string>(Stack);
  string s=vm::pop<string>(Stack);
  picture * f=vm::pop<picture *>(Stack);
#line 1374 "runtime.in"
  f->append(new drawLabelPath(s,size,g,justify,offset,p));
}

#line 1378 "runtime.in"
// void texreset();
void gen53(stack *)
{
#line 1379 "runtime.in"
  processDataStruct &pd=processData();
  pd.TeXpipepreamble.clear();
  pd.TeXpreamble.clear();
  pd.tex.pipeclose();
}

#line 1386 "runtime.in"
// void layer(picture *f);
void gen54(stack *Stack)
{
  picture * f=vm::pop<picture *>(Stack);
#line 1387 "runtime.in"
  f->append(new drawLayer());
}

#line 1391 "runtime.in"
// void _image(picture *f, realarray2 *data, pair initial, pair final,	    penarray *palette=NULL, transform t=identity, bool copy=true,	    bool antialias=false);
void gen55(stack *Stack)
{
  bool antialias=vm::pop<bool>(Stack,false);
  bool copy=vm::pop<bool>(Stack,true);
  transform t=vm::pop<transform>(Stack,identity);
  penarray * palette=vm::pop<penarray *>(Stack,NULL);
  pair final=vm::pop<pair>(Stack);
  pair initial=vm::pop<pair>(Stack);
  realarray2 * data=vm::pop<realarray2 *>(Stack);
  picture * f=vm::pop<picture *>(Stack);
#line 1394 "runtime.in"
  array *(*copyarray)(array *a)=copy ? copyArray: nop;
  array *(*copyarray2)(array *a)=copy ? copyArray2: nop;
  f->append(new drawImage(*copyarray2(data),*copyarray(palette),
			  t*matrix(initial,final),antialias));
}

#line 1401 "runtime.in"
// void _image(picture *f, penarray2 *data, pair initial, pair final,	    transform t=identity, bool copy=true, bool antialias=false);
void gen56(stack *Stack)
{
  bool antialias=vm::pop<bool>(Stack,false);
  bool copy=vm::pop<bool>(Stack,true);
  transform t=vm::pop<transform>(Stack,identity);
  pair final=vm::pop<pair>(Stack);
  pair initial=vm::pop<pair>(Stack);
  penarray2 * data=vm::pop<penarray2 *>(Stack);
  picture * f=vm::pop<picture *>(Stack);
#line 1403 "runtime.in"
  array *(*copyarray2)(array *a)=copy ? copyArray2: nop;
  f->append(new drawImage(*copyarray2(data),t*matrix(initial,final),antialias));
}

#line 1408 "runtime.in"
// string nativeformat();
void gen57(stack *Stack)
{
#line 1409 "runtime.in"
  {Stack->push<string>(nativeformat()); return;}
}

#line 1413 "runtime.in"
// bool latex();
void gen58(stack *Stack)
{
#line 1414 "runtime.in"
  {Stack->push<bool>(latex(getSetting<string>("tex"))); return;}
}

#line 1418 "runtime.in"
// bool pdf();
void gen59(stack *Stack)
{
#line 1419 "runtime.in"
  {Stack->push<bool>(pdf(getSetting<string>("tex"))); return;}
}

#line 1423 "runtime.in"
// void shipout(string prefix=emptystring, picture *f, picture *preamble=NULL,	     string format=emptystring, bool wait=false, bool view=true,	     callableTransform *xform);
void gen60(stack *Stack)
{
  callableTransform * xform=vm::pop<callableTransform *>(Stack);
  bool view=vm::pop<bool>(Stack,true);
  bool wait=vm::pop<bool>(Stack,false);
  string format=vm::pop<string>(Stack,emptystring);
  picture * preamble=vm::pop<picture *>(Stack,NULL);
  picture * f=vm::pop<picture *>(Stack);
  string prefix=vm::pop<string>(Stack,emptystring);
#line 1426 "runtime.in"
  if(prefix.empty()) prefix=outname();

  picture *result=new picture;
  unsigned level=0;
  picture::nodelist::iterator p;
  for(p = f->nodes.begin(); p != f->nodes.end(); ++p) {
    xform->call(Stack);
    transform t=pop<transform>(Stack);
    static transform Zero=transform(0.0,0.0,0.0,0.0,0.0,0.0);
    bool Delete=(t == Zero);
    picture *group=new picture;
    assert(*p);
    if((*p)->endgroup()) error(nobegin);
    if((*p)->begingroup()) {
      ++level;
      while(p != f->nodes.end() && level) {
	if(!Delete) {
	  drawElement *e=t.isIdentity() ? *p : (*p)->transformed(t);
	  group->append(e);
	}
	++p;
	if(p == f->nodes.end()) break;
	assert(*p);
	if((*p)->begingroup()) ++level;
	if((*p)->endgroup()) {
	  if(level) --level;
	  else error(nobegin);
	}
      }
    }
    if(p == f->nodes.end()) break;
    assert(*p);
    if(!Delete) {
      drawElement *e=t.isIdentity() ? *p : (*p)->transformed(t);
      group->append(e);
      result->add(*group);
    }
  }
    
  result->shipout(preamble,prefix,format,0.0,wait,view);
}

#line 1469 "runtime.in"
// void shipout3(string prefix, picture *f, string format=emptystring,	      real width, real height, real angle, triple m, triple M,	      triplearray *lights, realarray2 *diffuse, realarray2 *ambient,	      realarray2 *specular, bool viewportlighting,	      bool wait=false, bool view=true);
void gen61(stack *Stack)
{
  bool view=vm::pop<bool>(Stack,true);
  bool wait=vm::pop<bool>(Stack,false);
  bool viewportlighting=vm::pop<bool>(Stack);
  realarray2 * specular=vm::pop<realarray2 *>(Stack);
  realarray2 * ambient=vm::pop<realarray2 *>(Stack);
  realarray2 * diffuse=vm::pop<realarray2 *>(Stack);
  triplearray * lights=vm::pop<triplearray *>(Stack);
  triple M=vm::pop<triple>(Stack);
  triple m=vm::pop<triple>(Stack);
  real angle=vm::pop<real>(Stack);
  real height=vm::pop<real>(Stack);
  real width=vm::pop<real>(Stack);
  string format=vm::pop<string>(Stack,emptystring);
  picture * f=vm::pop<picture *>(Stack);
  string prefix=vm::pop<string>(Stack);
#line 1474 "runtime.in"
  size_t n=checkArrays(lights,diffuse);
  checkEqual(n,checkArray(ambient));
  checkEqual(n,checkArray(specular));
  
  triple *Lights=copyTripleArrayC(lights);
  real *Diffuse=copyArray2C(diffuse,false,4);  
  real *Ambient=copyArray2C(ambient,false,4);
  real *Specular=copyArray2C(specular,false,4);
  f->shipout3(prefix,format,width,height,angle,m,M,n,
	      Lights,Diffuse,Ambient,Specular,viewportlighting,wait,view);
  delete[] Specular;
  delete[] Ambient;
  delete[] Diffuse;
  delete[] Lights;
}

#line 1491 "runtime.in"
// void shipout3(string prefix, picture *f);
void gen62(stack *Stack)
{
  picture * f=vm::pop<picture *>(Stack);
  string prefix=vm::pop<string>(Stack);
#line 1492 "runtime.in"
    f->shipout3(prefix);
}

#line 1496 "runtime.in"
// void deconstruct(picture *f, picture *preamble=NULL, real magnification=1, 		 callableTransform *xform);
void gen63(stack *Stack)
{
  callableTransform * xform=vm::pop<callableTransform *>(Stack);
  real magnification=vm::pop<real>(Stack,1);
  picture * preamble=vm::pop<picture *>(Stack,NULL);
  picture * f=vm::pop<picture *>(Stack);
#line 1498 "runtime.in"
  unsigned level=0;
  unsigned n=0;

  string prefix=outname();
  string xformat=getSetting<string>("xformat");

  static long arg_max=sysconf(_SC_ARG_MAX);
  const unsigned maxargs=::min(arg_max/(prefix.size()+xformat.size()+25ul),
			       256ul);
  
  cout << xformat << newl;
  cout << maxargs << newl;
  
  string preformat=nativeformat();
  const string Done="Done";
  const string Error="Error";
  
  ostringstream cmd;
  
  // Enforce ghostscript limitations.
  magnification=::max(magnification,0.0001);
  real res=::min(::max(magnification*72.0,2.0),8192.0);
  
  const char *converter=NULL, *hint=NULL;
  
  bool png=xformat == "png";
  
  if(magnification > 0.0) {
    mem::list<string> nameStack;
    string outname;
    unsigned arg=0;
    unsigned batch=0;
    for(picture::nodelist::iterator p=f->nodes.begin();;) {
      if(p == f->nodes.end()) break;
      if(arg == 0) {
	cmd.str("");
	ostringstream buf;
	buf << batch << "_";
	outname=buildname(prefix+buf.str()+"%d",xformat,"",
			  prefix != settings::outname() && !globalwrite());
	if(png) {
	  cmd << "'" << getSetting<string>("gs")
	      << "' -q -dNOPAUSE -dBATCH -sDEVICE=pngalpha -dEPSCrop";
	  if(safe)
	    cmd << " -dSAFER";
	  cmd << " -r" << res << "x" << res
	      << " -sOutputFile='" << outname << "'";
	  converter="gs";
	  hint="Ghostscript";
	} else {
	  cmd << "'" << getSetting<string>("convert") 
	      << "' -density " << res << "x" << res
	      << " -transparent white";
	  hint=converter="convert";
	}
      }
      
      picture *group=new picture;
      xform->call(Stack);
      transform t=pop<transform>(Stack);
      assert(*p);
      if((*p)->endgroup()) {
	cout << Error << endl;
	error(nobegin);
      }
      if((*p)->begingroup()) {
	++level;
	while(p != f->nodes.end() && level) {
	  drawElement *e=t.isIdentity() ? *p : (*p)->transformed(t);
	  group->append(e);
	  ++p;
	  if(p == f->nodes.end()) break;
	  assert(*p);
	  if((*p)->begingroup()) ++level;
	  if((*p)->endgroup()) {
	    if(level) --level;
	    else {
	      cout << Error << endl;
	      error(nobegin);
	    }
	  }
	}
      }
      if(p != f->nodes.end()) {
	assert(*p);
	drawElement *e=t.isIdentity() ? *p : (*p)->transformed(t);
	group->append(e);
	bbox b;
	ostringstream buf;
	buf << prefix << "_" << n;
	group->shipout(preamble,buf.str(),preformat,magnification,false,false);
	string Preformat=png && group->Transparency() ? "pdf" : preformat;
	string name=buildname(buf.str(),Preformat);
	nameStack.push_back(name);
	cmd << " '";
	if(!png) cmd << preformat+":";
	cmd << name << "'";
	b=group->bounds();
	b *= magnification;
      
	cout << b << newl;
	++n;
	++p;
	++arg;
      }
      
      if(p == f->nodes.end() || arg >= maxargs) {
	arg=0;
	++batch;
	cout.flush();
	if(!png) 
	  cmd << " -scene 1 '" << xformat << ":" << outname << "'";
    
	int status=System(cmd,0,true,converter,hint);
	if(status) {
	  cout << Error << endl;
	  error("deconstruct failed");
	}
      }
    }
    
    if(!getSetting<bool>("keep")) {
      for(mem::list<string>::iterator p=nameStack.begin();
	  p != nameStack.end(); ++p)
	unlink(p->c_str());
    }
    
    cout << Done << endl;
  }
}

#line 1630 "runtime.in"
// void purge();
void gen64(stack *)
{
#line 1631 "runtime.in"
  purge();
}


// Pen operations
#line 1637 "runtime.in"
void newPen(stack *Stack)
{
#line 1638 "runtime.in"
  {Stack->push<pen>(pen()); return;}
}

#line 1643 "runtime.in"
// bool ==(pen a, pen b);
void gen66(stack *Stack)
{
  pen b=vm::pop<pen>(Stack);
  pen a=vm::pop<pen>(Stack);
#line 1644 "runtime.in"
  {Stack->push<bool>(a == b); return;}
}

#line 1648 "runtime.in"
// bool !=(pen a, pen b);
void gen67(stack *Stack)
{
  pen b=vm::pop<pen>(Stack);
  pen a=vm::pop<pen>(Stack);
#line 1649 "runtime.in"
  {Stack->push<bool>(a != b); return;}
}

#line 1653 "runtime.in"
// pen +(pen a, pen b);
void gen68(stack *Stack)
{
  pen b=vm::pop<pen>(Stack);
  pen a=vm::pop<pen>(Stack);
#line 1654 "runtime.in"
  {Stack->push<pen>(a+b); return;}
}

#line 1658 "runtime.in"
// pen *(real a, pen b);
void gen69(stack *Stack)
{
  pen b=vm::pop<pen>(Stack);
  real a=vm::pop<real>(Stack);
#line 1659 "runtime.in"
  {Stack->push<pen>(a*b); return;}
}

#line 1663 "runtime.in"
// pen *(pen a, real b);
void gen70(stack *Stack)
{
  real b=vm::pop<real>(Stack);
  pen a=vm::pop<pen>(Stack);
#line 1664 "runtime.in"
  {Stack->push<pen>(b*a); return;}
}

#line 1668 "runtime.in"
// pair max(pen p);
void gen71(stack *Stack)
{
  pen p=vm::pop<pen>(Stack);
#line 1669 "runtime.in"
  {Stack->push<pair>(p.bounds().Max()); return;}
}

#line 1673 "runtime.in"
// pair min(pen p);
void gen72(stack *Stack)
{
  pen p=vm::pop<pen>(Stack);
#line 1674 "runtime.in"
  {Stack->push<pair>(p.bounds().Min()); return;}
}

// Reset the meaning of pen default attributes.
#line 1679 "runtime.in"
// void resetdefaultpen();
void gen73(stack *)
{
#line 1680 "runtime.in"
  processData().defaultpen=camp::pen::initialpen();
}

#line 1684 "runtime.in"
// void defaultpen(pen p);
void gen74(stack *Stack)
{
  pen p=vm::pop<pen>(Stack);
#line 1685 "runtime.in"
  processData().defaultpen=pen(resolvepen,p);
}

#line 1689 "runtime.in"
// pen defaultpen();
void gen75(stack *Stack)
{
#line 1690 "runtime.in"
  {Stack->push<pen>(processData().defaultpen); return;}
}

#line 1694 "runtime.in"
// bool invisible(pen p);
void gen76(stack *Stack)
{
  pen p=vm::pop<pen>(Stack);
#line 1695 "runtime.in"
  {Stack->push<bool>(p.invisible()); return;}
}

#line 1699 "runtime.in"
// pen invisible();
void gen77(stack *Stack)
{
#line 1700 "runtime.in"
  {Stack->push<pen>(pen(invisiblepen)); return;}
}

#line 1704 "runtime.in"
// pen gray(pen p);
void gen78(stack *Stack)
{
  pen p=vm::pop<pen>(Stack);
#line 1705 "runtime.in"
  if(p.rgb()) p.rgbtogrey();
  else if (p.cmyk()) p.cmyktogrey();
  {Stack->push<pen>(p); return;}
}

#line 1711 "runtime.in"
// pen rgb(pen p);
void gen79(stack *Stack)
{
  pen p=vm::pop<pen>(Stack);
#line 1712 "runtime.in"
  if(p.grayscale()) p.greytorgb();
  else if (p.cmyk()) p.cmyktorgb();
  {Stack->push<pen>(p); return;}
}

#line 1718 "runtime.in"
// pen rgb(real r, real g, real b);
void gen80(stack *Stack)
{
  real b=vm::pop<real>(Stack);
  real g=vm::pop<real>(Stack);
  real r=vm::pop<real>(Stack);
#line 1719 "runtime.in"
  {Stack->push<pen>(pen(r,g,b)); return;}
}

#line 1723 "runtime.in"
// pen cmyk(real c, real m, real y, real k);
void gen81(stack *Stack)
{
  real k=vm::pop<real>(Stack);
  real y=vm::pop<real>(Stack);
  real m=vm::pop<real>(Stack);
  real c=vm::pop<real>(Stack);
#line 1724 "runtime.in"
  {Stack->push<pen>(pen(c,m,y,k)); return;}  
}

#line 1728 "runtime.in"
// pen gray(real gray);
void gen82(stack *Stack)
{
  real gray=vm::pop<real>(Stack);
#line 1729 "runtime.in"
  {Stack->push<pen>(pen(gray)); return;}
}

#line 1733 "runtime.in"
// realarray* colors(pen p);
void gen83(stack *Stack)
{
  pen p=vm::pop<pen>(Stack);
#line 1734 "runtime.in"  
  size_t n=ColorComponents[p.colorspace()];
  array *a=new array(n);
  
  switch(n) {
  case 0:
    break;
  case 1: 
    (*a)[0]=p.gray(); 
    break;
  case 3:
    (*a)[0]=p.red(); 
    (*a)[1]=p.green(); 
    (*a)[2]=p.blue(); 
    break;
  case 4:
    (*a)[0]=p.cyan();
    (*a)[1]=p.magenta(); 
    (*a)[2]=p.yellow(); 
    (*a)[3]=p.black();
    break;
  default:
    break;
  }
  {Stack->push<realarray*>(a); return;}
}

#line 1761 "runtime.in"
// string colorspace(pen p);
void gen84(stack *Stack)
{
  pen p=vm::pop<pen>(Stack);
#line 1762 "runtime.in"
  string s=ColorDeviceSuffix[p.colorspace()];
  std::transform(s.begin(),s.end(),s.begin(),tolower);
  {Stack->push<string>(s); return;}
}

#line 1768 "runtime.in"
// pen pattern(string *s);
void gen85(stack *Stack)
{
  string * s=vm::pop<string *>(Stack);
#line 1769 "runtime.in"
  {Stack->push<pen>(pen(setpattern,*s)); return;}
}

#line 1773 "runtime.in"
// string pattern(pen p);
void gen86(stack *Stack)
{
  pen p=vm::pop<pen>(Stack);
#line 1774 "runtime.in"
  {Stack->push<string>(p.fillpattern()); return;}  
}

#line 1778 "runtime.in"
// pen fillrule(Int n);
void gen87(stack *Stack)
{
  Int n=vm::pop<Int>(Stack);
#line 1779 "runtime.in"
  {Stack->push<pen>(pen(n >= 0 && n < nFill ? (FillRule) n : DEFFILL)); return;}
}

#line 1783 "runtime.in"
// Int fillrule(pen p);
void gen88(stack *Stack)
{
  pen p=vm::pop<pen>(Stack);
#line 1784 "runtime.in"
  {Stack->push<Int>(p.Fillrule()); return;}  
}

#line 1788 "runtime.in"
// pen opacity(real opacity=1.0, string blend=defaulttransparency);
void gen89(stack *Stack)
{
  string blend=vm::pop<string>(Stack,defaulttransparency);
  real opacity=vm::pop<real>(Stack,1.0);
#line 1789 "runtime.in"
  for(Int i=0; i < nBlendMode; ++i)
   if(blend == BlendMode[i]) {Stack->push<pen>(pen(Transparency(blend,opacity))); return;}

  ostringstream buf;
  buf << "Unknown blend mode: " << "'" << blend << "'";
  error(buf);
}

#line 1798 "runtime.in"
// real opacity(pen p);
void gen90(stack *Stack)
{
  pen p=vm::pop<pen>(Stack);
#line 1799 "runtime.in"
  {Stack->push<real>(p.opacity()); return;}
}

#line 1803 "runtime.in"
// string blend(pen p);
void gen91(stack *Stack)
{
  pen p=vm::pop<pen>(Stack);
#line 1804 "runtime.in"
  {Stack->push<string>(p.blend()); return;}
}

#line 1808 "runtime.in"
// pen linetype(string *s, real offset=0, bool scale=true, bool adjust=true);
void gen92(stack *Stack)
{
  bool adjust=vm::pop<bool>(Stack,true);
  bool scale=vm::pop<bool>(Stack,true);
  real offset=vm::pop<real>(Stack,0);
  string * s=vm::pop<string *>(Stack);
#line 1809 "runtime.in"
  {Stack->push<pen>(pen(LineType(*s,offset,scale,adjust))); return;} 
}

#line 1813 "runtime.in"
// string linetype(pen p);
void gen93(stack *Stack)
{
  pen p=vm::pop<pen>(Stack);
#line 1814 "runtime.in"
  {Stack->push<string>(p.stroke()); return;}  
}

#line 1818 "runtime.in"
// real offset(pen p);
void gen94(stack *Stack)
{
  pen p=vm::pop<pen>(Stack);
#line 1819 "runtime.in"
  {Stack->push<real>(p.linetype().offset); return;}
}

#line 1823 "runtime.in"
// bool scale(pen p);
void gen95(stack *Stack)
{
  pen p=vm::pop<pen>(Stack);
#line 1824 "runtime.in"
  {Stack->push<bool>(p.linetype().scale); return;}
}

#line 1828 "runtime.in"
// bool adjust(pen p);
void gen96(stack *Stack)
{
  pen p=vm::pop<pen>(Stack);
#line 1829 "runtime.in"
  {Stack->push<bool>(p.linetype().adjust); return;}
}

#line 1833 "runtime.in"
// pen adjust(pen p, real arclength, bool cyclic);
void gen97(stack *Stack)
{
  bool cyclic=vm::pop<bool>(Stack);
  real arclength=vm::pop<real>(Stack);
  pen p=vm::pop<pen>(Stack);
#line 1834 "runtime.in"
  {Stack->push<pen>(adjustdash(p,arclength,cyclic)); return;}
}

#line 1838 "runtime.in"
// pen linecap(Int n);
void gen98(stack *Stack)
{
  Int n=vm::pop<Int>(Stack);
#line 1839 "runtime.in"
  {Stack->push<pen>(pen(setlinecap,n >= 0 && n < nCap ? n : DEFCAP)); return;}
}

#line 1843 "runtime.in"
// Int linecap(pen p);
void gen99(stack *Stack)
{
  pen p=vm::pop<pen>(Stack);
#line 1844 "runtime.in"
  {Stack->push<Int>(p.cap()); return;}  
}

#line 1848 "runtime.in"
// pen linejoin(Int n);
void gen100(stack *Stack)
{
  Int n=vm::pop<Int>(Stack);
#line 1849 "runtime.in"
  {Stack->push<pen>(pen(setlinejoin,n >= 0 && n < nJoin ? n : DEFJOIN)); return;}
}

#line 1853 "runtime.in"
// Int linejoin(pen p);
void gen101(stack *Stack)
{
  pen p=vm::pop<pen>(Stack);
#line 1854 "runtime.in"
  {Stack->push<Int>(p.join()); return;}  
}

#line 1858 "runtime.in"
// pen linewidth(real x);
void gen102(stack *Stack)
{
  real x=vm::pop<real>(Stack);
#line 1859 "runtime.in"
  {Stack->push<pen>(pen(setlinewidth,x >= 0.0 ? x : DEFWIDTH)); return;}
}

#line 1863 "runtime.in"
// real linewidth(pen p);
void gen103(stack *Stack)
{
  pen p=vm::pop<pen>(Stack);
#line 1864 "runtime.in"
  {Stack->push<real>(p.width()); return;}  
}

#line 1868 "runtime.in"
// pen fontcommand(string *s);
void gen104(stack *Stack)
{
  string * s=vm::pop<string *>(Stack);
#line 1869 "runtime.in"
  {Stack->push<pen>(pen(setfont,*s)); return;}
}

#line 1873 "runtime.in"
// string font(pen p);
void gen105(stack *Stack)
{
  pen p=vm::pop<pen>(Stack);
#line 1874 "runtime.in"
  {Stack->push<string>(p.Font()); return;}
}

#line 1878 "runtime.in"
// pen fontsize(real size, real lineskip);
void gen106(stack *Stack)
{
  real lineskip=vm::pop<real>(Stack);
  real size=vm::pop<real>(Stack);
#line 1879 "runtime.in"
  {Stack->push<pen>(pen(setfontsize,size > 0.0 ? size : 0.0,
	     lineskip > 0.0 ? lineskip : 0.0)); return;}
}

#line 1884 "runtime.in"
// real fontsize(pen p);
void gen107(stack *Stack)
{
  pen p=vm::pop<pen>(Stack);
#line 1885 "runtime.in"
  {Stack->push<real>(p.size()); return;}
}

#line 1889 "runtime.in"
// real lineskip(pen p);
void gen108(stack *Stack)
{
  pen p=vm::pop<pen>(Stack);
#line 1890 "runtime.in"
  {Stack->push<real>(p.Lineskip()); return;}  
}

#line 1894 "runtime.in"
// pen overwrite(Int n);
void gen109(stack *Stack)
{
  Int n=vm::pop<Int>(Stack);
#line 1895 "runtime.in"
  {Stack->push<pen>(pen(setoverwrite,n >= 0 && n < nOverwrite ? (overwrite_t) n :
	     DEFWRITE)); return;}
}

#line 1900 "runtime.in"
// Int overwrite(pen p);
void gen110(stack *Stack)
{
  pen p=vm::pop<pen>(Stack);
#line 1901 "runtime.in"
  {Stack->push<Int>(p.Overwrite()); return;}  
}

#line 1905 "runtime.in"
// pen basealign(Int n);
void gen111(stack *Stack)
{
  Int n=vm::pop<Int>(Stack);
#line 1906 "runtime.in"
  {Stack->push<pen>(pen(n >= 0 && n < nBaseLine ? (BaseLine) n : DEFBASE)); return;}
}

#line 1910 "runtime.in"
// Int basealign(pen p);
void gen112(stack *Stack)
{
  pen p=vm::pop<pen>(Stack);
#line 1911 "runtime.in"
  {Stack->push<Int>(p.Baseline()); return;}
}

#line 1915 "runtime.in"
// transform transform(pen p);
void gen113(stack *Stack)
{
  pen p=vm::pop<pen>(Stack);
#line 1916 "runtime.in"
  {Stack->push<transform>(p.getTransform()); return;}
}

#line 1920 "runtime.in"
// path nib(pen p);
void gen114(stack *Stack)
{
  pen p=vm::pop<pen>(Stack);
#line 1921 "runtime.in"
  {Stack->push<path>(p.Path()); return;}
}

#line 1925 "runtime.in"
// pen makepen(path p);
void gen115(stack *Stack)
{
  path p=vm::pop<path>(Stack);
#line 1926 "runtime.in"
  {Stack->push<pen>(pen(p)); return;}
}

#line 1930 "runtime.in"
// pen colorless(pen p);
void gen116(stack *Stack)
{
  pen p=vm::pop<pen>(Stack);
#line 1931 "runtime.in"
  p.colorless();
  {Stack->push<pen>(p); return;}
}

// Interactive mode
#line 1937 "runtime.in"
// bool interactive();
void gen117(stack *Stack)
{
#line 1938 "runtime.in"
  {Stack->push<bool>(interact::interactive); return;}
}

#line 1943 "runtime.in"
// bool uptodate();
void gen118(stack *Stack)
{
#line 1944 "runtime.in"
  {Stack->push<bool>(interact::uptodate); return;}
}


// System commands
#line 1950 "runtime.in"
// Int system(string s);
void gen119(stack *Stack)
{
  string s=vm::pop<string>(Stack);
#line 1951 "runtime.in"
  if(safe) error("system() call disabled; override with option -unsafe");
  if(s.empty()) {Stack->push<Int>(0); return;}
  else {Stack->push<Int>(System(s.c_str())); return;}
}

#line 1958 "runtime.in"
// bool view();
void gen120(stack *Stack)
{
#line 1959 "runtime.in"
  {Stack->push<bool>(view()); return;}
}

#line 1963 "runtime.in"
// string asydir();
void gen121(stack *Stack)
{
#line 1964 "runtime.in"
  {Stack->push<string>(ASYMPTOTE_SYSDIR); return;}	
}

#line 1968 "runtime.in"
// string locale(string s=emptystring);
void gen122(stack *Stack)
{
  string s=vm::pop<string>(Stack,emptystring);
#line 1969 "runtime.in"
  char *L=setlocale(LC_ALL,s.empty() ? NULL : s.c_str());
  {Stack->push<string>(L != NULL ? string(L) : ""); return;}
}

#line 1974 "runtime.in"
// void abort(string s=emptystring);
void gen123(stack *Stack)
{
  string s=vm::pop<string>(Stack,emptystring);
#line 1975 "runtime.in"
  if(s.empty()) throw handled_error();
  error(s.c_str());
}

#line 1980 "runtime.in"
// void exit();
void gen124(stack *)
{
#line 1981 "runtime.in"
  throw quit();
}

#line 1985 "runtime.in"
// void assert(bool b, string s=emptystring);
void gen125(stack *Stack)
{
  string s=vm::pop<string>(Stack,emptystring);
  bool b=vm::pop<bool>(Stack);
#line 1986 "runtime.in"
  flush(cout);
  if(!b) {
    ostringstream buf;
    buf << "assert FAILED";
    if(s != "") buf << ": " << s << endl;
    error(buf);
  }
}

#line 1996 "runtime.in"
// void sleep(Int seconds);
void gen126(stack *Stack)
{
  Int seconds=vm::pop<Int>(Stack);
#line 1997 "runtime.in"
  if(seconds <= 0) return;	
  sleep(seconds);
}

#line 2002 "runtime.in"
// void usleep(Int microseconds);
void gen127(stack *Stack)
{
  Int microseconds=vm::pop<Int>(Stack);
#line 2003 "runtime.in"
  if(microseconds <= 0) return;	
  usleep((unsigned long) microseconds); 
}

#line 2008 "runtime.in"
// void _eval(string *s, bool embedded, bool interactiveWrite=false);
void gen128(stack *Stack)
{
  bool interactiveWrite=vm::pop<bool>(Stack,false);
  bool embedded=vm::pop<bool>(Stack);
  string * s=vm::pop<string *>(Stack);
#line 2009 "runtime.in"
  if (embedded) {
    trans::coenv *e=Stack->getEnvironment();
    vm::interactiveStack *is=dynamic_cast<vm::interactiveStack *>(Stack);
    if (e && is) {
      runStringEmbedded(*s, *e, *is);
    } else {
      cerr << "no runtime environment for embedded eval" << endl;
    }
  } else {
    runString(*s,interactiveWrite);
  }
}

#line 2023 "runtime.in"
// void _eval(runnable *s, bool embedded);
void gen129(stack *Stack)
{
  bool embedded=vm::pop<bool>(Stack);
  runnable * s=vm::pop<runnable *>(Stack);
#line 2024 "runtime.in"
  absyntax::block *ast=new absyntax::block(s->getPos(), false);
  ast->add(s);

  if (embedded) {
    trans::coenv *e=Stack->getEnvironment();
    vm::interactiveStack *is=dynamic_cast<vm::interactiveStack *>(Stack);
    if (e && is) {
      runCodeEmbedded(ast, *e, *is);
    } else {
      cerr << "no runtime environment for embedded eval" << endl;
    }
  } else {
    runCode(ast);
  }
}

#line 2041 "runtime.in"
// string location();
void gen130(stack *Stack)
{
#line 2042 "runtime.in"
  ostringstream buf;
  buf << getPos();
  {Stack->push<string>(buf.str()); return;}
}

// Wrapper for the stack::load() method.
#line 2048 "runtime.in"
void loadModule(stack *Stack)
{
  string * index=vm::pop<string *>(Stack);
#line 2049 "runtime.in"
  Stack->load(*index);
}

#line 2053 "runtime.in"
// string cd(string s=emptystring);
void gen132(stack *Stack)
{
  string s=vm::pop<string>(Stack,emptystring);
#line 2054 "runtime.in"
  if(!s.empty() && !globalwrite()) writeDisabled();
  {Stack->push<string>(setPath(s.c_str())); return;}
}

#line 2059 "runtime.in"
// void list(string *s, bool imports=false);
void gen133(stack *Stack)
{
  bool imports=vm::pop<bool>(Stack,false);
  string * s=vm::pop<string *>(Stack);
#line 2060 "runtime.in"
  if(*s == "-") return;
  trans::genv ge;
  symbol *name=symbol::trans(*s);
  record *r=ge.getModule(name,*s);
  r->e.list(imports ? 0 : r);
}


// Path operations
#line 2070 "runtime.in"
void nullPath(stack *Stack)
{
#line 2071 "runtime.in"
  {Stack->push<path>(nullpath); return;}
}

#line 2076 "runtime.in"
// bool ==(path a, path b);
void gen135(stack *Stack)
{
  path b=vm::pop<path>(Stack);
  path a=vm::pop<path>(Stack);
#line 2077 "runtime.in"
  {Stack->push<bool>(a == b); return;}
}

#line 2081 "runtime.in"
// bool !=(path a, path b);
void gen136(stack *Stack)
{
  path b=vm::pop<path>(Stack);
  path a=vm::pop<path>(Stack);
#line 2082 "runtime.in"
  {Stack->push<bool>(!(a == b)); return;}
}

#line 2086 "runtime.in"
// pair point(path p, Int t);
void gen137(stack *Stack)
{
  Int t=vm::pop<Int>(Stack);
  path p=vm::pop<path>(Stack);
#line 2087 "runtime.in"
  {Stack->push<pair>(p.point((Int) t)); return;}
}

#line 2091 "runtime.in"
// pair point(path p, real t);
void gen138(stack *Stack)
{
  real t=vm::pop<real>(Stack);
  path p=vm::pop<path>(Stack);
#line 2092 "runtime.in"
  {Stack->push<pair>(p.point(t)); return;}
}

#line 2096 "runtime.in"
// pair precontrol(path p, Int t);
void gen139(stack *Stack)
{
  Int t=vm::pop<Int>(Stack);
  path p=vm::pop<path>(Stack);
#line 2097 "runtime.in"
  {Stack->push<pair>(p.precontrol((Int) t)); return;}
}

#line 2101 "runtime.in"
// pair precontrol(path p, real t);
void gen140(stack *Stack)
{
  real t=vm::pop<real>(Stack);
  path p=vm::pop<path>(Stack);
#line 2102 "runtime.in"
  {Stack->push<pair>(p.precontrol(t)); return;}
}

#line 2106 "runtime.in"
// pair postcontrol(path p, Int t);
void gen141(stack *Stack)
{
  Int t=vm::pop<Int>(Stack);
  path p=vm::pop<path>(Stack);
#line 2107 "runtime.in"
  {Stack->push<pair>(p.postcontrol((Int) t)); return;}
}

#line 2111 "runtime.in"
// pair postcontrol(path p, real t);
void gen142(stack *Stack)
{
  real t=vm::pop<real>(Stack);
  path p=vm::pop<path>(Stack);
#line 2112 "runtime.in"
  {Stack->push<pair>(p.postcontrol(t)); return;}
}

#line 2116 "runtime.in"
// pair dir(path p, Int t, Int sign=0, bool normalize=true);
void gen143(stack *Stack)
{
  bool normalize=vm::pop<bool>(Stack,true);
  Int sign=vm::pop<Int>(Stack,0);
  Int t=vm::pop<Int>(Stack);
  path p=vm::pop<path>(Stack);
#line 2117 "runtime.in"
  {Stack->push<pair>(p.dir(t,sign,normalize)); return;}
}

#line 2121 "runtime.in"
// pair dir(path p, real t, bool normalize=true);
void gen144(stack *Stack)
{
  bool normalize=vm::pop<bool>(Stack,true);
  real t=vm::pop<real>(Stack);
  path p=vm::pop<path>(Stack);
#line 2122 "runtime.in"
  {Stack->push<pair>(p.dir(t,normalize)); return;}
}

#line 2126 "runtime.in"
// pair accel(path p, Int t, Int sign=0);
void gen145(stack *Stack)
{
  Int sign=vm::pop<Int>(Stack,0);
  Int t=vm::pop<Int>(Stack);
  path p=vm::pop<path>(Stack);
#line 2127 "runtime.in"
  {Stack->push<pair>(p.accel(t,sign)); return;}
}

#line 2131 "runtime.in"
// pair accel(path p, real t);
void gen146(stack *Stack)
{
  real t=vm::pop<real>(Stack);
  path p=vm::pop<path>(Stack);
#line 2132 "runtime.in"
  {Stack->push<pair>(p.accel(t)); return;}
}

#line 2136 "runtime.in"
// real radius(path p, real t);
void gen147(stack *Stack)
{
  real t=vm::pop<real>(Stack);
  path p=vm::pop<path>(Stack);
#line 2137 "runtime.in"
  pair v=p.dir(t,false);
  pair a=p.accel(t);
  real d=dot(a,v);
  real v2=v.abs2();
  real a2=a.abs2();
  real denom=v2*a2-d*d;
  real r=v2*sqrt(v2);
  {Stack->push<real>(denom > 0 ? r/sqrt(denom) : 0.0); return;}
}

#line 2148 "runtime.in"
// path reverse(path p);
void gen148(stack *Stack)
{
  path p=vm::pop<path>(Stack);
#line 2149 "runtime.in"
  {Stack->push<path>(p.reverse()); return;}
}

#line 2153 "runtime.in"
// path subpath(path p, Int a, Int b);
void gen149(stack *Stack)
{
  Int b=vm::pop<Int>(Stack);
  Int a=vm::pop<Int>(Stack);
  path p=vm::pop<path>(Stack);
#line 2154 "runtime.in"
  {Stack->push<path>(p.subpath((Int) a, (Int) b)); return;}
}

#line 2158 "runtime.in"
// path subpath(path p, real a, real b);
void gen150(stack *Stack)
{
  real b=vm::pop<real>(Stack);
  real a=vm::pop<real>(Stack);
  path p=vm::pop<path>(Stack);
#line 2159 "runtime.in"
  {Stack->push<path>(p.subpath(a,b)); return;}
}

#line 2163 "runtime.in"
// path nurb(pair z0, pair z1, pair z2, pair z3,	  real w0, real w1, real w2, real w3, Int m);
void gen151(stack *Stack)
{
  Int m=vm::pop<Int>(Stack);
  real w3=vm::pop<real>(Stack);
  real w2=vm::pop<real>(Stack);
  real w1=vm::pop<real>(Stack);
  real w0=vm::pop<real>(Stack);
  pair z3=vm::pop<pair>(Stack);
  pair z2=vm::pop<pair>(Stack);
  pair z1=vm::pop<pair>(Stack);
  pair z0=vm::pop<pair>(Stack);
#line 2165 "runtime.in"
  {Stack->push<path>(nurb(z0,z1,z2,z3,w0,w1,w2,w3,m)); return;}
}

#line 2169 "runtime.in"
// Int length(path p);
void gen152(stack *Stack)
{
  path p=vm::pop<path>(Stack);
#line 2170 "runtime.in"
  {Stack->push<Int>(p.length()); return;}
}

#line 2174 "runtime.in"
// bool cyclic(path p);
void gen153(stack *Stack)
{
  path p=vm::pop<path>(Stack);
#line 2175 "runtime.in"
  {Stack->push<bool>(p.cyclic()); return;}
}

#line 2179 "runtime.in"
// bool straight(path p, Int t);
void gen154(stack *Stack)
{
  Int t=vm::pop<Int>(Stack);
  path p=vm::pop<path>(Stack);
#line 2180 "runtime.in"
  {Stack->push<bool>(p.straight(t)); return;}
}

#line 2184 "runtime.in"
// path unstraighten(path p);
void gen155(stack *Stack)
{
  path p=vm::pop<path>(Stack);
#line 2185 "runtime.in"
  {Stack->push<path>(p.unstraighten()); return;}
}

#line 2189 "runtime.in"
// bool piecewisestraight(path p);
void gen156(stack *Stack)
{
  path p=vm::pop<path>(Stack);
#line 2190 "runtime.in"
  {Stack->push<bool>(p.piecewisestraight()); return;}
}

#line 2194 "runtime.in"
// real arclength(path p);
void gen157(stack *Stack)
{
  path p=vm::pop<path>(Stack);
#line 2195 "runtime.in"
  {Stack->push<real>(p.arclength()); return;}
}

#line 2199 "runtime.in"
// real arctime(path p, real dval);
void gen158(stack *Stack)
{
  real dval=vm::pop<real>(Stack);
  path p=vm::pop<path>(Stack);
#line 2200 "runtime.in"
  {Stack->push<real>(p.arctime(dval)); return;}
}

#line 2204 "runtime.in"
// real dirtime(path p, pair z);
void gen159(stack *Stack)
{
  pair z=vm::pop<pair>(Stack);
  path p=vm::pop<path>(Stack);
#line 2205 "runtime.in"
  {Stack->push<real>(p.directiontime(z)); return;}
}

#line 2209 "runtime.in"
// realarray* intersect(path p, path q, real fuzz=-1);
void gen160(stack *Stack)
{
  real fuzz=vm::pop<real>(Stack,-1);
  path q=vm::pop<path>(Stack);
  path p=vm::pop<path>(Stack);
#line 2210 "runtime.in"
  if(fuzz < 0)
    fuzz=BigFuzz*::max(::max(length(p.max()),length(p.min())),
		       ::max(length(q.max()),length(q.min())));
  std::vector<real> S,T;
  real s,t;
  if(intersections(s,t,S,T,p,q,fuzz,true)) {
    array *V=new array(2);
    (*V)[0]=s;
    (*V)[1]=t;
    {Stack->push<realarray*>(V); return;}
  } else
    {Stack->push<realarray*>(new array(0)); return;}
}

#line 2225 "runtime.in"
// realarray2* intersections(path p, path q, real fuzz=-1);
void gen161(stack *Stack)
{
  real fuzz=vm::pop<real>(Stack,-1);
  path q=vm::pop<path>(Stack);
  path p=vm::pop<path>(Stack);
#line 2226 "runtime.in"
  if(fuzz < 0)
    fuzz=BigFuzz*::max(::max(length(p.max()),length(p.min())),
		       ::max(length(q.max()),length(q.min())));
  real s,t;
  std::vector<real> S,T;
  intersections(s,t,S,T,p,q,fuzz,false);
  size_t n=S.size();
  array *V=new array(n);
  for(size_t i=0; i < n; ++i) {
    array *Vi=new array(2);
    (*V)[i]=Vi;
    (*Vi)[0]=S[i];
    (*Vi)[1]=T[i];
  }
  stable_sort(V->begin(),V->end(),run::compare2<real>());
  {Stack->push<realarray2*>(V); return;}
}

#line 2245 "runtime.in"
// realarray* intersections(path p, pair a, pair b, real fuzz=-1);
void gen162(stack *Stack)
{
  real fuzz=vm::pop<real>(Stack,-1);
  pair b=vm::pop<pair>(Stack);
  pair a=vm::pop<pair>(Stack);
  path p=vm::pop<path>(Stack);
#line 2246 "runtime.in"
  if(fuzz < 0)
    fuzz=BigFuzz*::max(::max(length(p.max()),length(p.min())),
		       ::max(length(a),length(b)));
  std::vector<real> S;
  intersections(S,p,a,b,fuzz);
  sort(S.begin(),S.end());
  size_t n=S.size();
  array *V=new array(n);
  for(size_t i=0; i < n; ++i)
    (*V)[i]=S[i];
  {Stack->push<realarray*>(V); return;}
}

#line 2260 "runtime.in"
// Int size(path p);
void gen163(stack *Stack)
{
  path p=vm::pop<path>(Stack);
#line 2261 "runtime.in"
  {Stack->push<Int>(p.size()); return;}
}

#line 2265 "runtime.in"
// path &(path p, path q);
void gen164(stack *Stack)
{
  path q=vm::pop<path>(Stack);
  path p=vm::pop<path>(Stack);
#line 2266 "runtime.in"
  {Stack->push<path>(camp::concat(p,q)); return;}
}

#line 2270 "runtime.in"
// pair min(path p);
void gen165(stack *Stack)
{
  path p=vm::pop<path>(Stack);
#line 2271 "runtime.in"
  {Stack->push<pair>(p.min()); return;}
}

#line 2275 "runtime.in"
// pair max(path p);
void gen166(stack *Stack)
{
  path p=vm::pop<path>(Stack);
#line 2276 "runtime.in"
  {Stack->push<pair>(p.max()); return;}
}

#line 2280 "runtime.in"
// realarray* mintimes(path p);
void gen167(stack *Stack)
{
  path p=vm::pop<path>(Stack);
#line 2281 "runtime.in"
  array *V=new array(2);
  pair z=p.mintimes();
  (*V)[0]=z.getx();
  (*V)[1]=z.gety();
  {Stack->push<realarray*>(V); return;}
}

#line 2289 "runtime.in"
// realarray* maxtimes(path p);
void gen168(stack *Stack)
{
  path p=vm::pop<path>(Stack);
#line 2290 "runtime.in"
  array *V=new array(2);
  pair z=p.maxtimes();
  (*V)[0]=z.getx();
  (*V)[1]=z.gety();
  {Stack->push<realarray*>(V); return;}
}

#line 2298 "runtime.in"
// real relativedistance(real theta, real phi, real t, bool atleast);
void gen169(stack *Stack)
{
  bool atleast=vm::pop<bool>(Stack);
  real t=vm::pop<real>(Stack);
  real phi=vm::pop<real>(Stack);
  real theta=vm::pop<real>(Stack);
#line 2299 "runtime.in"
  {Stack->push<real>(camp::velocity(theta,phi,tension(t,atleast))); return;}
}

#line 2303 "runtime.in"
// Int windingnumber(patharray *p, pair z);
void gen170(stack *Stack)
{
  pair z=vm::pop<pair>(Stack);
  patharray * p=vm::pop<patharray *>(Stack);
#line 2304 "runtime.in"
  {Stack->push<Int>(windingnumber(p,z)); return;}
}

#line 2308 "runtime.in"
// bool inside(explicit patharray *g, pair z, pen fillrule=CURRENTPEN);
void gen171(stack *Stack)
{
  pen fillrule=vm::pop<pen>(Stack,CURRENTPEN);
  pair z=vm::pop<pair>(Stack);
  patharray * g=vm::pop<patharray *>(Stack);
#line 2309 "runtime.in"
  {Stack->push<bool>(fillrule.inside(windingnumber(g,z))); return;}
}

#line 2313 "runtime.in"
// bool inside(path g, pair z, pen fillrule=CURRENTPEN);
void gen172(stack *Stack)
{
  pen fillrule=vm::pop<pen>(Stack,CURRENTPEN);
  pair z=vm::pop<pair>(Stack);
  path g=vm::pop<path>(Stack);
#line 2314 "runtime.in"
  {Stack->push<bool>(fillrule.inside(g.windingnumber(z))); return;}
}

// Determine the side of a--b that c lies on
// (negative=left, zero=on line, positive=right).
#line 2320 "runtime.in"
// real side(pair a, pair b, pair c);
void gen173(stack *Stack)
{
  pair c=vm::pop<pair>(Stack);
  pair b=vm::pop<pair>(Stack);
  pair a=vm::pop<pair>(Stack);
#line 2321 "runtime.in"
  {Stack->push<real>(orient2d(a,b,c)); return;}
}

// Determine the side of the counterclockwise circle through a,b,c that d
// lies on (negative=inside, 0=on circle, positive=right). 
#line 2327 "runtime.in"
// real incircle(pair a, pair b, pair c, pair d);
void gen174(stack *Stack)
{
  pair d=vm::pop<pair>(Stack);
  pair c=vm::pop<pair>(Stack);
  pair b=vm::pop<pair>(Stack);
  pair a=vm::pop<pair>(Stack);
#line 2328 "runtime.in"
  {Stack->push<real>(incircle(a.getx(),a.gety(),b.getx(),b.gety(),c.getx(),c.gety(),
		  d.getx(),d.gety())); return;}
}


// Path3 operations
#line 2335 "runtime.in"
// path3 path3(triplearray *pre, triplearray *point, triplearray *post,	    boolarray *straight, bool cyclic);
void gen175(stack *Stack)
{
  bool cyclic=vm::pop<bool>(Stack);
  boolarray * straight=vm::pop<boolarray *>(Stack);
  triplearray * post=vm::pop<triplearray *>(Stack);
  triplearray * point=vm::pop<triplearray *>(Stack);
  triplearray * pre=vm::pop<triplearray *>(Stack);
#line 2337 "runtime.in"
  size_t n=checkArrays(pre,point);
  checkEqual(n,checkArray(post));
  checkEqual(n,checkArray(straight));
  mem::vector<solvedKnot3> nodes(n);
  for(size_t i=0; i < n; ++i) {
    nodes[i].pre=read<triple>(pre,i);
    nodes[i].point=read<triple>(point,i);
    nodes[i].post=read<triple>(post,i);
    nodes[i].straight=read<bool>(straight,i);
  }

  {Stack->push<path3>(path3(nodes,(Int) n,cyclic)); return;}
}

#line 2353 "runtime.in"
void nullPath3(stack *Stack)
{
#line 2354 "runtime.in"
  {Stack->push<path3>(nullpath3); return;}
}

#line 2358 "runtime.in"
// bool ==(path3 a, path3 b);
void gen177(stack *Stack)
{
  path3 b=vm::pop<path3>(Stack);
  path3 a=vm::pop<path3>(Stack);
#line 2359 "runtime.in"
  {Stack->push<bool>(a == b); return;}
}

#line 2363 "runtime.in"
// bool !=(path3 a, path3 b);
void gen178(stack *Stack)
{
  path3 b=vm::pop<path3>(Stack);
  path3 a=vm::pop<path3>(Stack);
#line 2364 "runtime.in"
  {Stack->push<bool>(!(a == b)); return;}
}

#line 2368 "runtime.in"
// triple point(path3 p, Int t);
void gen179(stack *Stack)
{
  Int t=vm::pop<Int>(Stack);
  path3 p=vm::pop<path3>(Stack);
#line 2369 "runtime.in"
  {Stack->push<triple>(p.point((Int) t)); return;}
}

#line 2373 "runtime.in"
// triple point(path3 p, real t);
void gen180(stack *Stack)
{
  real t=vm::pop<real>(Stack);
  path3 p=vm::pop<path3>(Stack);
#line 2374 "runtime.in"
  {Stack->push<triple>(p.point(t)); return;}
}

#line 2378 "runtime.in"
// triple precontrol(path3 p, Int t);
void gen181(stack *Stack)
{
  Int t=vm::pop<Int>(Stack);
  path3 p=vm::pop<path3>(Stack);
#line 2379 "runtime.in"
  {Stack->push<triple>(p.precontrol((Int) t)); return;}
}

#line 2383 "runtime.in"
// triple precontrol(path3 p, real t);
void gen182(stack *Stack)
{
  real t=vm::pop<real>(Stack);
  path3 p=vm::pop<path3>(Stack);
#line 2384 "runtime.in"
  {Stack->push<triple>(p.precontrol(t)); return;}
}

#line 2388 "runtime.in"
// triple postcontrol(path3 p, Int t);
void gen183(stack *Stack)
{
  Int t=vm::pop<Int>(Stack);
  path3 p=vm::pop<path3>(Stack);
#line 2389 "runtime.in"
  {Stack->push<triple>(p.postcontrol((Int) t)); return;}
}

#line 2393 "runtime.in"
// triple postcontrol(path3 p, real t);
void gen184(stack *Stack)
{
  real t=vm::pop<real>(Stack);
  path3 p=vm::pop<path3>(Stack);
#line 2394 "runtime.in"
  {Stack->push<triple>(p.postcontrol(t)); return;}
}

#line 2398 "runtime.in"
// triple dir(path3 p, Int t, Int sign=0, bool normalize=true);
void gen185(stack *Stack)
{
  bool normalize=vm::pop<bool>(Stack,true);
  Int sign=vm::pop<Int>(Stack,0);
  Int t=vm::pop<Int>(Stack);
  path3 p=vm::pop<path3>(Stack);
#line 2399 "runtime.in"
  {Stack->push<triple>(p.dir(t,sign,normalize)); return;}
}

#line 2403 "runtime.in"
// triple dir(path3 p, real t, bool normalize=true);
void gen186(stack *Stack)
{
  bool normalize=vm::pop<bool>(Stack,true);
  real t=vm::pop<real>(Stack);
  path3 p=vm::pop<path3>(Stack);
#line 2404 "runtime.in"
  {Stack->push<triple>(p.dir(t,normalize)); return;}
}

#line 2408 "runtime.in"
// triple accel(path3 p, Int t, Int sign=0);
void gen187(stack *Stack)
{
  Int sign=vm::pop<Int>(Stack,0);
  Int t=vm::pop<Int>(Stack);
  path3 p=vm::pop<path3>(Stack);
#line 2409 "runtime.in"
  {Stack->push<triple>(p.accel(t,sign)); return;}
}

#line 2413 "runtime.in"
// triple accel(path3 p, real t);
void gen188(stack *Stack)
{
  real t=vm::pop<real>(Stack);
  path3 p=vm::pop<path3>(Stack);
#line 2414 "runtime.in"
  {Stack->push<triple>(p.accel(t)); return;}
}

#line 2418 "runtime.in"
// real radius(path3 p, real t);
void gen189(stack *Stack)
{
  real t=vm::pop<real>(Stack);
  path3 p=vm::pop<path3>(Stack);
#line 2419 "runtime.in"
  triple v=p.dir(t,false);
  triple a=p.accel(t);
  real d=dot(a,v);
  real v2=v.abs2();
  real a2=a.abs2();
  real denom=v2*a2-d*d;
  real r=v2*sqrt(v2);
  {Stack->push<real>(denom > 0 ? r/sqrt(denom) : 0.0); return;}
}

#line 2430 "runtime.in"
// path3 reverse(path3 p);
void gen190(stack *Stack)
{
  path3 p=vm::pop<path3>(Stack);
#line 2431 "runtime.in"
  {Stack->push<path3>(p.reverse()); return;}
}

#line 2435 "runtime.in"
// path3 subpath(path3 p, Int a, Int b);
void gen191(stack *Stack)
{
  Int b=vm::pop<Int>(Stack);
  Int a=vm::pop<Int>(Stack);
  path3 p=vm::pop<path3>(Stack);
#line 2436 "runtime.in"
  {Stack->push<path3>(p.subpath((Int) a, (Int) b)); return;}
}

#line 2440 "runtime.in"
// path3 subpath(path3 p, real a, real b);
void gen192(stack *Stack)
{
  real b=vm::pop<real>(Stack);
  real a=vm::pop<real>(Stack);
  path3 p=vm::pop<path3>(Stack);
#line 2441 "runtime.in"
  {Stack->push<path3>(p.subpath(a,b)); return;}
}

#line 2445 "runtime.in"
// Int length(path3 p);
void gen193(stack *Stack)
{
  path3 p=vm::pop<path3>(Stack);
#line 2446 "runtime.in"
  {Stack->push<Int>(p.length()); return;}
}

#line 2450 "runtime.in"
// bool cyclic(path3 p);
void gen194(stack *Stack)
{
  path3 p=vm::pop<path3>(Stack);
#line 2451 "runtime.in"
  {Stack->push<bool>(p.cyclic()); return;}
}

#line 2455 "runtime.in"
// bool straight(path3 p, Int t);
void gen195(stack *Stack)
{
  Int t=vm::pop<Int>(Stack);
  path3 p=vm::pop<path3>(Stack);
#line 2456 "runtime.in"
  {Stack->push<bool>(p.straight(t)); return;}
}

// Return the maximum perpendicular deviation of segment i of path3 g
// from a straight line.
#line 2462 "runtime.in"
// real straightness(path3 p, Int t);
void gen196(stack *Stack)
{
  Int t=vm::pop<Int>(Stack);
  path3 p=vm::pop<path3>(Stack);
#line 2463 "runtime.in"
  if(p.straight(t)) {Stack->push<real>(0); return;}
  triple z0=p.point(t);
  triple u=unit(p.point(t+1)-z0);
  {Stack->push<real>(::max(length(perp(p.postcontrol(t)-z0,u)),
	       length(perp(p.precontrol(t+1)-z0,u)))); return;}
}

#line 2471 "runtime.in"
// bool piecewisestraight(path3 p);
void gen197(stack *Stack)
{
  path3 p=vm::pop<path3>(Stack);
#line 2472 "runtime.in"
  {Stack->push<bool>(p.piecewisestraight()); return;}
}

#line 2476 "runtime.in"
// real arclength(path3 p);
void gen198(stack *Stack)
{
  path3 p=vm::pop<path3>(Stack);
#line 2477 "runtime.in"
  {Stack->push<real>(p.arclength()); return;}
}

#line 2481 "runtime.in"
// real arctime(path3 p, real dval);
void gen199(stack *Stack)
{
  real dval=vm::pop<real>(Stack);
  path3 p=vm::pop<path3>(Stack);
#line 2482 "runtime.in"
  {Stack->push<real>(p.arctime(dval)); return;}
}

#line 2486 "runtime.in"
// realarray* intersect(path3 p, path3 q, real fuzz=-1);
void gen200(stack *Stack)
{
  real fuzz=vm::pop<real>(Stack,-1);
  path3 q=vm::pop<path3>(Stack);
  path3 p=vm::pop<path3>(Stack);
#line 2487 "runtime.in"
  if(fuzz < 0) 
    fuzz=BigFuzz*::max(::max(length(p.max()),length(p.min())),
		       ::max(length(q.max()),length(q.min())));
  std::vector<real> S,T;
  real s,t;
  if(intersections(s,t,S,T,p,q,fuzz,true)) {
    array *V=new array(2);
    (*V)[0]=s;
    (*V)[1]=t;
    {Stack->push<realarray*>(V); return;}
  } else
    {Stack->push<realarray*>(new array(0)); return;}
}

#line 2502 "runtime.in"
// realarray2* intersections(path3 p, path3 q, real fuzz=-1);
void gen201(stack *Stack)
{
  real fuzz=vm::pop<real>(Stack,-1);
  path3 q=vm::pop<path3>(Stack);
  path3 p=vm::pop<path3>(Stack);
#line 2503 "runtime.in"
  if(fuzz < 0)
    fuzz=BigFuzz*::max(::max(length(p.max()),length(p.min())),
		       ::max(length(q.max()),length(q.min())));
  real s,t;
  std::vector<real> S,T;
  intersections(s,t,S,T,p,q,fuzz,false);
  size_t n=S.size();
  array *V=new array(n);
  for(size_t i=0; i < n; ++i) {
    array *Vi=new array(2);
    (*V)[i]=Vi;
    (*Vi)[0]=S[i];
    (*Vi)[1]=T[i];
  }
  stable_sort(V->begin(),V->end(),run::compare2<real>());
  {Stack->push<realarray2*>(V); return;}
}

#line 2522 "runtime.in"
// Int size(path3 p);
void gen202(stack *Stack)
{
  path3 p=vm::pop<path3>(Stack);
#line 2523 "runtime.in"
  {Stack->push<Int>(p.size()); return;}
}

#line 2527 "runtime.in"
// path3 &(path3 p, path3 q);
void gen203(stack *Stack)
{
  path3 q=vm::pop<path3>(Stack);
  path3 p=vm::pop<path3>(Stack);
#line 2528 "runtime.in"
  {Stack->push<path3>(camp::concat(p,q)); return;}
}

#line 2532 "runtime.in"
// triple min(path3 p);
void gen204(stack *Stack)
{
  path3 p=vm::pop<path3>(Stack);
#line 2533 "runtime.in"
  {Stack->push<triple>(p.min()); return;}
}

#line 2537 "runtime.in"
// triple max(path3 p);
void gen205(stack *Stack)
{
  path3 p=vm::pop<path3>(Stack);
#line 2538 "runtime.in"
  {Stack->push<triple>(p.max()); return;}
}

#line 2542 "runtime.in"
// realarray* mintimes(path3 p);
void gen206(stack *Stack)
{
  path3 p=vm::pop<path3>(Stack);
#line 2543 "runtime.in"
  array *V=new array(3);
  triple v=p.mintimes();
  (*V)[0]=v.getx();
  (*V)[1]=v.gety();
  (*V)[2]=v.getz();
  {Stack->push<realarray*>(V); return;}
}

#line 2552 "runtime.in"
// realarray* maxtimes(path3 p);
void gen207(stack *Stack)
{
  path3 p=vm::pop<path3>(Stack);
#line 2553 "runtime.in"
  array *V=new array(3);
  triple v=p.maxtimes();
  (*V)[0]=v.getx();
  (*V)[1]=v.gety();
  (*V)[2]=v.getz();
  {Stack->push<realarray*>(V); return;}
}

#line 2562 "runtime.in"
// path3 *(realarray2 *t, path3 g);
void gen208(stack *Stack)
{
  path3 g=vm::pop<path3>(Stack);
  realarray2 * t=vm::pop<realarray2 *>(Stack);
#line 2563 "runtime.in"
  {Stack->push<path3>(transformed(*t,g)); return;}
}


// Guide operations
#line 2569 "runtime.in"
void nullGuide(stack *Stack)
{
#line 2570 "runtime.in"
  {Stack->push<guide*>(new pathguide(path())); return;}
}

#line 2575 "runtime.in"
void dotsGuide(stack *Stack)
{
  guidearray * a=vm::pop<guidearray *>(Stack);
#line 2576 "runtime.in"
  guidevector v;
  size_t size=checkArray(a);
  for (size_t i=0; i < size; ++i)
    v.push_back(a->read<guide*>(i));

  {Stack->push<guide*>(new multiguide(v)); return;}
}

#line 2585 "runtime.in"
void dashesGuide(stack *Stack)
{
  guidearray * a=vm::pop<guidearray *>(Stack);
#line 2586 "runtime.in"
  static camp::curlSpec curly;
  static specguide curlout(&curly, camp::OUT);
  static specguide curlin(&curly, camp::IN);

  size_t n=checkArray(a);

  // a--b is equivalent to a{curl 1}..{curl 1}b
  guidevector v;
  if (n > 0)
    v.push_back(a->read<guide*>(0));

  if (n==1) {
    v.push_back(&curlout);
    v.push_back(&curlin);
  }
  else
    for (size_t i=1; i<n; ++i) {
      v.push_back(&curlout);
      v.push_back(&curlin);
      v.push_back(a->read<guide*>(i));
    }

  {Stack->push<guide*>(new multiguide(v)); return;}
}

#line 2612 "runtime.in"
void newCycleToken(stack *Stack)
{
#line 2613 "runtime.in"
  {Stack->push<cycleToken>(cycleToken()); return;}
}

#line 2617 "runtime.in"
// guide* operator cast(cycleToken tok);
void gen213(stack *Stack)
{
  cycleToken tok=vm::pop<cycleToken>(Stack);
#line 2618 "runtime.in"
// Avoid unused variable warning messages.
  unused(&tok);
  {Stack->push<guide*>(new cycletokguide()); return;}
}

#line 2624 "runtime.in"
// guide* operator spec(pair z, Int p);
void gen214(stack *Stack)
{
  Int p=vm::pop<Int>(Stack);
  pair z=vm::pop<pair>(Stack);
#line 2625 "runtime.in"
  camp::side d=(camp::side) p;
  camp::dirSpec *sp=new camp::dirSpec(z);

  {Stack->push<guide*>(new specguide(sp,d)); return;}
}

#line 2632 "runtime.in"
// curlSpecifier operator curl(real gamma, Int p);
void gen215(stack *Stack)
{
  Int p=vm::pop<Int>(Stack);
  real gamma=vm::pop<real>(Stack);
#line 2633 "runtime.in"
  camp::side s=(camp::side) p;
  {Stack->push<curlSpecifier>(curlSpecifier(gamma,s)); return;}
}

#line 2638 "runtime.in"
void curlSpecifierValuePart(stack *Stack)
{
  curlSpecifier spec=vm::pop<curlSpecifier>(Stack);
#line 2639 "runtime.in"
  {Stack->push<real>(spec.getValue()); return;}
}

#line 2643 "runtime.in"
void curlSpecifierSidePart(stack *Stack)
{
  curlSpecifier spec=vm::pop<curlSpecifier>(Stack);
#line 2644 "runtime.in"
  {Stack->push<Int>(spec.getSide()); return;}
}

#line 2648 "runtime.in"
// guide* operator cast(curlSpecifier spec);
void gen218(stack *Stack)
{
  curlSpecifier spec=vm::pop<curlSpecifier>(Stack);
#line 2649 "runtime.in"
  {Stack->push<guide*>(new specguide(spec)); return;}
}

#line 2653 "runtime.in"
// tensionSpecifier operator tension(real tout, real tin, bool atleast);
void gen219(stack *Stack)
{
  bool atleast=vm::pop<bool>(Stack);
  real tin=vm::pop<real>(Stack);
  real tout=vm::pop<real>(Stack);
#line 2654 "runtime.in"
  {Stack->push<tensionSpecifier>(tensionSpecifier(tout, tin, atleast)); return;}
}

#line 2658 "runtime.in"
void tensionSpecifierOutPart(stack *Stack)
{
  tensionSpecifier t=vm::pop<tensionSpecifier>(Stack);
#line 2659 "runtime.in"
  {Stack->push<real>(t.getOut()); return;}
}

#line 2663 "runtime.in"
void tensionSpecifierInPart(stack *Stack)
{
  tensionSpecifier t=vm::pop<tensionSpecifier>(Stack);
#line 2664 "runtime.in"
  {Stack->push<real>(t.getIn()); return;}
}

#line 2668 "runtime.in"
void tensionSpecifierAtleastPart(stack *Stack)
{
  tensionSpecifier t=vm::pop<tensionSpecifier>(Stack);
#line 2669 "runtime.in"
  {Stack->push<bool>(t.getAtleast()); return;}
}

#line 2673 "runtime.in"
// guide* operator cast(tensionSpecifier t);
void gen223(stack *Stack)
{
  tensionSpecifier t=vm::pop<tensionSpecifier>(Stack);
#line 2674 "runtime.in"
  {Stack->push<guide*>(new tensionguide(t)); return;}
}

#line 2678 "runtime.in"
// guide* operator controls(pair zout, pair zin);
void gen224(stack *Stack)
{
  pair zin=vm::pop<pair>(Stack);
  pair zout=vm::pop<pair>(Stack);
#line 2679 "runtime.in"
  {Stack->push<guide*>(new controlguide(zout, zin)); return;}
}

#line 2683 "runtime.in"
// Int size(guide *g);
void gen225(stack *Stack)
{
  guide * g=vm::pop<guide *>(Stack);
#line 2684 "runtime.in"
  flatguide f;
  g->flatten(f,false);
  {Stack->push<Int>(f.size()); return;}
}

#line 2690 "runtime.in"
// Int length(guide *g);
void gen226(stack *Stack)
{
  guide * g=vm::pop<guide *>(Stack);
#line 2691 "runtime.in"
  flatguide f;
  g->flatten(f,false);
  {Stack->push<Int>(g->cyclic() ? f.size() : f.size()-1); return;}
}

#line 2697 "runtime.in"
// bool cyclic(guide *g);
void gen227(stack *Stack)
{
  guide * g=vm::pop<guide *>(Stack);
#line 2698 "runtime.in"
  flatguide f;
  g->flatten(f,false);
  {Stack->push<bool>(g->cyclic()); return;}
}

#line 2704 "runtime.in"
// pair point(guide *g, Int t);
void gen228(stack *Stack)
{
  Int t=vm::pop<Int>(Stack);
  guide * g=vm::pop<guide *>(Stack);
#line 2705 "runtime.in"
  flatguide f;
  g->flatten(f,false);
  {Stack->push<pair>(f.Nodes(adjustedIndex(t,f.size(),g->cyclic())).z); return;}
}

#line 2711 "runtime.in"
// pairarray* dirSpecifier(guide *g, Int t);
void gen229(stack *Stack)
{
  Int t=vm::pop<Int>(Stack);
  guide * g=vm::pop<guide *>(Stack);
#line 2712 "runtime.in"
  flatguide f;
  g->flatten(f,false);
  array *c=new array(2);
  Int n=f.size();
  if(g->cyclic()) t=t % n;
  else if(t < 0 || t >= n-1) {
    (*c)[0]=zero;
    (*c)[1]=zero;
    {Stack->push<pairarray*>(c); return;}
  }
  (*c)[0]=f.Nodes(t).out->dir();
  (*c)[1]=f.Nodes(t+1).in->dir();
  {Stack->push<pairarray*>(c); return;}
}

#line 2728 "runtime.in"
// pairarray* controlSpecifier(guide *g, Int t);
void gen230(stack *Stack)
{
  Int t=vm::pop<Int>(Stack);
  guide * g=vm::pop<guide *>(Stack);
#line 2729 "runtime.in"
  flatguide f;
  g->flatten(f,false);
  Int n=f.size();
  if(g->cyclic()) t=t % n;
  else if(t < 0 || t >= n-1) {Stack->push<pairarray*>(new array(0)); return;}
  knot curr=f.Nodes(t);
  knot next=f.Nodes(t+1);
  if(curr.out->controlled()) {
    array *c;
    assert(next.in->controlled());
    c=new array(2);
    (*c)[0]=curr.out->control();
    (*c)[1]=next.in->control();
    {Stack->push<pairarray*>(c); return;}
  } else {Stack->push<pairarray*>(new array(0)); return;}
}

#line 2747 "runtime.in"
// tensionSpecifier tensionSpecifier(guide *g, Int t);
void gen231(stack *Stack)
{
  Int t=vm::pop<Int>(Stack);
  guide * g=vm::pop<guide *>(Stack);
#line 2748 "runtime.in"
  flatguide f;
  g->flatten(f,false);
  Int n=f.size();
  if(g->cyclic()) t=t % n;
  else if(t < 0 || t >= n-1) {Stack->push<tensionSpecifier>(tensionSpecifier(1.0,1.0,false)); return;}
  knot curr=f.Nodes(t);
  knot next=f.Nodes(t+1);
  {Stack->push<tensionSpecifier>(tensionSpecifier(curr.tout.val,next.tin.val,curr.tout.atleast)); return;}
}

#line 2759 "runtime.in"
// realarray* curlSpecifier(guide *g);
void gen232(stack *Stack)
{
  guide * g=vm::pop<guide *>(Stack);
#line 2760 "runtime.in"
  flatguide f;
  g->flatten(f,false);
  array *c=new array(2);
  real c0=f.Nodes(0).out->curl();
  real c1=f.Nodes(f.size()-1).in->curl();
  if(c1 < 0.0) c1=f.Nodes(f.size()-1).out->curl();
  (*c)[0]=c0 >= 0.0 ? c0 : 1.0;
  (*c)[1]=c1 >= 0.0 ? c1 : 1.0;
  {Stack->push<realarray*>(c); return;}
}

#line 2772 "runtime.in"
// guide* reverse(guide *g);
void gen233(stack *Stack)
{
  guide * g=vm::pop<guide *>(Stack);
#line 2773 "runtime.in"
  flatguide f;
  bool precycle=g->flatten(f,false);
  if(precycle && g->cyclic()) {
    path p=g->solve();
    {Stack->push<guide*>(new pathguide(p.reverse())); return;}
  }
  Int n=f.size();

  guidevector v;
  if(n >= 0) {
    v.push_back(new pairguide(f.Nodes(n-1).z));
    
    real c0=f.Nodes(0).out->curl();
    real c1=f.Nodes(f.size()-1).in->curl();
    if(c1 < 0.0)
      c1=f.Nodes(f.size()-1).out->curl();
    if(c1 >= 0.0)
      v.push_back(new specguide(new curlSpec(c1),camp::OUT));
  
    for(Int i=n-2; i >= 0; --i) {
      knot curr=f.Nodes(i);
      knot next=f.Nodes(i+1);
      if(curr.out->controlled()) {
	assert(next.in->controlled());
	v.push_back(new controlguide(next.in->control(),curr.out->control()));
      } else {
	pair d=f.Nodes(i+1).in->dir();
	if(d != zero) 
	  v.push_back(new specguide(new dirSpec(-d),camp::OUT));
	real tout=next.tin.val;
	real tin=curr.tout.val;
	bool atleast=curr.tout.atleast;
	if(tout != 1.0 || tin != 1.0 || curr.tout.atleast)
	  v.push_back(new tensionguide(tensionSpecifier(tout,tin,atleast)));
	d=f.Nodes(i).out->dir();	
	if(d != zero) 
	  v.push_back(new specguide(new dirSpec(-d),camp::IN));

      }
      if(i == 0 && c0 >= 0.0)
	v.push_back(new specguide(new curlSpec(c0),camp::IN));
      v.push_back(new pairguide(f.Nodes(i).z));
    }
    if(g->cyclic())
      v.push_back(new cycletokguide());
  }
  {Stack->push<guide*>(new multiguide(v)); return;}
}


// Three-dimensional picture and surface operations
#line 2825 "runtime.in"
// void _draw(picture *f, path3 g, pen p);
void gen234(stack *Stack)
{
  pen p=vm::pop<pen>(Stack);
  path3 g=vm::pop<path3>(Stack);
  picture * f=vm::pop<picture *>(Stack);
#line 2826 "runtime.in"
  f->append(new drawPath3(g,p));
}

#line 2831 "runtime.in"
// void draw(picture *f, triplearray2 *g, bool straight, penarray *p, real opacity,	  real shininess, real granularity, triple normal, bool lighton,	  penarray *colors);
void gen235(stack *Stack)
{
  penarray * colors=vm::pop<penarray *>(Stack);
  bool lighton=vm::pop<bool>(Stack);
  triple normal=vm::pop<triple>(Stack);
  real granularity=vm::pop<real>(Stack);
  real shininess=vm::pop<real>(Stack);
  real opacity=vm::pop<real>(Stack);
  penarray * p=vm::pop<penarray *>(Stack);
  bool straight=vm::pop<bool>(Stack);
  triplearray2 * g=vm::pop<triplearray2 *>(Stack);
  picture * f=vm::pop<picture *>(Stack);
#line 2834 "runtime.in"
  f->append(new drawSurface(*g,straight,*p,opacity,shininess,granularity,
			    normal,lighton,*colors));
}

#line 2839 "runtime.in"
// triple min3(picture *f);
void gen236(stack *Stack)
{
  picture * f=vm::pop<picture *>(Stack);
#line 2840 "runtime.in"
  {Stack->push<triple>(f->bounds3().Min()); return;}
}

#line 2844 "runtime.in"
// triple max3(picture *f);
void gen237(stack *Stack)
{
  picture * f=vm::pop<picture *>(Stack);
#line 2845 "runtime.in"
  {Stack->push<triple>(f->bounds3().Max()); return;}
}

#line 2849 "runtime.in"
// pair min(picture *f, realarray2 *t);
void gen238(stack *Stack)
{
  realarray2 * t=vm::pop<realarray2 *>(Stack);
  picture * f=vm::pop<picture *>(Stack);
#line 2850 "runtime.in"
  real *T=copyArray2C(t,4);
  pair m=f->bounds(::min,xproject,yproject,T);
  delete[] T;
  {Stack->push<pair>(m); return;}
}

#line 2857 "runtime.in"
// pair max(picture *f, realarray2 *t);
void gen239(stack *Stack)
{
  realarray2 * t=vm::pop<realarray2 *>(Stack);
  picture * f=vm::pop<picture *>(Stack);
#line 2858 "runtime.in"
  real *T=copyArray2C(t,4);
  pair M=f->bounds(::max,xproject,yproject,T);
  delete[] T;
  {Stack->push<pair>(M); return;}
}

#line 2865 "runtime.in"
// pair minratio(picture *f);
void gen240(stack *Stack)
{
  picture * f=vm::pop<picture *>(Stack);
#line 2866 "runtime.in"
  {Stack->push<pair>(f->bounds(::min,xratio,yratio)); return;}
}

#line 2870 "runtime.in"
// pair maxratio(picture *f);
void gen241(stack *Stack)
{
  picture * f=vm::pop<picture *>(Stack);
#line 2871 "runtime.in"
  {Stack->push<pair>(f->bounds(::max,xratio,yratio)); return;}
}

#line 2875 "runtime.in"
// real minbound(realarray *a, real b);
void gen242(stack *Stack)
{
  real b=vm::pop<real>(Stack);
  realarray * a=vm::pop<realarray *>(Stack);
#line 2876 "runtime.in"
  real *A=copyArrayC(a,16);
  b=bound(A,::min,b);
  delete[] A;
  {Stack->push<real>(b); return;}
}

#line 2883 "runtime.in"
// real maxbound(realarray *a, real b);
void gen243(stack *Stack)
{
  real b=vm::pop<real>(Stack);
  realarray * a=vm::pop<realarray *>(Stack);
#line 2884 "runtime.in"
  real *A=copyArrayC(a,16);
  b=bound(A,::max,b);
  delete[] A;
  {Stack->push<real>(b); return;}
}

#line 2891 "runtime.in"
// pair minbound(triplearray *a, realarray2 *t, pair b);
void gen244(stack *Stack)
{
  pair b=vm::pop<pair>(Stack);
  realarray2 * t=vm::pop<realarray2 *>(Stack);
  triplearray * a=vm::pop<triplearray *>(Stack);
#line 2892 "runtime.in"
  triple *A=copyTripleArrayC(a,16);
  real *T=copyArray2C(t,4);
  b=pair(bound(A,::min,xproject,T,b.getx()),
	 bound(A,::min,yproject,T,b.gety()));
  delete[] T;
  delete[] A;
  {Stack->push<pair>(b); return;}
}

#line 2902 "runtime.in"
// pair maxbound(triplearray *a, realarray2 *t, pair b);
void gen245(stack *Stack)
{
  pair b=vm::pop<pair>(Stack);
  realarray2 * t=vm::pop<realarray2 *>(Stack);
  triplearray * a=vm::pop<triplearray *>(Stack);
#line 2903 "runtime.in"
  triple *A=copyTripleArrayC(a,16);
  real *T=copyArray2C(t,4);
  b=pair(bound(A,::max,xproject,T,b.getx()),
	 bound(A,::max,yproject,T,b.gety()));
  delete[] T;
  delete[] A;
  {Stack->push<pair>(b); return;}
}

#line 2913 "runtime.in"
// pair max(path3 g, realarray2 *t);
void gen246(stack *Stack)
{
  realarray2 * t=vm::pop<realarray2 *>(Stack);
  path3 g=vm::pop<path3>(Stack);
#line 2914 "runtime.in"
  real *T=copyArray2C(t,4);
  pair b=g.bounds(::max,xproject,yproject,T);
  delete[] T;
  {Stack->push<pair>(b); return;}
}

#line 2921 "runtime.in"
// pair min(path3 g, realarray2 *t);
void gen247(stack *Stack)
{
  realarray2 * t=vm::pop<realarray2 *>(Stack);
  path3 g=vm::pop<path3>(Stack);
#line 2922 "runtime.in"
  real *T=copyArray2C(t,4);
  pair b=g.bounds(::min,xproject,yproject,T);
  delete[] T;
  {Stack->push<pair>(b); return;}
}

#line 2929 "runtime.in"
// real change2(triplearray2 *a);
void gen248(stack *Stack)
{
  triplearray2 * a=vm::pop<triplearray2 *>(Stack);
#line 2930 "runtime.in"
  size_t n=checkArray(a);
  if(n == 0) {Stack->push<real>(0.0); return;}
  
  vm::array *a0=vm::read<vm::array*>(a,0);
  size_t m=checkArray(a0);
  if(m == 0) {Stack->push<real>(0.0); return;}
  triple a00=vm::read<triple>(a0,0);
  real M=0.0;
    
  for(size_t i=0; i < n; ++i) {
    vm::array *ai=vm::read<vm::array*>(a,i);
    size_t m=checkArray(ai);
    for(size_t j=0; j < m; ++j) {
      real a=(vm::read<triple>(ai,j)-a00).abs2();
      if(a > M) M=a;
    }
  }
  {Stack->push<real>(M); return;}
}

#line 2951 "runtime.in"
// bool is3D(picture *f);
void gen249(stack *Stack)
{
  picture * f=vm::pop<picture *>(Stack);
#line 2952 "runtime.in"
  {Stack->push<bool>(f->have3D()); return;}
}

#line 2956 "runtime.in"
// triple bezier(triple a, triple b, triple c, triple d, real t);
void gen250(stack *Stack)
{
  real t=vm::pop<real>(Stack);
  triple d=vm::pop<triple>(Stack);
  triple c=vm::pop<triple>(Stack);
  triple b=vm::pop<triple>(Stack);
  triple a=vm::pop<triple>(Stack);
#line 2957 "runtime.in"
  real onemt=1-t;
  real onemt2=onemt*onemt;
  {Stack->push<triple>(onemt2*onemt*a+t*(3.0*(onemt2*b+t*onemt*c)+t*t*d)); return;}
}

#line 2963 "runtime.in"
// triple bezierP(triple a, triple b, triple c, triple d, real t);
void gen251(stack *Stack)
{
  real t=vm::pop<real>(Stack);
  triple d=vm::pop<triple>(Stack);
  triple c=vm::pop<triple>(Stack);
  triple b=vm::pop<triple>(Stack);
  triple a=vm::pop<triple>(Stack);
#line 2964 "runtime.in"
  {Stack->push<triple>(3.0*(t*t*(d-a+3.0*(b-c))+t*(2.0*(a+c)-4.0*b)+b-a)); return;}
}

#line 2968 "runtime.in"
// triple bezierPP(triple a, triple b, triple c, triple d, real t);
void gen252(stack *Stack)
{
  real t=vm::pop<real>(Stack);
  triple d=vm::pop<triple>(Stack);
  triple c=vm::pop<triple>(Stack);
  triple b=vm::pop<triple>(Stack);
  triple a=vm::pop<triple>(Stack);
#line 2969 "runtime.in"
  {Stack->push<triple>(6.0*(t*(d-a+3.0*(b-c))+a+c-2.0*b)); return;}
}

#line 2973 "runtime.in"
// triple bezierPPP(triple a, triple b, triple c, triple d);
void gen253(stack *Stack)
{
  triple d=vm::pop<triple>(Stack);
  triple c=vm::pop<triple>(Stack);
  triple b=vm::pop<triple>(Stack);
  triple a=vm::pop<triple>(Stack);
#line 2974 "runtime.in"
  {Stack->push<triple>(6.0*(d-a+3.0*(b-c))); return;}
}


// String operations
#line 2980 "runtime.in"
void emptyString(stack *Stack)
{
#line 2981 "runtime.in"
  {Stack->push<string>(emptystring); return;}
}

#line 2986 "runtime.in"
// Int length(string *s);
void gen255(stack *Stack)
{
  string * s=vm::pop<string *>(Stack);
#line 2987 "runtime.in"
  {Stack->push<Int>((Int) s->length()); return;}
}

#line 2991 "runtime.in"
// Int find(string *s, string t, Int pos=0);
void gen256(stack *Stack)
{
  Int pos=vm::pop<Int>(Stack,0);
  string t=vm::pop<string>(Stack);
  string * s=vm::pop<string *>(Stack);
#line 2992 "runtime.in"
  size_t n=s->find(t,pos);
  {Stack->push<Int>(n == string::npos ? (Int) -1 : (Int) n); return;}
}

#line 2997 "runtime.in"
// Int rfind(string *s, string t, Int pos=-1);
void gen257(stack *Stack)
{
  Int pos=vm::pop<Int>(Stack,-1);
  string t=vm::pop<string>(Stack);
  string * s=vm::pop<string *>(Stack);
#line 2998 "runtime.in"
  size_t n=s->rfind(t,pos);
  {Stack->push<Int>(n == string::npos ? (Int) -1 : (Int) n); return;}
}

#line 3003 "runtime.in"
// string reverse(string s);
void gen258(stack *Stack)
{
  string s=vm::pop<string>(Stack);
#line 3004 "runtime.in"
  reverse(s.begin(),s.end());
  {Stack->push<string>(s); return;}
}

#line 3009 "runtime.in"
// string insert(string s, Int pos, string t);
void gen259(stack *Stack)
{
  string t=vm::pop<string>(Stack);
  Int pos=vm::pop<Int>(Stack);
  string s=vm::pop<string>(Stack);
#line 3010 "runtime.in"
  if ((size_t) pos < s.length())
    {Stack->push<string>(s.insert(pos,t)); return;}
  {Stack->push<string>(s); return;}
}

#line 3016 "runtime.in"
// string substr(string* s, Int pos, Int n=-1);
void gen260(stack *Stack)
{
  Int n=vm::pop<Int>(Stack,-1);
  Int pos=vm::pop<Int>(Stack);
  string* s=vm::pop<string*>(Stack);
#line 3017 "runtime.in"
  if ((size_t) pos < s->length())
    {Stack->push<string>(s->substr(pos,n)); return;}
  {Stack->push<string>(emptystring); return;}
}

#line 3023 "runtime.in"
// string erase(string s, Int pos, Int n);
void gen261(stack *Stack)
{
  Int n=vm::pop<Int>(Stack);
  Int pos=vm::pop<Int>(Stack);
  string s=vm::pop<string>(Stack);
#line 3024 "runtime.in"
  if ((size_t) pos < s.length())
    {Stack->push<string>(s.erase(pos,n)); return;}
  {Stack->push<string>(s); return;} 
}

#line 3030 "runtime.in"
// string downcase(string s);
void gen262(stack *Stack)
{
  string s=vm::pop<string>(Stack);
#line 3031 "runtime.in"
  std::transform(s.begin(),s.end(),s.begin(),tolower);
  {Stack->push<string>(s); return;}
}

#line 3036 "runtime.in"
// string upcase(string s);
void gen263(stack *Stack)
{
  string s=vm::pop<string>(Stack);
#line 3037 "runtime.in"
  std::transform(s.begin(),s.end(),s.begin(),toupper);
  {Stack->push<string>(s); return;}
}

// returns a string constructed by translating all occurrences of the string
// from in an array of string pairs {from,to} to the string to in string s.
#line 3044 "runtime.in"
// string replace(string *S, stringarray2 *translate);
void gen264(stack *Stack)
{
  stringarray2 * translate=vm::pop<stringarray2 *>(Stack);
  string * S=vm::pop<string *>(Stack);
#line 3045 "runtime.in"
  size_t size=checkArray(translate);
  for(size_t i=0; i < size; i++) {
    array *a=read<array*>(translate,i);
    checkArray(a);
  }
  const char *p=S->c_str();
  ostringstream buf;
  while(*p) {
    for(size_t i=0; i < size;) {
      array *a=read<array*>(translate,i);
      string* from=read<string*>(a,0);
      size_t len=from->length();
      if(strncmp(p,from->c_str(),len) != 0) {i++; continue;}
      buf << read<string>(a,1);
      p += len;
      if(*p == 0) {Stack->push<string>(buf.str()); return;}
      i=0;
    }
    buf << *(p++);
  }
  {Stack->push<string>(buf.str()); return;}
}

#line 3069 "runtime.in"
// string format(string *format, Int x);
void gen265(stack *Stack)
{
  Int x=vm::pop<Int>(Stack);
  string * format=vm::pop<string *>(Stack);
#line 3070 "runtime.in"
  const char *f=format->c_str();
  
  checkformat(f,true);
  
  Int size=snprintf(NULL,0,f,x)+1;
  if(size < 1) size=255; // Workaround for non-C99 compliant systems.
  char *buf=new char[size];
  snprintf(buf,size,f,x);
  string s=string(buf);
  delete[] buf;
  {Stack->push<string>(s); return;}
}

#line 3084 "runtime.in"
// string format(string *format, real x, string locale=emptystring);
void gen266(stack *Stack)
{
  string locale=vm::pop<string>(Stack,emptystring);
  real x=vm::pop<real>(Stack);
  string * format=vm::pop<string *>(Stack);
#line 3085 "runtime.in"
  ostringstream out;
  
  checkformat(format->c_str(),false);

  const char *phantom="\\phantom{+}";
  const char *p0=format->c_str();
  
  const char *p=p0;
  const char *start=NULL;
  while (*p != 0) {
    if(*p == '%') {
      p++;
      if(*p != '%') {start=p-1; break;}
    }
    out << *(p++);
  }
  
  if(!start) {Stack->push<string>(out.str()); return;}
  
  // Allow at most 1 argument  
  while (*p != 0) {
    if(*p == '*' || *p == '$') {Stack->push<string>(out.str()); return;}
    if(isupper(*p) || islower(*p)) {p++; break;}
    p++;
  }
  
  const char *tail=p;
  string f=format->substr(start-p0,tail-start);

  const char *oldlocale=NULL;
  if(!locale.empty()) {
    oldlocale=setlocale(LC_ALL,NULL);
    setlocale(LC_ALL,locale.c_str());
  }

  Int size=snprintf(NULL,0,f.c_str(),x)+1;
  if(size < 1) size=255; // Workaround for non-C99 compliant systems.
  char *buf=new char[size];
  snprintf(buf,size,f.c_str(),x);

  if(!locale.empty())
    setlocale(LC_ALL,oldlocale);
  
  bool trailingzero=f.find("#") < string::npos;
  bool plus=f.find("+") < string::npos;
  bool space=f.find(" ") < string::npos;
  
  char *q=buf; // beginning of formatted number

  if(*q == ' ') {
    out << phantom;
    q++;
  }
  
  const char decimal=*(localeconv()->decimal_point);

  // Remove any spurious sign
  if(*q == '-' || *q == '+') {
    p=q+1;
    bool zero=true;
    while(*p != 0) {
      if(!isdigit(*p) && *p != decimal) break;
      if(isdigit(*p) && *p != '0') {zero=false; break;}
      p++;
    }
    if(zero) {
      q++;
      if(plus || space) out << phantom;
    }
  }
  
  const char *r=p=q;
  bool dp=false;
  while(*r != 0 && (isdigit(*r) || *r == decimal || *r == '+' || *r == '-')) {
    if(*r == decimal) dp=true;
    r++;
  }
  if(dp) { // Remove trailing zeros and/or decimal point
    r--;
    unsigned n=0;
    while(r > q && *r == '0') {r--; n++;}
    if(*r == decimal) {r--; n++;}
    while(q <= r) out << *(q++);
    if(!trailingzero) q += n;
  }
  
  bool zero=(r == p && *r == '0') && !trailingzero;
  
  // Translate "E+/E-/e+/e-" exponential notation to TeX
  while(*q != 0) {
    if((*q == 'E' || *q == 'e') && (*(q+1) == '+' || *(q+1) == '-')) {
      if(!zero) out << "\\!\\times\\!10^{";
      bool plus=(*(q+1) == '+');
      q++;
      if(plus) q++;
      if(*q == '-') out << *(q++);
      while(*q == '0' && (zero || isdigit(*(q+1)))) q++;
      while(isdigit(*q)) out << *(q++);
      if(!zero) {
	if(plus) out << phantom;
	out << "}";
      }
      break;
    }
    out << *(q++);
  }
  
  while(*tail != 0) 
    out << *(tail++);
  
  delete[] buf;

  {Stack->push<string>(out.str()); return;}
}

#line 3201 "runtime.in"
// string string(Int x);
void gen267(stack *Stack)
{
  Int x=vm::pop<Int>(Stack);
#line 3202 "runtime.in"
  ostringstream buf;
  buf << x;
  {Stack->push<string>(buf.str()); return;}
}

#line 3208 "runtime.in"
// string string(real x, Int digits=DBL_DIG);
void gen268(stack *Stack)
{
  Int digits=vm::pop<Int>(Stack,DBL_DIG);
  real x=vm::pop<real>(Stack);
#line 3209 "runtime.in"
  ostringstream buf;
  buf.precision(digits);
  buf << x;
  {Stack->push<string>(buf.str()); return;}
}

#line 3216 "runtime.in"
// string time(string format=defaulttimeformat);
void gen269(stack *Stack)
{
  string format=vm::pop<string>(Stack,defaulttimeformat);
#line 3217 "runtime.in"
#ifdef HAVE_STRFTIME
  const time_t bintime=time(NULL);
  if(!strftime(Time,nTime,format.c_str(),localtime(&bintime))) {Stack->push<string>(""); return;}
  {Stack->push<string>(Time); return;}
#else
  {Stack->push<string>(format); return;}
#endif  
}

#line 3227 "runtime.in"
// string time(Int seconds, string format=defaulttimeformat);
void gen270(stack *Stack)
{
  string format=vm::pop<string>(Stack,defaulttimeformat);
  Int seconds=vm::pop<Int>(Stack);
#line 3228 "runtime.in"
#ifdef HAVE_STRFTIME
  const time_t bintime=seconds;
  if(!strftime(Time,nTime,format.c_str(),localtime(&bintime))) {Stack->push<string>(""); return;}
  {Stack->push<string>(Time); return;}
#else
// Avoid unused variable warning messages
  unused(&seconds);
  {Stack->push<string>(format); return;}
#endif
}

#line 3240 "runtime.in"
// Int seconds(string t=emptystring, string format=emptystring);
void gen271(stack *Stack)
{
  string format=vm::pop<string>(Stack,emptystring);
  string t=vm::pop<string>(Stack,emptystring);
#line 3241 "runtime.in"
#if defined(HAVE_STRPTIME)
  const time_t bintime=time(NULL);
  tm tm=*localtime(&bintime);
  if(t != "" && !strptime(t.c_str(),format.c_str(),&tm)) {Stack->push<Int>(-1); return;}
  {Stack->push<Int>((Int) mktime(&tm)); return;}
#else
  {Stack->push<Int>(-1); return;}
#endif  
}

#line 3252 "runtime.in"
// realarray* _cputime();
void gen272(stack *Stack)
{
#line 3253 "runtime.in"
  static const real ticktime=1.0/sysconf(_SC_CLK_TCK);
  struct tms buf;

  ::times(&buf);
  array *t=new array(4);
  (*t)[0] = ((real) buf.tms_utime)*ticktime;
  (*t)[1] = ((real) buf.tms_stime)*ticktime;
  (*t)[2] = ((real) buf.tms_cutime)*ticktime;
  (*t)[3] = ((real) buf.tms_cstime)*ticktime;
  {Stack->push<realarray*>(t); return;}
}


// Math
#line 3268 "runtime.in"
// real ^(real x, Int y);
void gen273(stack *Stack)
{
  Int y=vm::pop<Int>(Stack);
  real x=vm::pop<real>(Stack);
#line 3269 "runtime.in"
  {Stack->push<real>(pow(x,y)); return;}
}

#line 3274 "runtime.in"
// pair ^(pair z, Int y);
void gen274(stack *Stack)
{
  Int y=vm::pop<Int>(Stack);
  pair z=vm::pop<pair>(Stack);
#line 3275 "runtime.in"
  {Stack->push<pair>(pow(z,y)); return;}
}

#line 3279 "runtime.in"
// Int quotient(Int x, Int y);
void gen275(stack *Stack)
{
  Int y=vm::pop<Int>(Stack);
  Int x=vm::pop<Int>(Stack);
#line 3280 "runtime.in" 
  if(y == 0) dividebyzero();
  if(y == -1) {Stack->push<Int>(Negate(x)); return;}
// Implementation-independent definition of integer division: round down
  {Stack->push<Int>((x-portableMod(x,y))/y); return;}
}

#line 3287 "runtime.in"
// Int abs(Int x);
void gen276(stack *Stack)
{
  Int x=vm::pop<Int>(Stack);
#line 3288 "runtime.in" 
  {Stack->push<Int>(Abs(x)); return;}
}

#line 3292 "runtime.in"
// Int sgn(real x);
void gen277(stack *Stack)
{
  real x=vm::pop<real>(Stack);
#line 3293 "runtime.in" 
  {Stack->push<Int>(sgn(x)); return;}
}

#line 3297 "runtime.in"
// Int rand();
void gen278(stack *Stack)
{
#line 3298 "runtime.in" 
  {Stack->push<Int>(rand()); return;}
}

#line 3302 "runtime.in"
// void srand(Int seed);
void gen279(stack *Stack)
{
  Int seed=vm::pop<Int>(Stack);
#line 3303 "runtime.in" 
  srand(intcast(seed));
}

// a random number uniformly distributed in the interval [0,1]
#line 3308 "runtime.in"
// real unitrand();
void gen280(stack *Stack)
{
#line 3309 "runtime.in"                         
  {Stack->push<real>(((real) rand())/RAND_MAX); return;}
}

#line 3313 "runtime.in"
// Int ceil(real x);
void gen281(stack *Stack)
{
  real x=vm::pop<real>(Stack);
#line 3314 "runtime.in" 
  {Stack->push<Int>(Intcast(ceil(x))); return;}
}

#line 3318 "runtime.in"
// Int floor(real x);
void gen282(stack *Stack)
{
  real x=vm::pop<real>(Stack);
#line 3319 "runtime.in" 
  {Stack->push<Int>(Intcast(floor(x))); return;}
}

#line 3323 "runtime.in"
// Int round(real x);
void gen283(stack *Stack)
{
  real x=vm::pop<real>(Stack);
#line 3324 "runtime.in" 
  if(validInt(x)) {Stack->push<Int>(Round(x)); return;}
  integeroverflow(0);
}

#line 3329 "runtime.in"
// Int Ceil(real x);
void gen284(stack *Stack)
{
  real x=vm::pop<real>(Stack);
#line 3330 "runtime.in" 
  {Stack->push<Int>(Ceil(x)); return;}
}

#line 3334 "runtime.in"
// Int Floor(real x);
void gen285(stack *Stack)
{
  real x=vm::pop<real>(Stack);
#line 3335 "runtime.in" 
  {Stack->push<Int>(Floor(x)); return;}
}

#line 3339 "runtime.in"
// Int Round(real x);
void gen286(stack *Stack)
{
  real x=vm::pop<real>(Stack);
#line 3340 "runtime.in" 
  {Stack->push<Int>(Round(Intcap(x))); return;}
}

#line 3344 "runtime.in"
// real fmod(real x, real y);
void gen287(stack *Stack)
{
  real y=vm::pop<real>(Stack);
  real x=vm::pop<real>(Stack);
#line 3345 "runtime.in"
  if (y == 0.0) dividebyzero();
  {Stack->push<real>(fmod(x,y)); return;}
}

#line 3350 "runtime.in"
// real atan2(real y, real x);
void gen288(stack *Stack)
{
  real x=vm::pop<real>(Stack);
  real y=vm::pop<real>(Stack);
#line 3351 "runtime.in" 
  {Stack->push<real>(atan2(y,x)); return;}
}

#line 3355 "runtime.in"
// real hypot(real x, real y);
void gen289(stack *Stack)
{
  real y=vm::pop<real>(Stack);
  real x=vm::pop<real>(Stack);
#line 3356 "runtime.in" 
  {Stack->push<real>(hypot(x,y)); return;}
}

#line 3360 "runtime.in"
// real remainder(real x, real y);
void gen290(stack *Stack)
{
  real y=vm::pop<real>(Stack);
  real x=vm::pop<real>(Stack);
#line 3361 "runtime.in" 
  {Stack->push<real>(remainder(x,y)); return;}
}

#line 3365 "runtime.in"
// real J(Int n, real x);
void gen291(stack *Stack)
{
  real x=vm::pop<real>(Stack);
  Int n=vm::pop<Int>(Stack);
#line 3366 "runtime.in"
  {Stack->push<real>(jn(n,x)); return;}
}

#line 3370 "runtime.in"
// real Y(Int n, real x);
void gen292(stack *Stack)
{
  real x=vm::pop<real>(Stack);
  Int n=vm::pop<Int>(Stack);
#line 3371 "runtime.in"
  {Stack->push<real>(yn(n,x)); return;}
}

#line 3375 "runtime.in"
// real erf(real x);
void gen293(stack *Stack)
{
  real x=vm::pop<real>(Stack);
#line 3376 "runtime.in"
  {Stack->push<real>(erf(x)); return;}
}

#line 3380 "runtime.in"
// real erfc(real x);
void gen294(stack *Stack)
{
  real x=vm::pop<real>(Stack);
#line 3381 "runtime.in"
  {Stack->push<real>(erfc(x)); return;}
}

#line 3385 "runtime.in"
// real gamma(real x);
void gen295(stack *Stack)
{
  real x=vm::pop<real>(Stack);
#line 3386 "runtime.in"
#ifdef HAVE_TGAMMA
  {Stack->push<real>(tgamma(x)); return;}
#else
 real lg = lgamma(x);
 {Stack->push<real>(signgam*exp(lg)); return;}
#endif
}

#line 3395 "runtime.in"
// realarray* quadraticroots(real a, real b, real c);
void gen296(stack *Stack)
{
  real c=vm::pop<real>(Stack);
  real b=vm::pop<real>(Stack);
  real a=vm::pop<real>(Stack);
#line 3396 "runtime.in"
  quadraticroots q(a,b,c);
  array *roots=new array(q.roots);
  if(q.roots >= 1) (*roots)[0]=q.t1;
  if(q.roots == 2) (*roots)[1]=q.t2;
  {Stack->push<realarray*>(roots); return;}
}

#line 3404 "runtime.in"
// pairarray* quadraticroots(explicit pair a, explicit pair b, explicit pair c);
void gen297(stack *Stack)
{
  pair c=vm::pop<pair>(Stack);
  pair b=vm::pop<pair>(Stack);
  pair a=vm::pop<pair>(Stack);
#line 3405 "runtime.in"
  Quadraticroots q(a,b,c);
  array *roots=new array(q.roots);
  if(q.roots >= 1) (*roots)[0]=q.z1;
  if(q.roots == 2) (*roots)[1]=q.z2;
  {Stack->push<pairarray*>(roots); return;}
}

#line 3413 "runtime.in"
// realarray* cubicroots(real a, real b, real c, real d);
void gen298(stack *Stack)
{
  real d=vm::pop<real>(Stack);
  real c=vm::pop<real>(Stack);
  real b=vm::pop<real>(Stack);
  real a=vm::pop<real>(Stack);
#line 3414 "runtime.in"
  cubicroots q(a,b,c,d);
  array *roots=new array(q.roots);
  if(q.roots >= 1) (*roots)[0]=q.t1;
  if(q.roots >= 2) (*roots)[1]=q.t2;
  if(q.roots == 3) (*roots)[2]=q.t3;
  {Stack->push<realarray*>(roots); return;}
}

  
// Transforms
#line 3425 "runtime.in"
// bool ==(transform a, transform b);
void gen299(stack *Stack)
{
  transform b=vm::pop<transform>(Stack);
  transform a=vm::pop<transform>(Stack);
#line 3426 "runtime.in"
  {Stack->push<bool>(a == b); return;}
}

#line 3431 "runtime.in"
// bool !=(transform a, transform b);
void gen300(stack *Stack)
{
  transform b=vm::pop<transform>(Stack);
  transform a=vm::pop<transform>(Stack);
#line 3432 "runtime.in"
  {Stack->push<bool>(a != b); return;}
}

#line 3436 "runtime.in"
// transform +(transform a, transform b);
void gen301(stack *Stack)
{
  transform b=vm::pop<transform>(Stack);
  transform a=vm::pop<transform>(Stack);
#line 3437 "runtime.in"
  {Stack->push<transform>(a+b); return;}
}

#line 3441 "runtime.in"
// transform *(transform a, transform b);
void gen302(stack *Stack)
{
  transform b=vm::pop<transform>(Stack);
  transform a=vm::pop<transform>(Stack);
#line 3442 "runtime.in"
  {Stack->push<transform>(a*b); return;}
}

#line 3446 "runtime.in"
// pair *(transform t, pair z);
void gen303(stack *Stack)
{
  pair z=vm::pop<pair>(Stack);
  transform t=vm::pop<transform>(Stack);
#line 3447 "runtime.in"
  {Stack->push<pair>(t*z); return;}
}

#line 3451 "runtime.in"
// path *(transform t, path g);
void gen304(stack *Stack)
{
  path g=vm::pop<path>(Stack);
  transform t=vm::pop<transform>(Stack);
#line 3452 "runtime.in"
  {Stack->push<path>(transformed(t,g)); return;}
}

#line 3456 "runtime.in"
// pen *(transform t, pen p);
void gen305(stack *Stack)
{
  pen p=vm::pop<pen>(Stack);
  transform t=vm::pop<transform>(Stack);
#line 3457 "runtime.in"
  {Stack->push<pen>(transformed(t,p)); return;}
}

#line 3461 "runtime.in"
// picture* *(transform t, picture *f);
void gen306(stack *Stack)
{
  picture * f=vm::pop<picture *>(Stack);
  transform t=vm::pop<transform>(Stack);
#line 3462 "runtime.in"
  {Stack->push<picture*>(transformed(t,f)); return;}
}

#line 3466 "runtime.in"
// picture* *(realarray2 *t, picture *f);
void gen307(stack *Stack)
{
  picture * f=vm::pop<picture *>(Stack);
  realarray2 * t=vm::pop<realarray2 *>(Stack);
#line 3467 "runtime.in"
  {Stack->push<picture*>(transformed(*t,f)); return;}
}

#line 3471 "runtime.in"
// transform ^(transform t, Int n);
void gen308(stack *Stack)
{
  Int n=vm::pop<Int>(Stack);
  transform t=vm::pop<transform>(Stack);
#line 3472 "runtime.in"
  transform T;
  if(n < 0) {
    n=-n;
    t=inverse(t);
  }
  for(Int i=0; i < n; i++) T=T*t;
  {Stack->push<transform>(T); return;}
}

#line 3482 "runtime.in"
void transformXPart(stack *Stack)
{
  transform t=vm::pop<transform>(Stack);
#line 3483 "runtime.in"
  {Stack->push<real>(t.getx()); return;}
}

#line 3487 "runtime.in"
void transformYPart(stack *Stack)
{
  transform t=vm::pop<transform>(Stack);
#line 3488 "runtime.in"
  {Stack->push<real>(t.gety()); return;}
}

#line 3492 "runtime.in"
void transformXXPart(stack *Stack)
{
  transform t=vm::pop<transform>(Stack);
#line 3493 "runtime.in"
  {Stack->push<real>(t.getxx()); return;}
}

#line 3497 "runtime.in"
void transformXYPart(stack *Stack)
{
  transform t=vm::pop<transform>(Stack);
#line 3498 "runtime.in"
  {Stack->push<real>(t.getxy()); return;}
}

#line 3502 "runtime.in"
void transformYXPart(stack *Stack)
{
  transform t=vm::pop<transform>(Stack);
#line 3503 "runtime.in"
  {Stack->push<real>(t.getyx()); return;}
}

#line 3507 "runtime.in"
void transformYYPart(stack *Stack)
{
  transform t=vm::pop<transform>(Stack);
#line 3508 "runtime.in"
  {Stack->push<real>(t.getyy()); return;}
}

#line 3512 "runtime.in"
void real6ToTransform(stack *Stack)
{
  real yy=vm::pop<real>(Stack);
  real yx=vm::pop<real>(Stack);
  real xy=vm::pop<real>(Stack);
  real xx=vm::pop<real>(Stack);
  real y=vm::pop<real>(Stack);
  real x=vm::pop<real>(Stack);
#line 3514 "runtime.in"
  {Stack->push<transform>(transform(x,y,xx,xy,yx,yy)); return;}
}

#line 3518 "runtime.in"
// transform shift(transform t);
void gen316(stack *Stack)
{
  transform t=vm::pop<transform>(Stack);
#line 3519 "runtime.in"
  {Stack->push<transform>(transform(t.getx(),t.gety(),0,0,0,0)); return;}
}

#line 3523 "runtime.in"
// transform shiftless(transform t);
void gen317(stack *Stack)
{
  transform t=vm::pop<transform>(Stack);
#line 3524 "runtime.in"
  {Stack->push<transform>(transform(0,0,t.getxx(),t.getxy(),t.getyx(),t.getyy())); return;}
}

#line 3528 "runtime.in"
// transform identity();
void transformIdentity(stack *Stack)
{
#line 3529 "runtime.in"
  {Stack->push<transform>(identity); return;}
}

#line 3533 "runtime.in"
// transform inverse(transform t);
void gen319(stack *Stack)
{
  transform t=vm::pop<transform>(Stack);
#line 3534 "runtime.in"
  {Stack->push<transform>(inverse(t)); return;}
}

#line 3538 "runtime.in"
// transform shift(pair z);
void gen320(stack *Stack)
{
  pair z=vm::pop<pair>(Stack);
#line 3539 "runtime.in"
  {Stack->push<transform>(shift(z)); return;}
}

#line 3543 "runtime.in"
// transform shift(real x, real y);
void gen321(stack *Stack)
{
  real y=vm::pop<real>(Stack);
  real x=vm::pop<real>(Stack);
#line 3544 "runtime.in"
  {Stack->push<transform>(shift(pair(x,y))); return;}
}

#line 3548 "runtime.in"
// transform xscale(real x);
void gen322(stack *Stack)
{
  real x=vm::pop<real>(Stack);
#line 3549 "runtime.in"
  {Stack->push<transform>(xscale(x)); return;}
}

#line 3553 "runtime.in"
// transform yscale(real y);
void gen323(stack *Stack)
{
  real y=vm::pop<real>(Stack);
#line 3554 "runtime.in"
  {Stack->push<transform>(yscale(y)); return;}
}

#line 3558 "runtime.in"
// transform scale(real x);
void gen324(stack *Stack)
{
  real x=vm::pop<real>(Stack);
#line 3559 "runtime.in"
  {Stack->push<transform>(scale(x)); return;}
}

#line 3563 "runtime.in"
// transform scale(real x, real y);
void gen325(stack *Stack)
{
  real y=vm::pop<real>(Stack);
  real x=vm::pop<real>(Stack);
#line 3564 "runtime.in"
  {Stack->push<transform>(xscale(x)*yscale(y)); return;}
}

#line 3568 "runtime.in"
// transform slant(real s);
void gen326(stack *Stack)
{
  real s=vm::pop<real>(Stack);
#line 3569 "runtime.in"
  {Stack->push<transform>(slant(s)); return;}
}

#line 3573 "runtime.in"
// transform rotate(real angle, pair z=0);
void gen327(stack *Stack)
{
  pair z=vm::pop<pair>(Stack,0);
  real angle=vm::pop<real>(Stack);
#line 3574 "runtime.in"
  {Stack->push<transform>(rotatearound(z,radians(angle))); return;}
}

#line 3578 "runtime.in"
// transform reflect(pair a, pair b);
void gen328(stack *Stack)
{
  pair b=vm::pop<pair>(Stack);
  pair a=vm::pop<pair>(Stack);
#line 3579 "runtime.in"
  {Stack->push<transform>(reflectabout(a,b)); return;}
}


// Pair operations
#line 3585 "runtime.in"
void pairZero(stack *Stack)
{
#line 3586 "runtime.in"
  {Stack->push<pair>(zero); return;}
}

#line 3591 "runtime.in"
void realRealToPair(stack *Stack)
{
  real y=vm::pop<real>(Stack);
  real x=vm::pop<real>(Stack);
#line 3592 "runtime.in"
  {Stack->push<pair>(pair(x,y)); return;}
}

#line 3596 "runtime.in"
void pairNegate(stack *Stack)
{
  pair z=vm::pop<pair>(Stack);
#line 3597 "runtime.in"
  {Stack->push<pair>(-z); return;}
}

#line 3601 "runtime.in"
// real xpart(pair z);
void pairXPart(stack *Stack)
{
  pair z=vm::pop<pair>(Stack);
#line 3602 "runtime.in"
  {Stack->push<real>(z.getx()); return;}
}

#line 3606 "runtime.in"
// real ypart(pair z);
void pairYPart(stack *Stack)
{
  pair z=vm::pop<pair>(Stack);
#line 3607 "runtime.in"
  {Stack->push<real>(z.gety()); return;}
}

#line 3611 "runtime.in"
// real length(pair z);
void gen334(stack *Stack)
{
  pair z=vm::pop<pair>(Stack);
#line 3612 "runtime.in"
  {Stack->push<real>(z.length()); return;}
}

#line 3616 "runtime.in"
// real abs(pair z);
void gen335(stack *Stack)
{
  pair z=vm::pop<pair>(Stack);
#line 3617 "runtime.in"
  {Stack->push<real>(z.length()); return;}
}

#line 3621 "runtime.in"
// pair sqrt(explicit pair z);
void gen336(stack *Stack)
{
  pair z=vm::pop<pair>(Stack);
#line 3622 "runtime.in"
  {Stack->push<pair>(Sqrt(z)); return;}
}

// Return the angle of z in radians.
#line 3627 "runtime.in"
// real angle(pair z, bool warn=true);
void gen337(stack *Stack)
{
  bool warn=vm::pop<bool>(Stack,true);
  pair z=vm::pop<pair>(Stack);
#line 3628 "runtime.in"
  if(!warn && z.getx() == 0.0 && z.gety() == 0.0) {Stack->push<real>(0.0); return;}
  {Stack->push<real>(z.angle()); return;}
}

// Return the angle of z in degrees in the interval [0,360).
#line 3634 "runtime.in"
// real degrees(pair z, bool warn=true);
void gen338(stack *Stack)
{
  bool warn=vm::pop<bool>(Stack,true);
  pair z=vm::pop<pair>(Stack);
#line 3635 "runtime.in"
  if(!warn && z.getx() == 0.0 && z.gety() == 0.0) {Stack->push<real>(0.0); return;}
  {Stack->push<real>(principalBranch(degrees(z.angle()))); return;}
}

// Convert degrees to radians.
#line 3641 "runtime.in"
// real radians(real degrees);
void gen339(stack *Stack)
{
  real degrees=vm::pop<real>(Stack);
#line 3642 "runtime.in"
  {Stack->push<real>(radians(degrees)); return;}
}

// Convert radians to degrees.
#line 3647 "runtime.in"
// real degrees(real radians);
void gen340(stack *Stack)
{
  real radians=vm::pop<real>(Stack);
#line 3648 "runtime.in"
  {Stack->push<real>(degrees(radians)); return;}
}

// Convert radians to degrees in [0,360).
#line 3653 "runtime.in"
// real Degrees(real radians);
void gen341(stack *Stack)
{
  real radians=vm::pop<real>(Stack);
#line 3654 "runtime.in"
  {Stack->push<real>(principalBranch(degrees(radians))); return;}
}

#line 3658 "runtime.in"
// real Sin(real deg);
void gen342(stack *Stack)
{
  real deg=vm::pop<real>(Stack);
#line 3659 "runtime.in"
  {Stack->push<real>(sin(radians(deg))); return;}
}

#line 3663 "runtime.in"
// real Cos(real deg);
void gen343(stack *Stack)
{
  real deg=vm::pop<real>(Stack);
#line 3664 "runtime.in"
  {Stack->push<real>(cos(radians(deg))); return;}
}

#line 3668 "runtime.in"
// real Tan(real deg);
void gen344(stack *Stack)
{
  real deg=vm::pop<real>(Stack);
#line 3669 "runtime.in"
  {Stack->push<real>(tan(radians(deg))); return;}
}

#line 3673 "runtime.in"
// real aSin(real x);
void gen345(stack *Stack)
{
  real x=vm::pop<real>(Stack);
#line 3674 "runtime.in"
  {Stack->push<real>(degrees(asin(x))); return;}
}

#line 3678 "runtime.in"
// real aCos(real x);
void gen346(stack *Stack)
{
  real x=vm::pop<real>(Stack);
#line 3679 "runtime.in"
  {Stack->push<real>(degrees(acos(x))); return;}
}

#line 3683 "runtime.in"
// real aTan(real x);
void gen347(stack *Stack)
{
  real x=vm::pop<real>(Stack);
#line 3684 "runtime.in"
  {Stack->push<real>(degrees(atan(x))); return;}
}

#line 3688 "runtime.in"
// pair unit(pair z);
void gen348(stack *Stack)
{
  pair z=vm::pop<pair>(Stack);
#line 3689 "runtime.in"
  {Stack->push<pair>(unit(z)); return;}
}

#line 3693 "runtime.in"
// pair dir(real degrees);
void gen349(stack *Stack)
{
  real degrees=vm::pop<real>(Stack);
#line 3694 "runtime.in"
  {Stack->push<pair>(expi(radians(degrees))); return;}
}

#line 3698 "runtime.in"
// pair dir(explicit pair z);
void gen350(stack *Stack)
{
  pair z=vm::pop<pair>(Stack);
#line 3699 "runtime.in"
  {Stack->push<pair>(unit(z)); return;}
}

#line 3703 "runtime.in"
// pair expi(real angle);
void gen351(stack *Stack)
{
  real angle=vm::pop<real>(Stack);
#line 3704 "runtime.in"
  {Stack->push<pair>(expi(angle)); return;}
}

#line 3708 "runtime.in"
// pair exp(explicit pair z);
void gen352(stack *Stack)
{
  pair z=vm::pop<pair>(Stack);
#line 3709 "runtime.in" 
  {Stack->push<pair>(exp(z.getx())*expi(z.gety())); return;}
}

#line 3713 "runtime.in"
// pair log(explicit pair z);
void gen353(stack *Stack)
{
  pair z=vm::pop<pair>(Stack);
#line 3714 "runtime.in" 
  {Stack->push<pair>(pair(log(z.length()),z.angle())); return;}
}

#line 3718 "runtime.in"
// pair sin(explicit pair z);
void gen354(stack *Stack)
{
  pair z=vm::pop<pair>(Stack);
#line 3719 "runtime.in" 
  {Stack->push<pair>(pair(sin(z.getx())*cosh(z.gety()),cos(z.getx())*sinh(z.gety()))); return;} 
}

#line 3723 "runtime.in"
// pair cos(explicit pair z);
void gen355(stack *Stack)
{
  pair z=vm::pop<pair>(Stack);
#line 3724 "runtime.in" 
  {Stack->push<pair>(pair(cos(z.getx())*cosh(z.gety()),-sin(z.getx())*sinh(z.gety()))); return;} 
}

#line 3728 "runtime.in"
// pair conj(pair z);
void gen356(stack *Stack)
{
  pair z=vm::pop<pair>(Stack);
#line 3729 "runtime.in"
  {Stack->push<pair>(conj(z)); return;}
}

#line 3733 "runtime.in"
// pair realmult(pair z, pair w);
void gen357(stack *Stack)
{
  pair w=vm::pop<pair>(Stack);
  pair z=vm::pop<pair>(Stack);
#line 3734 "runtime.in"
  {Stack->push<pair>(pair (z.getx()*w.getx(),z.gety()*w.gety())); return;}
}

#line 3738 "runtime.in"
// triple realmult(triple u, triple v);
void gen358(stack *Stack)
{
  triple v=vm::pop<triple>(Stack);
  triple u=vm::pop<triple>(Stack);
#line 3739 "runtime.in"
  {Stack->push<triple>(triple (u.getx()*v.getx(),u.gety()*v.gety(),u.getz()*v.getz())); return;}
}

// To avoid confusion, a dot product requires explicit pair arguments.
#line 3744 "runtime.in"
// real dot(explicit pair z, explicit pair w);
void gen359(stack *Stack)
{
  pair w=vm::pop<pair>(Stack);
  pair z=vm::pop<pair>(Stack);
#line 3745 "runtime.in"
  {Stack->push<real>(dot(z,w)); return;}
}


// Triple operations
#line 3751 "runtime.in"
void tripleZero(stack *Stack)
{
#line 3752 "runtime.in"
  static triple zero;
  {Stack->push<triple>(zero); return;}
}

#line 3758 "runtime.in"
void realRealRealToTriple(stack *Stack)
{
  real z=vm::pop<real>(Stack);
  real y=vm::pop<real>(Stack);
  real x=vm::pop<real>(Stack);
#line 3759 "runtime.in"
  {Stack->push<triple>(triple(x,y,z)); return;}
}

#line 3763 "runtime.in"
// real xpart(triple v);
void tripleXPart(stack *Stack)
{
  triple v=vm::pop<triple>(Stack);
#line 3764 "runtime.in"
  {Stack->push<real>(v.getx()); return;}
}

#line 3768 "runtime.in"
// real ypart(triple v);
void tripleYPart(stack *Stack)
{
  triple v=vm::pop<triple>(Stack);
#line 3769 "runtime.in"
  {Stack->push<real>(v.gety()); return;}
}

#line 3773 "runtime.in"
// real zpart(triple v);
void tripleZPart(stack *Stack)
{
  triple v=vm::pop<triple>(Stack);
#line 3774 "runtime.in"
  {Stack->push<real>(v.getz()); return;}
}

#line 3778 "runtime.in"
// triple *(real x, triple v);
void gen365(stack *Stack)
{
  triple v=vm::pop<triple>(Stack);
  real x=vm::pop<real>(Stack);
#line 3779 "runtime.in"
  {Stack->push<triple>(x*v); return;}
}

#line 3783 "runtime.in"
// triple *(triple v, real x);
void gen366(stack *Stack)
{
  real x=vm::pop<real>(Stack);
  triple v=vm::pop<triple>(Stack);
#line 3784 "runtime.in"
  {Stack->push<triple>(v*x); return;}
}

#line 3788 "runtime.in"
// triple /(triple v, real x);
void gen367(stack *Stack)
{
  real x=vm::pop<real>(Stack);
  triple v=vm::pop<triple>(Stack);
#line 3789 "runtime.in"
  {Stack->push<triple>(v/x); return;}
}

#line 3793 "runtime.in"
// real length(triple v);
void gen368(stack *Stack)
{
  triple v=vm::pop<triple>(Stack);
#line 3794 "runtime.in"
  {Stack->push<real>(v.length()); return;}
}

#line 3798 "runtime.in"
// real abs(triple v);
void gen369(stack *Stack)
{
  triple v=vm::pop<triple>(Stack);
#line 3799 "runtime.in"
  {Stack->push<real>(v.length()); return;}
}

#line 3803 "runtime.in"
// real polar(triple v);
void gen370(stack *Stack)
{
  triple v=vm::pop<triple>(Stack);
#line 3804 "runtime.in"
  {Stack->push<real>(v.polar()); return;}
}

#line 3808 "runtime.in"
// real azimuth(triple v);
void gen371(stack *Stack)
{
  triple v=vm::pop<triple>(Stack);
#line 3809 "runtime.in"
  {Stack->push<real>(v.azimuth()); return;}
}

#line 3813 "runtime.in"
// real colatitude(triple v);
void gen372(stack *Stack)
{
  triple v=vm::pop<triple>(Stack);
#line 3814 "runtime.in"
  {Stack->push<real>(degrees(v.polar())); return;}
}

#line 3818 "runtime.in"
// real latitude(triple v);
void gen373(stack *Stack)
{
  triple v=vm::pop<triple>(Stack);
#line 3819 "runtime.in"
  {Stack->push<real>(90.0-degrees(v.polar())); return;}
}

// Return the longitude of v in [0,360).
#line 3824 "runtime.in"
// real longitude(triple v, bool warn=true);
void gen374(stack *Stack)
{
  bool warn=vm::pop<bool>(Stack,true);
  triple v=vm::pop<triple>(Stack);
#line 3825 "runtime.in"
  if(!warn && v.getx() == 0.0 && v.gety() == 0.0) {Stack->push<real>(0.0); return;}
  {Stack->push<real>(principalBranch(degrees(v.azimuth()))); return;}
}

#line 3830 "runtime.in"
// triple unit(triple v);
void gen375(stack *Stack)
{
  triple v=vm::pop<triple>(Stack);
#line 3831 "runtime.in"
  {Stack->push<triple>(unit(v)); return;}
}

#line 3835 "runtime.in"
// real dot(triple u, triple v);
void gen376(stack *Stack)
{
  triple v=vm::pop<triple>(Stack);
  triple u=vm::pop<triple>(Stack);
#line 3836 "runtime.in"
  {Stack->push<real>(dot(u,v)); return;}
}

#line 3840 "runtime.in"
// triple cross(triple u, triple v);
void gen377(stack *Stack)
{
  triple v=vm::pop<triple>(Stack);
  triple u=vm::pop<triple>(Stack);
#line 3841 "runtime.in"
  {Stack->push<triple>(cross(u,v)); return;}
}

#line 3845 "runtime.in"
// triple expi(real polar, real azimuth);
void gen378(stack *Stack)
{
  real azimuth=vm::pop<real>(Stack);
  real polar=vm::pop<real>(Stack);
#line 3846 "runtime.in"
  {Stack->push<triple>(expi(polar,azimuth)); return;}
}

#line 3850 "runtime.in"
// triple dir(real colatitude, real longitude);
void gen379(stack *Stack)
{
  real longitude=vm::pop<real>(Stack);
  real colatitude=vm::pop<real>(Stack);
#line 3851 "runtime.in"
  {Stack->push<triple>(expi(radians(colatitude),radians(longitude))); return;}
}


// System routines
#line 3857 "runtime.in"
// string VERSION();
void gen380(stack *Stack)
{
#line 3858 "runtime.in"
  {Stack->push<string>(string(VERSION)+string(SVN_REVISION)); return;}
}

#line 3863 "runtime.in"
// void atupdate(callable *f);
void gen381(stack *Stack)
{
  callable * f=vm::pop<callable *>(Stack);
#line 3864 "runtime.in"
  processData().atUpdateFunction=f;
}

#line 3868 "runtime.in"
// callable* atupdate();
void gen382(stack *Stack)
{
#line 3869 "runtime.in"
  {Stack->push<callable*>(processData().atUpdateFunction); return;}
}

#line 3873 "runtime.in"
// void atexit(callable *f);
void gen383(stack *Stack)
{
  callable * f=vm::pop<callable *>(Stack);
#line 3874 "runtime.in"
  processData().atExitFunction=f;
}

#line 3878 "runtime.in"
// callable* atexit();
void gen384(stack *Stack)
{
#line 3879 "runtime.in"
  {Stack->push<callable*>(processData().atExitFunction); return;}
}

#line 3883 "runtime.in"
// void atbreakpoint(callableBp *f);
void gen385(stack *Stack)
{
  callableBp * f=vm::pop<callableBp *>(Stack);
#line 3884 "runtime.in"
  processData().atBreakpointFunction=f;
}

#line 3888 "runtime.in"
// void breakpoint(runnable *s=NULL);
void gen386(stack *Stack)
{
  runnable * s=vm::pop<runnable *>(Stack,NULL);
#line 3889 "runtime.in"
  breakpoint(Stack,s);
}

#line 3893 "runtime.in"
// string locatefile(string file);
void gen387(stack *Stack)
{
  string file=vm::pop<string>(Stack);
#line 3894 "runtime.in"
  {Stack->push<string>(locateFile(file)); return;}
}

#line 3898 "runtime.in"
// void stop(string file, Int line, runnable *s=NULL);
void gen388(stack *Stack)
{
  runnable * s=vm::pop<runnable *>(Stack,NULL);
  Int line=vm::pop<Int>(Stack);
  string file=vm::pop<string>(Stack);
#line 3899 "runtime.in"
  file=locateFile(file);
  clear(file,line);
  cout << "setting breakpoint at " << file << ": " << line << endl;
  bplist.push_back(bpinfo(file,line,s));
}

#line 3906 "runtime.in"
// void breakpoints();
void gen389(stack *)
{
#line 3907 "runtime.in"
  for(mem::list<bpinfo>::iterator p=bplist.begin(); p != bplist.end(); ++p)
    cout << p->f.name() << ": " << p->f.line() << endl;
}

#line 3912 "runtime.in"
// void clear(string file, Int line);
void gen390(stack *Stack)
{
  Int line=vm::pop<Int>(Stack);
  string file=vm::pop<string>(Stack);
#line 3913 "runtime.in"
  file=locateFile(file);
  clear(file,line,true);
}

#line 3918 "runtime.in"
// void clear();
void gen391(stack *)
{
#line 3919 "runtime.in"
  bplist.clear();
}

// Strip directory from string
#line 3924 "runtime.in"
// string stripdirectory(string *s);
void gen392(stack *Stack)
{
  string * s=vm::pop<string *>(Stack);
#line 3925 "runtime.in"
  {Stack->push<string>(stripDir(*s)); return;}
}

// Strip file extension from string
#line 3930 "runtime.in"
// string stripextension(string *s);
void gen393(stack *Stack)
{
  string * s=vm::pop<string *>(Stack);
#line 3931 "runtime.in"
 {Stack->push<string>(stripExt(*s)); return;}
}

// Call ImageMagick convert.
#line 3936 "runtime.in"
// Int convert(string args=emptystring, string file=emptystring,	    string format=emptystring);
void gen394(stack *Stack)
{
  string format=vm::pop<string>(Stack,emptystring);
  string file=vm::pop<string>(Stack,emptystring);
  string args=vm::pop<string>(Stack,emptystring);
#line 3938 "runtime.in"
  ostringstream cmd;
  
  string name=convertname(file,format);
  cmd << "'" << getSetting<string>("convert") << "' " << args
      << " '" << name << "'";
  Int ret=System(cmd,2,true,"convert","your ImageMagick convert utility");
  
  if(ret == 0 && verbose > 0)
    cout << "Wrote " << ((file.empty()) ? name : file) << endl;
  
  {Stack->push<Int>(ret); return;}
}

// Call ImageMagick animate.
#line 3953 "runtime.in"
// Int animate(string args=emptystring, string file=emptystring,	    string format=emptystring);
void gen395(stack *Stack)
{
  string format=vm::pop<string>(Stack,emptystring);
  string file=vm::pop<string>(Stack,emptystring);
  string args=vm::pop<string>(Stack,emptystring);
#line 3955 "runtime.in"
  string name=convertname(file,format,false);
  if(view()) {
    ostringstream cmd;
    cmd << "'" << getSetting<string>("animate") << "' " << args
	<< " '" << name << "'";
    {Stack->push<Int>(System(cmd,0,false,"animate","your animated GIF viewer")); return;}
  }
  
  {Stack->push<Int>(0); return;}
}

// Delete file named s.
#line 3968 "runtime.in"
// Int delete(string *s);
void gen396(stack *Stack)
{
  string * s=vm::pop<string *>(Stack);
#line 3969 "runtime.in"
  checkLocal(*s);
  Int rc=unlink(s->c_str());
  if(rc == 0 && verbose > 0) 
    cout << "Deleted " << *s << endl;
  {Stack->push<Int>(rc); return;}
}

// Rename file "from" to file "to".
#line 3978 "runtime.in"
// Int rename(string *from, string *to);
void gen397(stack *Stack)
{
  string * to=vm::pop<string *>(Stack);
  string * from=vm::pop<string *>(Stack);
#line 3979 "runtime.in"
  checkLocal(*from);
  checkLocal(*to);
  Int rc=rename(from->c_str(),to->c_str());
  if(rc == 0 && verbose > 0) 
    cout << "Renamed " << *from << " to " << *to << endl;
  {Stack->push<Int>(rc); return;}
}


// Array operations

// Create an empty array.
#line 3992 "runtime.in"
void emptyArray(stack *Stack)
{
#line 3993 "runtime.in"
  {Stack->push<array*>(new array(0)); return;}
}

// Create a new array (technically a vector).
// This array will be multidimensional.  First the number of dimensions
// is popped off the stack, followed by each dimension in reverse order.
// The array itself is technically a one dimensional array of one
// dimension arrays and so on.
#line 4002 "runtime.in"
void newDeepArray(stack *Stack)
{
  Int depth=vm::pop<Int>(Stack);
#line 4003 "runtime.in"
  assert(depth > 0);

  Int *dims = new Int[depth];

  for (Int index = depth-1; index >= 0; index--) {
    Int i=pop<Int>(Stack);
    if(i < 0) error("cannot create a negative length array");
    dims[index]=i;
  }

  array *a=deepArray(depth, dims);
  delete[] dims;
  {Stack->push<array*>(a); return;}
}

// Creates an array with elements already specified.  First, the number
// of elements is popped off the stack, followed by each element in
// reverse order.
#line 4022 "runtime.in"
void newInitializedArray(stack *Stack)
{
  Int n=vm::pop<Int>(Stack);
#line 4023 "runtime.in"
  assert(n >= 0);

  array *a = new array(n);

  for (Int index = n-1; index >= 0; index--)
    (*a)[index] = pop(Stack);

  {Stack->push<array*>(a); return;}
}

// Similar to newInitializedArray, but after the n elements, append another
// array to it.
#line 4036 "runtime.in"
void newAppendedArray(stack *Stack)
{
  Int n=vm::pop<Int>(Stack);
  array* tail=vm::pop<array*>(Stack);
#line 4037 "runtime.in"
  assert(n >= 0);

  array *a = new array(n);

  for (Int index = n-1; index >= 0; index--)
    (*a)[index] = pop(Stack);
  
  copy(tail->begin(), tail->end(), back_inserter(*a));

  {Stack->push<array*>(a); return;}
}

// The function T[] array(int n, T value, int depth=0) produces a array of n
// copies of x, where each copy is copied up to depth.
#line 4052 "runtime.in"
void newDuplicateArray(stack *Stack)
{
  Int depth=vm::pop<Int>(Stack,Int_MAX);
  item value=vm::pop(Stack);
  Int n=vm::pop<Int>(Stack);
#line 4053 "runtime.in"
  if(n < 0) error("cannot create a negative length array");
  if(depth < 0) error("cannot copy to a negative depth");

  {Stack->push<array*>(new array(n, value, depth)); return;}
}

// Read an element from an array. Checks for initialization & bounds.
#line 4061 "runtime.in"
void arrayRead(stack *Stack)
{
  Int n=vm::pop<Int>(Stack);
  array * a=vm::pop<array *>(Stack);
#line 4062 "runtime.in"
  item& i=arrayRead(a,n);
  if (i.empty()) {
    ostringstream buf;
    buf << "read uninitialized value from array at index " << n;
    error(buf);
  }
  {Stack->push(i); return;}
}

// Slice a substring from an array.
#line 4073 "runtime.in"
void arraySliceRead(stack *Stack)
{
  Int right=vm::pop<Int>(Stack);
  Int left=vm::pop<Int>(Stack);
  array * a=vm::pop<array *>(Stack);
#line 4074 "runtime.in"
  checkArray(a);
  {Stack->push(a->slice(left, right)); return;}
}

// Slice a substring from an array.  This implements the cases a[i:] and a[:]
// where the endpoint is not given, and assumed to be the length of the array.
#line 4081 "runtime.in"
void arraySliceReadToEnd(stack *Stack)
{
  Int left=vm::pop<Int>(Stack);
  array * a=vm::pop<array *>(Stack);
#line 4082 "runtime.in"
  size_t len=checkArray(a);
  {Stack->push(a->slice(left, (Int)len)); return;}
}

// Read an element from an array of arrays. Check bounds and initialize
// as necessary.
#line 4089 "runtime.in"
void arrayArrayRead(stack *Stack)
{
  Int n=vm::pop<Int>(Stack);
  array * a=vm::pop<array *>(Stack);
#line 4090 "runtime.in"
  item& i=arrayRead(a,n);
  if (i.empty()) i=new array(0);
  {Stack->push(i); return;}
}

// Write an element to an array.  Increase size if necessary.
#line 4097 "runtime.in"
void arrayWrite(stack *Stack)
{
  Int n=vm::pop<Int>(Stack);
  array * a=vm::pop<array *>(Stack);
  item value=vm::pop(Stack);
#line 4098 "runtime.in"
  size_t len=checkArray(a);
  bool cyclic=a->cyclic();
  if(cyclic && len > 0) n=imod(n,len);
  else {
    if(cyclic) outOfBounds("writing cyclic",len,n);
    if(n < 0) outOfBounds("writing",len,n);
    if(len <= (size_t) n)
      a->resize(n+1);
  }
  (*a)[n] = value;
  {Stack->push(value); return;}
}

#line 4112 "runtime.in"
void arraySliceWrite(stack *Stack)
{
  Int right=vm::pop<Int>(Stack);
  Int left=vm::pop<Int>(Stack);
  array * dest=vm::pop<array *>(Stack);
  array * src=vm::pop<array *>(Stack);
#line 4113 "runtime.in"
  checkArray(src);
  checkArray(dest);
  dest->setSlice(left, right, src);
  {Stack->push<array*>(src); return;}
}

#line 4120 "runtime.in"
void arraySliceWriteToEnd(stack *Stack)
{
  Int left=vm::pop<Int>(Stack);
  array * dest=vm::pop<array *>(Stack);
  array * src=vm::pop<array *>(Stack);
#line 4121 "runtime.in"
  checkArray(src);
  size_t len=checkArray(dest);
  dest->setSlice(left, (Int) len, src);
  {Stack->push<array*>(src); return;}
}

// Returns the length of an array.
#line 4129 "runtime.in"
void arrayLength(stack *Stack)
{
  array * a=vm::pop<array *>(Stack);
#line 4130 "runtime.in"
  {Stack->push<Int>((Int) checkArray(a)); return;}
}

// Returns an array of integers representing the keys of the array.
#line 4135 "runtime.in"
void arrayKeys(stack *Stack)
{
  array * a=vm::pop<array *>(Stack);
#line 4136 "runtime.in"
  size_t size=checkArray(a);

  array *keys=new array();
  for (size_t i=0; i<size; ++i) {
    item& cell = (*a)[i];
    if (!cell.empty())
      keys->push((Int)i);
  }

  {Stack->push<array*>(keys); return;}
}

// Return the cyclic flag for an array.
#line 4150 "runtime.in"
void arrayCyclicFlag(stack *Stack)
{
  array * a=vm::pop<array *>(Stack);
#line 4151 "runtime.in"
  checkArray(a);
  {Stack->push<bool>(a->cyclic()); return;}
}

// Check to see if an array element is initialized.
#line 4157 "runtime.in"
void arrayInitializedHelper(stack *Stack)
{
  array * a=vm::pop<array *>(Stack);
  Int n=vm::pop<Int>(Stack);
#line 4158 "runtime.in"
  size_t len=checkArray(a);
  bool cyclic=a->cyclic();
  if(cyclic && len > 0) n=imod(n,len);
  else if(n < 0 || n >= (Int) len) {Stack->push<bool>(false); return;}
  item&i=(*a)[(unsigned) n];
  {Stack->push<bool>(!i.empty()); return;}
}

// Returns the initialize method for an array.
#line 4168 "runtime.in"
void arrayInitialized(stack *Stack)
{
  array * a=vm::pop<array *>(Stack);
#line 4169 "runtime.in"
  {Stack->push<callable*>(new thunk(new bfunc(arrayInitializedHelper),a)); return;}
}

// The helper function for the cyclic method that sets the cyclic flag.
#line 4174 "runtime.in"
void arrayCyclicHelper(stack *Stack)
{
  array * a=vm::pop<array *>(Stack);
  bool b=vm::pop<bool>(Stack);
#line 4175 "runtime.in"
  checkArray(a);
  a->cyclic(b);
}

// Set the cyclic flag for an array.
#line 4181 "runtime.in"
void arrayCyclic(stack *Stack)
{
  array * a=vm::pop<array *>(Stack);
#line 4182 "runtime.in"
  {Stack->push<callable*>(new thunk(new bfunc(arrayCyclicHelper),a)); return;}
}

// The helper function for the push method that does the actual operation.
#line 4187 "runtime.in"
void arrayPushHelper(stack *Stack)
{
  array * a=vm::pop<array *>(Stack);
  item x=vm::pop(Stack);
#line 4188 "runtime.in"
  checkArray(a);
  a->push(x);
  {Stack->push(x); return;}
}

// Returns the push method for an array.
#line 4195 "runtime.in"
void arrayPush(stack *Stack)
{
  array * a=vm::pop<array *>(Stack);
#line 4196 "runtime.in"
  {Stack->push<callable*>(new thunk(new bfunc(arrayPushHelper),a)); return;}
}

// The helper function for the append method that appends b to a.
#line 4201 "runtime.in"
void arrayAppendHelper(stack *Stack)
{
  array * a=vm::pop<array *>(Stack);
  array * b=vm::pop<array *>(Stack);
#line 4202 "runtime.in"
  checkArray(a);
  size_t size=checkArray(b);
  for(size_t i=0; i < size; i++)
    a->push((*b)[i]);
}

// Returns the append method for an array.
#line 4210 "runtime.in"
void arrayAppend(stack *Stack)
{
  array * a=vm::pop<array *>(Stack);
#line 4211 "runtime.in"
  {Stack->push<callable*>(new thunk(new bfunc(arrayAppendHelper),a)); return;}
}

// The helper function for the pop method.
#line 4216 "runtime.in"
void arrayPopHelper(stack *Stack)
{
  array * a=vm::pop<array *>(Stack);
#line 4217 "runtime.in"
  size_t asize=checkArray(a);
  if(asize == 0) 
    error("cannot pop element from empty array");
  {Stack->push(a->pop()); return;}
}

// Returns the pop method for an array.
#line 4225 "runtime.in"
void arrayPop(stack *Stack)
{
  array * a=vm::pop<array *>(Stack);
#line 4226 "runtime.in"
  {Stack->push<callable*>(new thunk(new bfunc(arrayPopHelper),a)); return;}
}

// The helper function for the insert method.
#line 4231 "runtime.in"
void arrayInsertHelper(stack *Stack)
{
  array * a=vm::pop<array *>(Stack);
  array * x=vm::pop<array *>(Stack);
  Int i=vm::pop<Int>(Stack);
#line 4232 "runtime.in"
  size_t asize=checkArray(a);
  checkArray(x);
  if(a->cyclic() && asize > 0) i=imod(i,asize);
  if(i < 0 || i > (Int) asize) 
    outOfBounds("inserting",asize,i);
  (*a).insert((*a).begin()+i,(*x).begin(),(*x).end());
}

// Returns the insert method for an array.
#line 4242 "runtime.in"
void arrayInsert(stack *Stack)
{
  array * a=vm::pop<array *>(Stack);
#line 4243 "runtime.in"
  {Stack->push<callable*>(new thunk(new bfunc(arrayInsertHelper),a)); return;}
}

// Returns the delete method for an array.
#line 4248 "runtime.in"
void arrayDelete(stack *Stack)
{
  array * a=vm::pop<array *>(Stack);
#line 4249 "runtime.in"
  {Stack->push<callable*>(new thunk(new bfunc(arrayDeleteHelper),a)); return;}
}

#line 4253 "runtime.in"
void arrayAlias(stack *Stack)
{
  array * b=vm::pop<array *>(Stack);
  array * a=vm::pop<array *>(Stack);
#line 4254 "runtime.in"
  {Stack->push<bool>(a==b); return;}
}

// Return array formed by indexing array a with elements of integer array b
#line 4259 "runtime.in"
void arrayIntArray(stack *Stack)
{
  array * b=vm::pop<array *>(Stack);
  array * a=vm::pop<array *>(Stack);
#line 4260 "runtime.in"
  size_t asize=checkArray(a);
  size_t bsize=checkArray(b);
  array *r=new array(bsize);
  bool cyclic=a->cyclic();
  for(size_t i=0; i < bsize; i++) {
    Int index=read<Int>(b,i);
    if(cyclic && asize > 0) index=imod(index,asize);
    else
      if(index < 0 || index >= (Int) asize)
	outOfBounds("reading",asize,index);
    (*r)[i]=(*a)[index];
  }
  {Stack->push<array*>(r); return;}
}

// returns the complement of the integer array a in {0,2,...,n-1},
// so that b[complement(a,b.length)] yields the complement of b[a].
#line 4278 "runtime.in"
// Intarray* complement(Intarray *a, Int n);
void gen428(stack *Stack)
{
  Int n=vm::pop<Int>(Stack);
  Intarray * a=vm::pop<Intarray *>(Stack);
#line 4279 "runtime.in"
  size_t asize=checkArray(a);
  array *r=new array(0);
  bool *keep=new bool[n];
  for(Int i=0; i < n; ++i) keep[i]=true;
  for(size_t i=0; i < asize; ++i) {
    Int j=read<Int>(a,i);
    if(j >= 0 && j < n) keep[j]=false;
  }
  for(Int i=0; i < n; i++)
    if(keep[i]) r->push(i);
  
  delete[] keep;
  {Stack->push<Intarray*>(r); return;}
}

// Generate the sequence {f(i) : i=0,1,...n-1} given a function f and integer n
#line 4296 "runtime.in"
void arraySequence(stack *Stack)
{
  Int n=vm::pop<Int>(Stack);
  callable * f=vm::pop<callable *>(Stack);
#line 4297 "runtime.in"
  if(n < 0) n=0;
  array *a=new array(n);
  for(Int i=0; i < n; ++i) {
    Stack->push(i);
    f->call(Stack);
    (*a)[i]=pop(Stack);
  }
  {Stack->push<Intarray*>(a); return;}
}

// Return the array {0,1,...n-1}
#line 4309 "runtime.in"
// Intarray* sequence(Int n);
void gen430(stack *Stack)
{
  Int n=vm::pop<Int>(Stack);
#line 4310 "runtime.in"
  if(n < 0) n=0;
  array *a=new array(n);
  for(Int i=0; i < n; ++i) {
    (*a)[i]=i;
  }
  {Stack->push<Intarray*>(a); return;}
}

// Apply a function to each element of an array
#line 4320 "runtime.in"
void arrayFunction(stack *Stack)
{
  array * a=vm::pop<array *>(Stack);
  callable * f=vm::pop<callable *>(Stack);
#line 4321 "runtime.in"
  size_t size=checkArray(a);
  array *b=new array(size);
  for(size_t i=0; i < size; ++i) {
    Stack->push((*a)[i]);
    f->call(Stack);
    (*b)[i]=pop(Stack);
  }
  {Stack->push<array*>(b); return;}
}

#line 4332 "runtime.in"
void arraySort(stack *Stack)
{
  callable * f=vm::pop<callable *>(Stack);
  array * a=vm::pop<array *>(Stack);
#line 4333 "runtime.in"
  array *c=copyArray(a);
  compareFunc=f;
  FuncStack=Stack;
  stable_sort(c->begin(),c->end(),compareFunction);
  {Stack->push<array*>(c); return;}
}

#line 4341 "runtime.in"
// bool all(boolarray *a);
void gen433(stack *Stack)
{
  boolarray * a=vm::pop<boolarray *>(Stack);
#line 4342 "runtime.in"
  size_t size=checkArray(a);
  bool c=true;
  for(size_t i=0; i < size; i++)
    if(!get<bool>((*a)[i])) {c=false; break;}
  {Stack->push<bool>(c); return;}
}

#line 4350 "runtime.in"
// boolarray* !(boolarray* a);
void gen434(stack *Stack)
{
  boolarray* a=vm::pop<boolarray*>(Stack);
#line 4351 "runtime.in"
  size_t size=checkArray(a);
  array *c=new array(size);
  for(size_t i=0; i < size; i++)
    (*c)[i]=!read<bool>(a,i);
  {Stack->push<boolarray*>(c); return;}
}

#line 4359 "runtime.in"
// Int sum(boolarray *a);
void gen435(stack *Stack)
{
  boolarray * a=vm::pop<boolarray *>(Stack);
#line 4360 "runtime.in"
  size_t size=checkArray(a);
  Int sum=0;
  for(size_t i=0; i < size; i++)
    sum += read<bool>(a,i) ? 1 : 0;
  {Stack->push<Int>(sum); return;}
}

#line 4368 "runtime.in"
void arrayCopy(stack *Stack)
{
  array * a=vm::pop<array *>(Stack);
#line 4369 "runtime.in"
  {Stack->push<array*>(copyArray(a)); return;}
}

#line 4373 "runtime.in"
void arrayConcat(stack *Stack)
{
  array * a=vm::pop<array *>(Stack);
#line 4374 "runtime.in"
  // a is an array of arrays to be concatenated together.
  // The signature is
  //   T[] concat(... T[][] a);

  size_t numArgs=checkArray(a);
  size_t resultSize=0;
  for (size_t i=0; i < numArgs; ++i) {
    resultSize += checkArray(a->read<array *>(i));
  }

  array *result=new array(resultSize);

  size_t ri=0;
  for (size_t i=0; i < numArgs; ++i) {
    array *arg=a->read<array *>(i);
    size_t size=checkArray(arg);

    for (size_t j=0; j < size; ++j) {
      (*result)[ri]=(*arg)[j];
      ++ri;
    }
  }

  {Stack->push<array*>(result); return;}
}

#line 4401 "runtime.in"
void array2Copy(stack *Stack)
{
  array * a=vm::pop<array *>(Stack);
#line 4402 "runtime.in"
  {Stack->push<array*>(copyArray2(a)); return;}
}

#line 4406 "runtime.in"
void array3Copy(stack *Stack)
{
  array * a=vm::pop<array *>(Stack);
#line 4407 "runtime.in"
  {Stack->push<array*>(copyArray3(a)); return;}
}

#line 4411 "runtime.in"
void array2Transpose(stack *Stack)
{
  array * a=vm::pop<array *>(Stack);
#line 4412 "runtime.in"
  size_t asize=checkArray(a);
  array *c=new array(0);
  for(size_t i=0; i < asize; i++) {
    size_t ip=i+1;
    array *ai=read<array*>(a,i);
    size_t aisize=checkArray(ai);
    size_t csize=checkArray(c);
    if(csize < aisize) {
      c->resize(aisize);
      for(size_t j=csize; j < aisize; j++) {
	(*c)[j]=new array(ip);
      }
    }
    for(size_t j=0; j < aisize; j++) {
    array *cj=read<array*>(c,j);
    if(checkArray(cj) < ip) cj->resize(ip);
    (*cj)[i]=(*ai)[j];
    }
  }
  {Stack->push<array*>(c); return;}
}

// a is a rectangular 3D array; perm is an Int array indicating the type of
// permutation  (021 or 120, etc; original is 012).
// Transpose by sending respective members to the permutated locations:
// return the array obtained by putting a[i][j][k] into position perm{ijk}. 
#line 4439 "runtime.in"
void array3Transpose(stack *Stack)
{
  array * perm=vm::pop<array *>(Stack);
  array * a=vm::pop<array *>(Stack);
#line 4440 "runtime.in"
  const size_t DIM=3;

  if(checkArray(perm) != DIM) {
    ostringstream buf;
    buf << "permutation array must have length " << DIM;
    error(buf);
  }
  
  size_t* size=new size_t[DIM];
  for(size_t i=0; i < DIM; ++i) size[i]=DIM;
  
  for(size_t i=0; i < DIM; ++i) {
    Int p=read<Int>(perm,i);
    size_t P=(size_t) p;
    if(p < 0 || P >= DIM) {
      ostringstream buf;
      buf << "permutation index out of range: " << p;
      error(buf);
    }
    size[P]=P;
  }
  
  for(size_t i=0; i < DIM; ++i)
    if(size[i] == DIM) error("permutation indices must be distinct");
  
  static const char *rectangular=
    "3D transpose implemented for rectangular matrices only";
  
  size_t isize=size[0]=checkArray(a);
  array *a0=read<array*>(a,0);
  size[1]=checkArray(a0);
  array *a00=read<array*>(a0,0);
  size[2]=checkArray(a00);
  for(size_t i=0; i < isize; i++) {
    array *ai=read<array*>(a,i);
    size_t jsize=checkArray(ai);
    if(jsize != size[1]) error(rectangular);
    for(size_t j=0; j < jsize; j++) {
      array *aij=read<array*>(ai,j);
      if(checkArray(aij) != size[2]) error(rectangular);
    }
  }
  
  size_t perm0=(size_t) read<Int>(perm,0);
  size_t perm1=(size_t) read<Int>(perm,1);
  size_t perm2=(size_t) read<Int>(perm,2);
  
  size_t sizep0=size[perm0];
  size_t sizep1=size[perm1];
  size_t sizep2=size[perm2];
  
  array *c=new array(sizep0);
  for(size_t i=0; i < sizep0; ++i) {
    array *ci=new array(sizep1);
    (*c)[i]=ci;
    for(size_t j=0; j < sizep1; ++j) {
      array *cij=new array(sizep2);
      (*ci)[j]=cij;
    }
  }
  
  size_t* i=new size_t[DIM];
  
  for(i[0]=0; i[0] < size[0]; ++i[0]) {
    array *a0=read<array*>(a,i[0]);
    for(i[1]=0; i[1] < size[1]; ++i[1]) {
      array *a1=read<array*>(a0,i[1]);
      for(i[2]=0; i[2] < size[2]; ++i[2]) {
	array *c0=read<array*>(c,i[perm0]);
	array *c1=read<array*>(c0,i[perm1]);
	(*c1)[i[perm2]]=read<real>(a1,i[2]);
      }
    }
  }
  
  delete [] i;  
  delete [] size;  

  {Stack->push<array*>(c); return;}
}

// In a boolean array, find the index of the nth true value or -1 if not found
// If n is negative, search backwards.
#line 4524 "runtime.in"
// Int find(boolarray *a, Int n=1);
void gen442(stack *Stack)
{
  Int n=vm::pop<Int>(Stack,1);
  boolarray * a=vm::pop<boolarray *>(Stack);
#line 4525 "runtime.in"
  
  size_t size=checkArray(a);
  Int j=-1;
  if(n > 0)
    for(size_t i=0; i < size; i++)
      if(read<bool>(a,i)) {
	n--; if(n == 0) {j=(Int) i; break;}
      }
  if(n < 0)
    for(size_t i=size; i > 0;)
      if(read<bool>(a,--i)) {
	n++; if(n == 0) {j=(Int) i; break;}
      }
  {Stack->push<Int>(j); return;}
}

#line 4542 "runtime.in"
// bool ==(realarray2 *a, realarray2 *b);
void gen443(stack *Stack)
{
  realarray2 * b=vm::pop<realarray2 *>(Stack);
  realarray2 * a=vm::pop<realarray2 *>(Stack);
#line 4543 "runtime.in"
  size_t n=checkArray(a);
  if(n != checkArray(b)) {Stack->push<bool>(false); return;}
  
  size_t n0=n == 0 ? 0 : checkArray(read<array*>(a,0));
  if(n0 != checkArray(read<array*>(b,0))) {Stack->push<bool>(false); return;}
    
  for(size_t i=0; i < n; ++i) {
    array *ai=read<array*>(a,i);
    array *bi=read<array*>(b,i);
    for(size_t j=0; j < n0; ++j) {
      if(read<real>(ai,j) != read<real>(bi,j))
	{Stack->push<bool>(false); return;}
    }
  }
  {Stack->push<bool>(true); return;}
}

// construct vector obtained by replacing those elements of b for which the
// corresponding elements of a are false by the corresponding element of c.
#line 4563 "runtime.in"
void arrayConditional(stack *Stack)
{
  array * c=vm::pop<array *>(Stack);
  array * b=vm::pop<array *>(Stack);
  array * a=vm::pop<array *>(Stack);
#line 4564 "runtime.in"
  size_t size=checkArray(a);
  array *r=new array(size);
  if(b && c) {
    checkArrays(a,b);
    checkArrays(b,c);
    for(size_t i=0; i < size; i++)
      (*r)[i]=read<bool>(a,i) ? (*b)[i] : (*c)[i];
  } else {
    r->clear();
    if(b) {
      checkArrays(a,b);
      for(size_t i=0; i < size; i++)
        if(read<bool>(a,i)) r->push((*b)[i]);
    } else if(c) {
      checkArrays(a,c);
      for(size_t i=0; i < size; i++)
        if(!read<bool>(a,i)) r->push((*c)[i]);
    }
  }
  {Stack->push<array*>(r); return;}
}

// Return an n x n identity matrix.
#line 4588 "runtime.in"
// realarray2* identity(Int n);
void gen445(stack *Stack)
{
  Int n=vm::pop<Int>(Stack);
#line 4589 "runtime.in"
  {Stack->push<realarray2*>(Identity(n)); return;}
}

// Return the diagonal matrix with diagonal entries given by a.
#line 4594 "runtime.in"
void diagonal(stack *Stack)
{
  realarray * a=vm::pop<realarray *>(Stack);
#line 4595 "runtime.in"
  size_t n=checkArray(a);
  array *c=new array(n);
  for(size_t i=0; i < n; ++i) {
    array *ci=new array(n);
    (*c)[i]=ci;
    for(size_t j=0; j < i; ++j)
      (*ci)[j]=0.0;
    (*ci)[i]=read<real>(a,i);
    for(size_t j=i+1; j < n; ++j)
      (*ci)[j]=0.0;
  }
  {Stack->push<realarray2*>(c); return;}
}

// Return the inverse of an n x n matrix a using Gauss-Jordan elimination.
#line 4611 "runtime.in"
// realarray2* inverse(realarray2 *a);
void gen447(stack *Stack)
{
  realarray2 * a=vm::pop<realarray2 *>(Stack);
#line 4612 "runtime.in"
  a=copyArray2(a);
  size_t n=checkArray(a);
  checkSquare(a);
  
  inverseAllocate(n);
  
  for(size_t i=0; i < n; i++)
    pivot[i]=0;
 
  size_t col=0, row=0;
  // This is the main loop over the columns to be reduced.
  for(size_t i=0; i < n; i++) {
    real big=0.0;
    // This is the outer loop of the search for a pivot element.
    for(size_t j=0; j < n; j++) {
      array *aj=read<array*>(a,j);
      if(pivot[j] != 1) {
	for(size_t k=0; k < n; k++) {
	  if(pivot[k] == 0) {
	    real temp=fabs(read<real>(aj,k));
	    if(temp >= big) {
	      big=temp;
	      row=j;
	      col=k;
	    }
	  } else if(pivot[k] > 1) {
	    inverseDeallocate();
	    error(singular);
	  }
	}
      }
    }
    ++(pivot[col]);
    
    // Interchange rows, if needed, to put the pivot element on the diagonal.
    array *acol=read<array*>(a,col);
    if(row != col) {
      array *arow=read<array*>(a,row);
      for(size_t l=0; l < n; l++) {
	real temp=read<real>(arow,l);
	(*arow)[l]=read<real>(acol,l);
	(*acol)[l]=temp;
      }
    }
    
    Row[i]=row; 
    Col[i]=col;

    // Divide the pivot row by the pivot element.
    real denom=read<real>(acol,col);
    if(denom == 0.0) {
      inverseDeallocate();
      error(singular);
    }
    real pivinv=1.0/denom;
    (*acol)[col]=1.0;
    for(size_t l=0; l < n; l++) 
      (*acol)[l]=read<real>(acol,l)*pivinv;
    
    // Reduce all rows except for the pivoted one.
    for(size_t k=0; k < n; k++) {
      if(k != col) { 
	array *ak=read<array*>(a,k);
	real akcol=read<real>(ak,col);
	(*ak)[col]=0.0;
	for(size_t l=0; l < n; l++)
	  (*ak)[l]=read<real>(ak,l)-read<real>(acol,l)*akcol;
      }
    }
  }
  
  // Unscramble the inverse matrix in view of the column interchanges.
  for(size_t l=n; l > 0;) {
    l--;
    size_t r=Row[l];
    size_t c=Col[l];
    if(r != c) {
      for(size_t k=0; k < n; k++) {
	array *ak=read<array*>(a,k);
	real temp=read<real>(ak,r);
	(*ak)[r]=read<real>(ak,c);
	(*ak)[c]=temp;
      }
    }
  }
  inverseDeallocate();
  {Stack->push<realarray2*>(a); return;}
}

// Solve the linear equation ax=b by LU decomposition, returning the
// solution x, where a is an n x n matrix and b is an array of length n.
// If no solution exists, return an empty array.
#line 4705 "runtime.in"
// realarray* solve(realarray2 *a, realarray *b, bool warn=true);
void gen448(stack *Stack)
{
  bool warn=vm::pop<bool>(Stack,true);
  realarray * b=vm::pop<realarray *>(Stack);
  realarray2 * a=vm::pop<realarray2 *>(Stack);
#line 4706 "runtime.in"
  size_t n=checkArray(a);
  
  if(n == 0) {Stack->push<realarray*>(new array(0)); return;}
  
  size_t m=checkArray(b);
  if(m != n) error(incommensurate);
  
  real *A=copyArray2C(a);
  size_t *index=new size_t[n];
  
  if(LUdecompose(A,n,index,warn) == 0)
    {Stack->push<realarray*>(new array(0)); return;}

  array *x=new array(n);
  
  real *B=copyArrayC(b);
  
  for(size_t i=0; i < n; ++i) {
    size_t ip=index[i];
    real sum=B[ip];
    B[ip]=B[i];
    real *Ai=A+i*n;
    for(size_t j=0; j < i; ++j)
      sum -= Ai[j]*B[j];
    B[i]=sum;
  }
  
  for(size_t i=n; i > 0;) {
    --i;
    real sum=B[i];
    real *Ai=A+i*n;
    for(size_t j=i+1; j < n; ++j)
      sum -= Ai[j]*B[j];
    B[i]=sum/Ai[i];
  }
  
  for(size_t i=0; i < n; ++i)
    (*x)[i]=B[i];

  delete[] index;
  delete[] B;
  delete[] A;
  
  {Stack->push<realarray*>(x); return;}
}

// Solve the linear equation ax=b by LU decomposition, returning the
// solution x, where a is an n x n matrix and b is an n x m matrix.
// If no solution exists, return an empty array.
#line 4756 "runtime.in"
// realarray2* solve(realarray2 *a, realarray2 *b, bool warn=true);
void gen449(stack *Stack)
{
  bool warn=vm::pop<bool>(Stack,true);
  realarray2 * b=vm::pop<realarray2 *>(Stack);
  realarray2 * a=vm::pop<realarray2 *>(Stack);
#line 4757 "runtime.in"
  size_t n=checkArray(a);
  
  if(n == 0) {Stack->push<realarray2*>(new array(0)); return;}
  
  if(checkArray(b) != n) error(incommensurate);
  size_t m=checkArray(read<array*>(b,0));
  
  real *A=copyArray2C(a);
  real *B=copyArray2C(b,false);
  
  size_t *index=new size_t[n];
  
  if(LUdecompose(A,n,index,warn) == 0)
    {Stack->push<realarray2*>(new array(0)); return;}

  array *x=new array(n);
  
  for(size_t i=0; i < n; ++i) {
    real *Ai=A+i*n;
    real *Bi=B+i*m;
    real *Bip=B+index[i]*m;
    for(size_t k=0; k < m; ++k) {
      real sum=Bip[k];
      Bip[k]=Bi[k];
      size_t jk=k;
      for(size_t j=0; j < i; ++j, jk += m)
	sum -= Ai[j]*B[jk];
      Bi[k]=sum;
    }
  }
  
  for(size_t i=n; i > 0;) {
    --i;
    real *Ai=A+i*n;
    real *Bi=B+i*m;
    for(size_t k=0; k < m; ++k) {
      real sum=Bi[k];
      size_t jk=(i+1)*m+k;
      for(size_t j=i+1; j < n; ++j, jk += m)
	sum -= Ai[j]*B[jk];
      Bi[k]=sum/Ai[i];
    }
  }
  
  for(size_t i=0; i < n; ++i) {
    real *Bi=B+i*m;
    array *xi=new array(m);
    (*x)[i]=xi;
    for(size_t j=0; j < m; ++j)
      (*xi)[j]=Bi[j];
  }
    
  delete[] index;
  delete[] B;
  delete[] A;
  
  {Stack->push<realarray2*>(x); return;}
}

// Compute the determinant of an n x n matrix.
#line 4818 "runtime.in"
// real determinant(realarray2 *a);
void gen450(stack *Stack)
{
  realarray2 * a=vm::pop<realarray2 *>(Stack);
#line 4819 "runtime.in"
  real *A=copyArray2C(a);
  size_t n=checkArray(a);
  
  real det=LUdecompose(A,n,NULL,false);
  size_t n1=n+1;
  for(size_t i=0; i < n; ++i)
    det *= A[i*n1];
  
  delete[] A;
  
  {Stack->push<real>(det); return;}
}

#line 4833 "runtime.in"
// realarray* *(realarray2 *a, realarray *b);
void gen451(stack *Stack)
{
  realarray * b=vm::pop<realarray *>(Stack);
  realarray2 * a=vm::pop<realarray2 *>(Stack);
#line 4834 "runtime.in"
  size_t n=checkArray(a);
  size_t m=checkArray(b);
  array *c=new array(n);
  real *B=copyArrayC(b);
  for(size_t i=0; i < n; ++i) {
    array *ai=read<array*>(a,i);
    if(checkArray(ai) != m) error(incommensurate);
    real sum=0.0;
    for(size_t j=0; j < m; ++j)
      sum += read<real>(ai,j)*B[j];
    (*c)[i]=sum;
  }
  delete[] B;
  {Stack->push<realarray*>(c); return;}
}

#line 4851 "runtime.in"
// realarray2* *(realarray2 *a, realarray2 *b);
void gen452(stack *Stack)
{
  realarray2 * b=vm::pop<realarray2 *>(Stack);
  realarray2 * a=vm::pop<realarray2 *>(Stack);
#line 4852 "runtime.in"
  size_t n=checkArray(a);
  
  size_t nb=checkArray(b);
  size_t na0=n == 0 ? 0 : checkArray(read<array*>(a,0));
  if(na0 != nb) 
    error(incommensurate);
  
  size_t nb0=nb == 0 ? 0 : checkArray(read<array*>(b,0));
    
  array *c=new array(n);

  real *A=copyArray2C(a,false);
  real *B=copyArray2C(b,false);

  for(size_t i=0; i < n; ++i) {
    real *Ai=A+i*nb;
    array *ci=new array(nb0);
    (*c)[i]=ci;
    for(size_t j=0; j < nb0; ++j) {
      real sum=0.0;
      size_t kj=j;
      for(size_t k=0; k < nb; ++k, kj += nb0)
        sum += Ai[k]*B[kj];
      (*ci)[j]=sum;
    }
  }
  
  delete[] B;
  delete[] A;
  
  {Stack->push<realarray2*>(c); return;}
}

#line 4886 "runtime.in"
// triple *(realarray2 *t, triple v);
void gen453(stack *Stack)
{
  triple v=vm::pop<triple>(Stack);
  realarray2 * t=vm::pop<realarray2 *>(Stack);
#line 4887 "runtime.in"
  {Stack->push<triple>(*t*v); return;}
}

#line 4891 "runtime.in"
// pair project(triple v, realarray2 *t);
void gen454(stack *Stack)
{
  realarray2 * t=vm::pop<realarray2 *>(Stack);
  triple v=vm::pop<triple>(Stack);
#line 4892 "runtime.in"
  size_t n=checkArray(t);
  if(n != 4) error(incommensurate);
  array *t0=read<array*>(t,0);
  array *t1=read<array*>(t,1);
  array *t3=read<array*>(t,3);
  if(checkArray(t0) != 4 || checkArray(t1) != 4 || checkArray(t3) != 4)
    error(incommensurate);
  
  real x=v.getx();
  real y=v.gety();
  real z=v.getz();
  
  real f=read<real>(t3,0)*x+read<real>(t3,1)*y+read<real>(t3,2)*z+
    read<real>(t3,3);
  if(f == 0.0) dividebyzero();
  f=1.0/f;
  
  {Stack->push<pair>(pair((read<real>(t0,0)*x+read<real>(t0,1)*y+read<real>(t0,2)*z+
	       read<real>(t0,3))*f,
	      (read<real>(t1,0)*x+read<real>(t1,1)*y+read<real>(t1,2)*z+
	       read<real>(t1,3))*f)); return;}
}

// Compute the dot product of vectors a and b.
#line 4917 "runtime.in"
// real dot(realarray *a, realarray *b);
void gen455(stack *Stack)
{
  realarray * b=vm::pop<realarray *>(Stack);
  realarray * a=vm::pop<realarray *>(Stack);
#line 4918 "runtime.in"
  size_t n=checkArrays(a,b);
  real sum=0.0;
  for(size_t i=0; i < n; ++i)
    sum += read<real>(a,i)*read<real>(b,i);
  {Stack->push<real>(sum); return;}
}

// Solve the problem L\inv f, where f is an n vector and L is the n x n matrix
//
// [ b[0] c[0]           a[0]   ]
// [ a[1] b[1] c[1]             ]
// [      a[2] b[2] c[2]        ]
// [                ...         ]
// [ c[n-1]       a[n-1] b[n-1] ]
#line 4933 "runtime.in"
// realarray* tridiagonal(realarray *a, realarray *b, realarray *c, realarray *f);
void gen456(stack *Stack)
{
  realarray * f=vm::pop<realarray *>(Stack);
  realarray * c=vm::pop<realarray *>(Stack);
  realarray * b=vm::pop<realarray *>(Stack);
  realarray * a=vm::pop<realarray *>(Stack);
#line 4934 "runtime.in"
  size_t n=checkArrays(a,b);
  checkEqual(n,checkArray(c));
  checkEqual(n,checkArray(f));
  
  array *up=new array(n);
  array& u=*up;

  if(n == 0) {Stack->push<realarray*>(up); return;}
  
  // Special case: zero Dirichlet boundary conditions
  if(read<real>(a,0) == 0.0 && read<real>(c,n-1) == 0.0) {
    real temp=read<real>(b,0);
    if(temp == 0.0) dividebyzero();
    temp=1.0/temp;
    
    real *work=new real[n];
    u[0]=read<real>(f,0)*temp;
    work[0]=-read<real>(c,0)*temp;
	
    for(size_t i=1; i < n; i++) {
      real temp=(read<real>(b,i)+read<real>(a,i)*work[i-1]);
      if(temp == 0.0) {delete[] work; dividebyzero();}
      temp=1.0/temp;
      u[i]=(read<real>(f,i)-read<real>(a,i)*read<real>(u,i-1))*temp;
      work[i]=-read<real>(c,i)*temp;
    }

    for(size_t i=n-1; i >= 1; i--)
      u[i-1]=read<real>(u,i-1)+work[i-1]*read<real>(u,i);
    
    delete[] work;
    {Stack->push<realarray*>(up); return;}
  }
  
  real binv=read<real>(b,0);
  if(binv == 0.0) dividebyzero();
  binv=1.0/binv;
  
  if(n == 1) {u[0]=read<real>(f,0)*binv; {Stack->push<realarray*>(up); return;}}
  if(n == 2) {
    real factor=(read<real>(b,0)*read<real>(b,1)-
		   read<real>(a,0)*read<real>(c,1));
    if(factor== 0.0) dividebyzero();
    factor=1.0/factor;
    real temp=(read<real>(b,0)*read<real>(f,1)-
	  read<real>(c,1)*read<real>(f,0))*factor;
    u[0]=(read<real>(b,1)*read<real>(f,0)-
	  read<real>(a,0)*read<real>(f,1))*factor;
    u[1]=temp;
    {Stack->push<realarray*>(up); return;}
  }
	
  real *gamma=new real[n-2];
  real *delta=new real[n-2];
  
  gamma[0]=read<real>(c,0)*binv;
  delta[0]=read<real>(a,0)*binv;
  u[0]=read<real>(f,0)*binv;
  real beta=read<real>(c,n-1);
  real fn=read<real>(f,n-1)-beta*read<real>(u,0);
  real alpha=read<real>(b,n-1)-beta*delta[0];

  for(size_t i=1; i <= n-3; i++) {
    real alphainv=read<real>(b,i)-read<real>(a,i)*gamma[i-1];
    if(alphainv == 0.0) {delete[] gamma; delete[] delta; dividebyzero();}
    alphainv=1.0/alphainv;
    beta *= -gamma[i-1];
    gamma[i]=read<real>(c,i)*alphainv;
    u[i]=(read<real>(f,i)-read<real>(a,i)*read<real>(u,i-1))*alphainv;
    fn -= beta*read<real>(u,i);
    delta[i]=-read<real>(a,i)*delta[i-1]*alphainv;
    alpha -= beta*delta[i];
  }
	
  real alphainv=read<real>(b,n-2)-read<real>(a,n-2)*gamma[n-3];
  if(alphainv == 0.0) {delete[] gamma; delete[] delta; dividebyzero();}
  alphainv=1.0/alphainv;
  u[n-2]=(read<real>(f,n-2)-read<real>(a,n-2)*read<real>(u,n-3))
    *alphainv;
  beta=read<real>(a,n-1)-beta*gamma[n-3];
  real dnm1=(read<real>(c,n-2)-read<real>(a,n-2)*delta[n-3])*alphainv;
  real temp=alpha-beta*dnm1;
  if(temp == 0.0) {delete[] gamma; delete[] delta; dividebyzero();}
  u[n-1]=temp=(fn-beta*read<real>(u,n-2))/temp;
  u[n-2]=read<real>(u,n-2)-dnm1*temp;
	
  for(size_t i=n-2; i >= 1; i--)
    u[i-1]=read<real>(u,i-1)-gamma[i-1]*read<real>(u,i)-delta[i-1]*temp;
  
  delete[] delta;
  delete[] gamma;
  
  {Stack->push<realarray*>(up); return;}
}

// Root solve by Newton-Raphson
#line 5031 "runtime.in"
// real newton(Int iterations=100, callableReal *f, callableReal *fprime, real x,	    bool verbose=false);
void gen457(stack *Stack)
{
  bool verbose=vm::pop<bool>(Stack,false);
  real x=vm::pop<real>(Stack);
  callableReal * fprime=vm::pop<callableReal *>(Stack);
  callableReal * f=vm::pop<callableReal *>(Stack);
  Int iterations=vm::pop<Int>(Stack,100);
#line 5033 "runtime.in"
  static const real fuzz=1000.0*DBL_EPSILON;
  Int i=0;
  size_t oldPrec=0;
  if(verbose) 
    oldPrec=cout.precision(DBL_DIG);

  real diff=DBL_MAX;
  real lastdiff;
  do {
    real x0=x;
    
    Stack->push(x);
    fprime->call(Stack);
    real dfdx=pop<real>(Stack);
    
    if(dfdx == 0.0) {
      x=DBL_MAX;
      break;
    }

    Stack->push(x);
    f->call(Stack);
    real fx=pop<real>(Stack);
    
    x -= fx/dfdx;

    lastdiff=diff;
    
    if(verbose)
      cout << "Newton-Raphson: " << x << endl;
    
    diff=fabs(x-x0);
    if(++i == iterations) {
      x=DBL_MAX;
      break;
    }
  } while (diff != 0.0 && (diff < lastdiff || diff > fuzz*fabs(x)));

  if(verbose)
    cout.precision(oldPrec);
  {Stack->push<real>(x); return;}
}

// Root solve by Newton-Raphson bisection
// cf. routine rtsafe (Press et al.,  Numerical Recipes, 1991).
#line 5079 "runtime.in"
// real newton(Int iterations=100, callableReal *f, callableReal *fprime, real x1,	    real x2, bool verbose=false);
void gen458(stack *Stack)
{
  bool verbose=vm::pop<bool>(Stack,false);
  real x2=vm::pop<real>(Stack);
  real x1=vm::pop<real>(Stack);
  callableReal * fprime=vm::pop<callableReal *>(Stack);
  callableReal * f=vm::pop<callableReal *>(Stack);
  Int iterations=vm::pop<Int>(Stack,100);
#line 5081 "runtime.in"
  static const real fuzz=1000.0*DBL_EPSILON;
  size_t oldPrec=0;
  if(verbose) 
    oldPrec=cout.precision(DBL_DIG);

  Stack->push(x1);
  f->call(Stack);
  real f1=pop<real>(Stack);
  if(f1 == 0.0) {Stack->push<real>(x1); return;}
  
  Stack->push(x2);
  f->call(Stack);
  real f2=pop<real>(Stack);
  if(f2 == 0.0) {Stack->push<real>(x2); return;}
	
  if((f1 > 0.0 && f2 > 0.0) || (f1 < 0.0 && f2 < 0.0)) {
    ostringstream buf;
    buf << "root not bracketed, f(x1)=" << f1 << ", f(x2)=" << f2 << endl;
    error(buf);
  }

  real x=0.5*(x1+x2);
  real dxold=fabs(x2-x1);
  if(f1 > 0.0) {
    real temp=x1;
    x1=x2;
    x2=temp;
  }
	
  if(verbose)
    cout << "midpoint: " << x << endl;

  real dx=dxold;
  Stack->push(x);
  f->call(Stack);
  real y=pop<real>(Stack);
  
  Stack->push(x);
  fprime->call(Stack);
  real dy=pop<real>(Stack);

  Int j;
  for(j=0; j < iterations; j++) {
    if(((x-x2)*dy-y)*((x-x1)*dy-y) >= 0.0 || fabs(2.0*y) > fabs(dxold*dy)) {
      dxold=dx;
      dx=0.5*(x2-x1);
      x=x1+dx;
      if(verbose)
	cout << "bisection: " << x << endl;
      if(x1 == x) {Stack->push<real>(x); return;}
    } else {
      dxold=dx;
      dx=y/dy;
      real temp=x;
      x -= dx;
      if(verbose)
	cout << "Newton-Raphson: " << x << endl;
      if(temp == x) {Stack->push<real>(x); return;}
    }
    if(fabs(dx) < fuzz*fabs(x)) {Stack->push<real>(x); return;}
    
    Stack->push(x);
    f->call(Stack);
    y=pop<real>(Stack);
    
    Stack->push(x);
    fprime->call(Stack);
    dy=pop<real>(Stack);

    if(y < 0.0) x1=x;
    else x2=x;
  }
  if(verbose)
    cout.precision(oldPrec);
  {Stack->push<real>((j == iterations) ? DBL_MAX : x); return;}
}

#line 5159 "runtime.in"
// real simpson(callableReal *f, real a, real b, real acc=DBL_EPSILON,	     real dxmax=0);
void gen459(stack *Stack)
{
  real dxmax=vm::pop<real>(Stack,0);
  real acc=vm::pop<real>(Stack,DBL_EPSILON);
  real b=vm::pop<real>(Stack);
  real a=vm::pop<real>(Stack);
  callableReal * f=vm::pop<callableReal *>(Stack);
#line 5161 "runtime.in"
  real integral;
  if(dxmax == 0) dxmax=b-a;
  Func=f;
  FuncStack=Stack;
  if(!simpson(integral,wrapFunction,a,b,acc,dxmax))
    error("nesting capacity exceeded in simpson");
  {Stack->push<real>(integral); return;}
}

// Compute the fast Fourier transform of a pair array
#line 5172 "runtime.in"
void pairArrayFFT(stack *Stack)
{
  Int sign=vm::pop<Int>(Stack,1);
  pairarray * a=vm::pop<pairarray *>(Stack);
#line 5173 "runtime.in"
  unsigned n=(unsigned) checkArray(a);
#ifdef HAVE_LIBFFTW3
  array *c=new array(n);
  if(n) {
    Complex *f=FFTWComplex(n);
    fft1d Forward(n,intcast(sign),f);
  
    for(size_t i=0; i < n; i++) {
      pair z=read<pair>(a,i);
      f[i]=Complex(z.getx(),z.gety());
    }
    Forward.fft(f);
  
    for(size_t i=0; i < n; i++) {
      Complex z=f[i];
      (*c)[i]=pair(z.real(),z.imag());
    }
    FFTWdelete(f);
  }
#else
  unused(&n);
  unused(&sign);
  array *c=new array(0);
#endif //  HAVE_LIBFFTW3
  {Stack->push<pairarray*>(c); return;}
}

#line 5201 "runtime.in"
// Intarray2* triangulate(pairarray *z);
void gen461(stack *Stack)
{
  pairarray * z=vm::pop<pairarray *>(Stack);
#line 5202 "runtime.in"
  size_t nv=checkArray(z);
// Call robust version of Gilles Dumoulin's port of Paul Bourke's
// triangulation code.

  XYZ *pxyz=new XYZ[nv+3];
  ITRIANGLE *V=new ITRIANGLE[4*nv];
  
  for(size_t i=0; i < nv; ++i) {
    pair w=read<pair>(z,i);
    pxyz[i].p[0]=w.getx();
    pxyz[i].p[1]=w.gety();
    pxyz[i].i=(Int) i;
  }
  
  Int ntri;
  Triangulate((Int) nv,pxyz,V,ntri,true,false);

  size_t nt=(size_t) ntri;
  array *t=new array(nt);
  for(size_t i=0; i < nt; ++i) {
    array *ti=new array(3);
    (*t)[i]=ti;
    ITRIANGLE *Vi=V+i;
    (*ti)[0]=pxyz[Vi->p1].i;
    (*ti)[1]=pxyz[Vi->p2].i;
    (*ti)[2]=pxyz[Vi->p3].i;
  }
   
  delete[] V;
  delete[] pxyz;
  {Stack->push<Intarray2*>(t); return;}
}


// File operations
#line 5238 "runtime.in"
// bool ==(file *a, file *b);
void gen462(stack *Stack)
{
  file * b=vm::pop<file *>(Stack);
  file * a=vm::pop<file *>(Stack);
#line 5239 "runtime.in"
  {Stack->push<bool>(a == b); return;}
}

#line 5244 "runtime.in"
// bool !=(file *a, file *b);
void gen463(stack *Stack)
{
  file * b=vm::pop<file *>(Stack);
  file * a=vm::pop<file *>(Stack);
#line 5245 "runtime.in"
  {Stack->push<bool>(a != b); return;}
}

#line 5249 "runtime.in"
void nullFile(stack *Stack)
{
#line 5250 "runtime.in"
 {Stack->push<file*>(&camp::nullfile); return;}
}

#line 5254 "runtime.in"
// file* input(string name, bool check=true, string comment=commentchar);
void gen465(stack *Stack)
{
  string comment=vm::pop<string>(Stack,commentchar);
  bool check=vm::pop<bool>(Stack,true);
  string name=vm::pop<string>(Stack);
#line 5255 "runtime.in"
  char c=comment.empty() ? (char) 0 : comment[0];
  file *f=new ifile(name,c,check);
  f->open();
  {Stack->push<file*>(f); return;}
}

#line 5262 "runtime.in"
// file* output(string name, bool update=false, string comment=commentchar);
void gen466(stack *Stack)
{
  string comment=vm::pop<string>(Stack,commentchar);
  bool update=vm::pop<bool>(Stack,false);
  string name=vm::pop<string>(Stack);
#line 5263 "runtime.in"
  file *f;
  if(update) {
    char c=comment.empty() ? (char) 0 : comment[0];
    f=new iofile(name,c);
  } else f=new ofile(name);
  f->open();
  if(update) f->seek(0,false);
  {Stack->push<file*>(f); return;}
}

#line 5274 "runtime.in"
// file* xinput(string name, bool check=true);
void gen467(stack *Stack)
{
  bool check=vm::pop<bool>(Stack,true);
  string name=vm::pop<string>(Stack);
#line 5275 "runtime.in"
#ifdef HAVE_RPC_RPC_H
  file *f=new ixfile(name,check);
  f->open();
  {Stack->push<file*>(f); return;}
#else  
  ostringstream buf;
  buf << name << ": XDR read support not enabled";
  error(buf);
  unused(&check); // Suppress unused variable warning
#endif
}

#line 5288 "runtime.in"
// file* xoutput(string name, bool update=false);
void gen468(stack *Stack)
{
  bool update=vm::pop<bool>(Stack,false);
  string name=vm::pop<string>(Stack);
#line 5289 "runtime.in"
#ifdef HAVE_RPC_RPC_H
  file *f;
  if(update)
    f=new ioxfile(name);
  else f=new oxfile(name);
  f->open();
  if(update) f->seek(0,false);
  {Stack->push<file*>(f); return;}
#else  
  ostringstream buf;
  buf << name << ": XDR write support not enabled";
  error(buf);
  unused(&update); // Suppress unused variable warning
#endif
}

#line 5306 "runtime.in"
// file* binput(string name, bool check=true);
void gen469(stack *Stack)
{
  bool check=vm::pop<bool>(Stack,true);
  string name=vm::pop<string>(Stack);
#line 5307 "runtime.in"
  file *f=new ibfile(name,check);
  f->open();
  {Stack->push<file*>(f); return;}
}

#line 5313 "runtime.in"
// file* boutput(string name, bool update=false);
void gen470(stack *Stack)
{
  bool update=vm::pop<bool>(Stack,false);
  string name=vm::pop<string>(Stack);
#line 5314 "runtime.in"
  file *f;
  if(update) f=new iobfile(name);
  else f=new obfile(name);
  f->open();
  if(update) f->seek(0,false);
  {Stack->push<file*>(f); return;}
}

#line 5323 "runtime.in"
// bool eof(file *File);
void gen471(stack *Stack)
{
  file * File=vm::pop<file *>(Stack);
#line 5324 "runtime.in"
  {Stack->push<bool>(File->eof()); return;}
}

#line 5328 "runtime.in"
// bool eol(file *File);
void gen472(stack *Stack)
{
  file * File=vm::pop<file *>(Stack);
#line 5329 "runtime.in"
  {Stack->push<bool>(File->eol()); return;}
}

#line 5333 "runtime.in"
// bool error(file *File);
void gen473(stack *Stack)
{
  file * File=vm::pop<file *>(Stack);
#line 5334 "runtime.in"
  {Stack->push<bool>(File->error()); return;}
}

#line 5338 "runtime.in"
// void clear(file *File);
void gen474(stack *Stack)
{
  file * File=vm::pop<file *>(Stack);
#line 5339 "runtime.in"
  File->clear();
}

#line 5343 "runtime.in"
// void close(file *File);
void gen475(stack *Stack)
{
  file * File=vm::pop<file *>(Stack);
#line 5344 "runtime.in"
  File->close();
}

#line 5348 "runtime.in"
// Int precision(file *File=NULL, Int digits=0);
void gen476(stack *Stack)
{
  Int digits=vm::pop<Int>(Stack,0);
  file * File=vm::pop<file *>(Stack,NULL);
#line 5349 "runtime.in"
  if(File == 0) File=&camp::Stdout;
  {Stack->push<Int>(File->precision(digits)); return;}
}

#line 5354 "runtime.in"
// void flush(file *File);
void gen477(stack *Stack)
{
  file * File=vm::pop<file *>(Stack);
#line 5355 "runtime.in"
   File->flush();
}

#line 5359 "runtime.in"
// string getc(file *File);
void gen478(stack *Stack)
{
  file * File=vm::pop<file *>(Stack);
#line 5360 "runtime.in"
  char c=0;
  if(File->isOpen()) File->read(c);
  static char str[1];
  str[0]=c;
  {Stack->push<string>(string(str)); return;}
}

#line 5368 "runtime.in"
// Int tell(file *File);
void gen479(stack *Stack)
{
  file * File=vm::pop<file *>(Stack);
#line 5369 "runtime.in"
  {Stack->push<Int>(File->tell()); return;}
}

#line 5373 "runtime.in"
// void seek(file *File, Int pos);
void gen480(stack *Stack)
{
  Int pos=vm::pop<Int>(Stack);
  file * File=vm::pop<file *>(Stack);
#line 5374 "runtime.in"
  File->seek(pos,pos >= 0);
}

#line 5378 "runtime.in"
// void seekeof(file *File);
void gen481(stack *Stack)
{
  file * File=vm::pop<file *>(Stack);
#line 5379 "runtime.in"
  File->seek(0,false);
}

// Set file dimensions
#line 5384 "runtime.in"
// file* dimension(file *File, Int nx);
void gen482(stack *Stack)
{
  Int nx=vm::pop<Int>(Stack);
  file * File=vm::pop<file *>(Stack);
#line 5385 "runtime.in"
  File->dimension(nx);
  {Stack->push<file*>(File); return;}
}

#line 5390 "runtime.in"
// file* dimension(file *File, Int nx, Int ny);
void gen483(stack *Stack)
{
  Int ny=vm::pop<Int>(Stack);
  Int nx=vm::pop<Int>(Stack);
  file * File=vm::pop<file *>(Stack);
#line 5391 "runtime.in"
  File->dimension(nx,ny);
  {Stack->push<file*>(File); return;}
}

#line 5396 "runtime.in"
// file* dimension(file *File, Int nx, Int ny, Int nz);
void gen484(stack *Stack)
{
  Int nz=vm::pop<Int>(Stack);
  Int ny=vm::pop<Int>(Stack);
  Int nx=vm::pop<Int>(Stack);
  file * File=vm::pop<file *>(Stack);
#line 5397 "runtime.in"
  File->dimension(nx,ny,nz);
  {Stack->push<file*>(File); return;}
}

// Set file to read comma-separated values
#line 5403 "runtime.in"
// file* csv(file *File, bool b=true);
void gen485(stack *Stack)
{
  bool b=vm::pop<bool>(Stack,true);
  file * File=vm::pop<file *>(Stack);
#line 5404 "runtime.in"
  File->CSVMode(b);
  {Stack->push<file*>(File); return;}
}

// Set file to read whitespace-separated values
#line 5410 "runtime.in"
// file* word(file *File, bool b=true);
void gen486(stack *Stack)
{
  bool b=vm::pop<bool>(Stack,true);
  file * File=vm::pop<file *>(Stack);
#line 5411 "runtime.in"
  File->WordMode(b);
  {Stack->push<file*>(File); return;}
}

// Set file to read arrays in line-at-a-time mode
#line 5417 "runtime.in"
// file* line(file *File, bool b=true);
void gen487(stack *Stack)
{
  bool b=vm::pop<bool>(Stack,true);
  file * File=vm::pop<file *>(Stack);
#line 5418 "runtime.in"
  File->LineMode(b);
  {Stack->push<file*>(File); return;}
}

// Set file to read/write single-precision XDR values.
#line 5424 "runtime.in"
// file* single(file *File, bool b=true);
void gen488(stack *Stack)
{
  bool b=vm::pop<bool>(Stack,true);
  file * File=vm::pop<file *>(Stack);
#line 5425 "runtime.in"
  File->SingleReal(b);
  File->SingleInt(b);
  {Stack->push<file*>(File); return;}
}

// Set file to read/write single-precision real XDR values.
#line 5432 "runtime.in"
// file* single(file *File, real x, bool b=true);
void gen489(stack *Stack)
{
  bool b=vm::pop<bool>(Stack,true);
  real x=vm::pop<real>(Stack);
  file * File=vm::pop<file *>(Stack);
#line 5433 "runtime.in"
  File->SingleReal(b);
  unused(&x);
  {Stack->push<file*>(File); return;}
}

// Set file to read/write single-precision int XDR values.
#line 5440 "runtime.in"
// file* single(file *File, Int x, bool b=true);
void gen490(stack *Stack)
{
  bool b=vm::pop<bool>(Stack,true);
  Int x=vm::pop<Int>(Stack);
  file * File=vm::pop<file *>(Stack);
#line 5441 "runtime.in"
  File->SingleInt(b);
  unused(&x);
  {Stack->push<file*>(File); return;}
}

// Set file to read an array1 (1 Int size followed by a 1d array)
#line 5448 "runtime.in"
// file* read1(file *File);
void gen491(stack *Stack)
{
  file * File=vm::pop<file *>(Stack);
#line 5449 "runtime.in"
  File->dimension(-2);
  {Stack->push<file*>(File); return;}
}

// Set file to read an array2 (2 Int sizes followed by a 2d array)
#line 5455 "runtime.in"
// file* read2(file *File);
void gen492(stack *Stack)
{
  file * File=vm::pop<file *>(Stack);
#line 5456 "runtime.in"
  File->dimension(-2,-2);
  {Stack->push<file*>(File); return;}
}

// Set file to read an array3 (3 Int sizes followed by a 3d array)
#line 5462 "runtime.in"
// file* read3(file *File);
void gen493(stack *Stack)
{
  file * File=vm::pop<file *>(Stack);
#line 5463 "runtime.in"
  File->dimension(-2,-2,-2);
  {Stack->push<file*>(File); return;}
}

// Return the last n lines of the history named name.
#line 5469 "runtime.in"
// stringarray* history(string name, Int n=1);
void gen494(stack *Stack)
{
  Int n=vm::pop<Int>(Stack,1);
  string name=vm::pop<string>(Stack);
#line 5470 "runtime.in"
#if defined(HAVE_LIBREADLINE) && defined(HAVE_LIBCURSES)
  bool newhistory=historyMap.find(name) == historyMap.end();
  
  string filename;
  
  if(newhistory) {
    filename=historyfilename(name);
    std::ifstream exists(filename.c_str());
    if(!exists) {Stack->push<stringarray*>(new array(0)); return;}
  }

  store_history(&history_save);
  HISTORY_STATE& history=historyMap[name].state;
  history_set_history_state(&history);
  
  if(newhistory)
    read_history(filename.c_str());

  array *a=get_history(n);
  
  store_history(&history);
  history_set_history_state(&history_save);
  
  {Stack->push<stringarray*>(a); return;}
#else
  unused(&n);
  {Stack->push<stringarray*>(new array(0)); return;}
#endif
}

// Return the last n lines of the interactive history.
#line 5502 "runtime.in"
// stringarray* history(Int n=0);
void gen495(stack *Stack)
{
  Int n=vm::pop<Int>(Stack,0);
#line 5503 "runtime.in"
#if defined(HAVE_LIBREADLINE) && defined(HAVE_LIBCURSES)
  {Stack->push<stringarray*>(get_history(n)); return;}
#else
  unused(&n);
  {Stack->push<stringarray*>(new array(0)); return;}
#endif
}

// Prompt for a string using prompt, the GNU readline library, and a
// local history named name.
#line 5514 "runtime.in"
// string readline(string prompt=emptystring, string name=emptystring,		bool tabcompletion=false);
void gen496(stack *Stack)
{
  bool tabcompletion=vm::pop<bool>(Stack,false);
  string name=vm::pop<string>(Stack,emptystring);
  string prompt=vm::pop<string>(Stack,emptystring);
#line 5516 "runtime.in"
 if(!isatty(STDIN_FILENO)) 
   {Stack->push<string>(emptystring); return;}
#if defined(HAVE_LIBREADLINE) && defined(HAVE_LIBCURSES)
  init_readline(tabcompletion);
  
  store_history(&history_save);
  bool newhistory=historyMap.find(name) == historyMap.end();
  historyState& h=historyMap[name];
  HISTORY_STATE& history=h.state;
  history_set_history_state(&history);

  if(newhistory)
    read_history(historyfilename(name).c_str());
  
  static char *line=NULL;
  /* Return the memory to the free pool
     if the buffer has already been allocated. */
  if(line) {
    free(line);
    line=NULL;
  }
     
  /* Get a line from the user. */
  line=readline(prompt.c_str());
     
  if(!line) cout << endl;
  
  history_set_history_state(&history_save);

  {Stack->push<string>(line ? string(line) : emptystring); return;}
#else
  cout << prompt;
  string s;
  getline(cin,s);
  unused(&tabcompletion); // Avoid unused variable warning message.
  {Stack->push<string>(s); return;}
#endif
}

// Save a string in a local history named name.
// If store=true, store the local history in the file historyfilename(name).
#line 5558 "runtime.in"
// void saveline(string name, string value, bool store=true);
void gen497(stack *Stack)
{
  bool store=vm::pop<bool>(Stack,true);
  string value=vm::pop<string>(Stack);
  string name=vm::pop<string>(Stack);
#line 5559 "runtime.in"
#if defined(HAVE_LIBREADLINE) && defined(HAVE_LIBCURSES)
  store_history(&history_save);
  bool newhistory=historyMap.find(name) == historyMap.end();
  historyState& h=historyMap[name];
  h.store=store;
  HISTORY_STATE& history=h.state;
  history_set_history_state(&history);

  if(newhistory)
    read_history(historyfilename(name).c_str());
  
  if(value != "") {
    add_history(value.c_str());
    std::ofstream hout(historyfilename(name).c_str(),std::ios::app);
    hout << value << endl;
  }
  
  store_history(&history);
  history_set_history_state(&history_save);
#else
  unused(&store);
#endif	 
}

#line 5584 "runtime.in"
// void generate_random_backtrace();
void gen498(stack *)
{
#line 5585 "runtime.in"
#if defined(USEGC) && defined(GC_DEBUG) && defined(GC_BACKTRACE)
  GC_generate_random_backtrace();
#else
  error("generate_random_backtrace() requires ./configure --enable-gc-debug");
#endif
}

#line 5593 "runtime.in"
// void print_random_addresses(Int n=1);
void gen499(stack *Stack)
{
  Int n=vm::pop<Int>(Stack,1);
#line 5594 "runtime.in"
#if defined(USEGC) && defined(GC_DEBUG) && defined(GC_BACKTRACE)
  GC_gcollect();
  for (Int i=0; i < n; ++i)
    GC_debug_print_heap_obj_proc(GC_base(GC_generate_random_valid_address()));
#else
  error("print_random_addresses() requires ./configure --enable-gc-debug");
  unused(&n); // Avoid unused variable warning message.
#endif
}

} // namespace run

namespace trans {

void gen_base_venv(venv &ve)
{
#line 1009 "runtime.in"
  addFunc(ve, run::gen8, primBoolean(), "!", formal(primBoolean(), "b", false, false));
#line 1037 "runtime.in"
  addFunc(ve, run::gen13, primInt(), "AND", formal(primInt(), "a", false, false), formal(primInt(), "b", false, false));
#line 1045 "runtime.in"
  addFunc(ve, run::gen14, primInt(), "OR", formal(primInt(), "a", false, false), formal(primInt(), "b", false, false));
#line 1050 "runtime.in"
  addFunc(ve, run::gen15, primInt(), "XOR", formal(primInt(), "a", false, false), formal(primInt(), "b", false, false));
#line 1055 "runtime.in"
  addFunc(ve, run::gen16, primInt(), "NOT", formal(primInt(), "a", false, false));
#line 1086 "runtime.in"
  addFunc(ve, run::gen21, primBoolean(), "empty", formal(primPicture(), "f", false, false));
#line 1091 "runtime.in"
  addFunc(ve, run::gen22, primVoid(), "erase", formal(primPicture(), "f", false, false));
#line 1096 "runtime.in"
  addFunc(ve, run::gen23, primPair(), "min", formal(primPicture(), "f", false, false));
#line 1101 "runtime.in"
  addFunc(ve, run::gen24, primPair(), "max", formal(primPicture(), "f", false, false));
#line 1106 "runtime.in"
  addFunc(ve, run::gen25, primVoid(), "label", formal(primPicture(), "f", false, false), formal(primString(), "s", false, false), formal(primString(), "size", false, false), formal(primTransform(), "t", false, false), formal(primPair(), "position", false, false), formal(primPair(), "align", false, false), formal(primPen(), "p", false, false));
#line 1112 "runtime.in"
  addFunc(ve, run::gen26, primBoolean(), "labels", formal(primPicture(), "f", false, false));
#line 1117 "runtime.in"
  addFunc(ve, run::gen27, pathArray()  , "_texpath", formal(primString(), "s", false, false), formal(primPen(), "p", true, false));
#line 1183 "runtime.in"
  addFunc(ve, run::gen28, pathArray()  , "_strokepath", formal(primPath(), "g", false, false), formal(primPen(), "p", true, false));
#line 1207 "runtime.in"
  addFunc(ve, run::gen29, primVoid(), "_draw", formal(primPicture(), "f", false, false), formal(primPath(), "g", false, false), formal(primPen(), "p", false, false));
#line 1212 "runtime.in"
  addFunc(ve, run::gen30, primVoid(), "fill", formal(primPicture(), "f", false, false), formal(pathArray()  , "g", false, false), formal(primPen(), "p", true, false), formal(primBoolean(), "copy", true, false));
#line 1218 "runtime.in"
  addFunc(ve, run::gen31, primVoid(), "latticeshade", formal(primPicture(), "f", false, false), formal(pathArray()  , "g", false, false), formal(primBoolean(), "stroke", true, false), formal(primPen(), "fillrule", false, false), formal(penArray2()  , "p", false, false), formal(primBoolean(), "copy", true, false));
#line 1225 "runtime.in"
  addFunc(ve, run::gen32, primVoid(), "axialshade", formal(primPicture(), "f", false, false), formal(pathArray()  , "g", false, false), formal(primBoolean(), "stroke", true, false), formal(primPen(), "pena", false, false), formal(primPair(), "a", false, false), formal(primPen(), "penb", false, false), formal(primPair(), "b", false, false), formal(primBoolean(), "copy", true, false));
#line 1232 "runtime.in"
  addFunc(ve, run::gen33, primVoid(), "radialshade", formal(primPicture(), "f", false, false), formal(pathArray()  , "g", false, false), formal(primBoolean(), "stroke", true, false), formal(primPen(), "pena", false, false), formal(primPair(), "a", false, false), formal(primReal(), "ra", false, false), formal(primPen(), "penb", false, false), formal(primPair(), "b", false, false), formal(primReal(), "rb", false, false), formal(primBoolean(), "copy", true, false));
#line 1239 "runtime.in"
  addFunc(ve, run::gen34, primVoid(), "gouraudshade", formal(primPicture(), "f", false, false), formal(pathArray()  , "g", false, false), formal(primBoolean(), "stroke", true, false), formal(primPen(), "fillrule", false, false), formal(penArray()  , "p", false, false), formal(pairArray(), "z", false, false), formal(IntArray(), "edges", false, false), formal(primBoolean(), "copy", true, false));
#line 1249 "runtime.in"
  addFunc(ve, run::gen35, primVoid(), "gouraudshade", formal(primPicture(), "f", false, false), formal(pathArray()  , "g", false, false), formal(primBoolean(), "stroke", true, false), formal(primPen(), "fillrule", false, false), formal(penArray()  , "p", false, false), formal(IntArray(), "edges", false, false), formal(primBoolean(), "copy", true, false));
#line 1272 "runtime.in"
  addFunc(ve, run::gen36, primVoid(), "tensorshade", formal(primPicture(), "f", false, false), formal(pathArray()  , "g", false, false), formal(primBoolean(), "stroke", true, false), formal(primPen(), "fillrule", false, false), formal(penArray2()  , "p", false, false), formal(pathArray()  , "b", true, false), formal(pairArray2(), "z", true, false), formal(primBoolean(), "copy", true, false));
#line 1287 "runtime.in"
  addFunc(ve, run::gen37, primVoid(), "clip", formal(primPicture(), "f", false, false), formal(pathArray()  , "g", false, false), formal(primBoolean(), "stroke", true, false), formal(primPen(), "fillrule", false, false), formal(primBoolean(), "copy", true, false));
#line 1297 "runtime.in"
  addFunc(ve, run::gen38, primVoid(), "beginclip", formal(primPicture(), "f", false, false), formal(pathArray()  , "g", false, false), formal(primBoolean(), "stroke", true, false), formal(primPen(), "fillrule", false, false));
#line 1302 "runtime.in"
  addFunc(ve, run::gen39, primVoid(), "endclip", formal(primPicture(), "f", false, false));
#line 1307 "runtime.in"
  addFunc(ve, run::gen40, primVoid(), "gsave", formal(primPicture(), "f", false, false));
#line 1312 "runtime.in"
  addFunc(ve, run::gen41, primVoid(), "grestore", formal(primPicture(), "f", false, false));
#line 1317 "runtime.in"
  addFunc(ve, run::gen42, primVoid(), "begingroup", formal(primPicture(), "f", false, false));
#line 1322 "runtime.in"
  addFunc(ve, run::gen43, primVoid(), "endgroup", formal(primPicture(), "f", false, false));
#line 1327 "runtime.in"
  addFunc(ve, run::gen44, primVoid(), "add", formal(primPicture(), "dest", false, false), formal(primPicture(), "src", false, false));
#line 1332 "runtime.in"
  addFunc(ve, run::gen45, primVoid(), "prepend", formal(primPicture(), "dest", false, false), formal(primPicture(), "src", false, false));
#line 1337 "runtime.in"
  addFunc(ve, run::gen46, primVoid(), "postscript", formal(primPicture(), "f", false, false), formal(primString() , "s", false, false));
#line 1342 "runtime.in"
  addFunc(ve, run::gen47, primVoid(), "tex", formal(primPicture(), "f", false, false), formal(primString() , "s", false, false));
#line 1347 "runtime.in"
  addFunc(ve, run::gen48, primVoid(), "postscript", formal(primPicture(), "f", false, false), formal(primString() , "s", false, false), formal(primPair(), "min", false, false), formal(primPair(), "max", false, false));
#line 1352 "runtime.in"
  addFunc(ve, run::gen49, primVoid(), "tex", formal(primPicture(), "f", false, false), formal(primString() , "s", false, false), formal(primPair(), "min", false, false), formal(primPair(), "max", false, false));
#line 1357 "runtime.in"
  addFunc(ve, run::gen50, primVoid(), "texpreamble", formal(primString() , "s", false, false));
#line 1365 "runtime.in"
  addFunc(ve, run::gen51, primVoid(), "deletepreamble");
#line 1372 "runtime.in"
  addFunc(ve, run::gen52, primVoid(), "_labelpath", formal(primPicture(), "f", false, false), formal(primString() , "s", false, false), formal(primString() , "size", false, false), formal(primPath(), "g", false, false), formal(primString() , "justify", false, false), formal(primPair(), "offset", false, false), formal(primPen(), "p", false, false));
#line 1378 "runtime.in"
  addFunc(ve, run::gen53, primVoid(), "texreset");
#line 1386 "runtime.in"
  addFunc(ve, run::gen54, primVoid(), "layer", formal(primPicture(), "f", false, false));
#line 1391 "runtime.in"
  addFunc(ve, run::gen55, primVoid(), "_image", formal(primPicture(), "f", false, false), formal(realArray2(), "data", false, false), formal(primPair(), "initial", false, false), formal(primPair(), "final", false, false), formal(penArray()  , "palette", true, false), formal(primTransform(), "t", true, false), formal(primBoolean(), "copy", true, false), formal(primBoolean(), "antialias", true, false));
#line 1401 "runtime.in"
  addFunc(ve, run::gen56, primVoid(), "_image", formal(primPicture(), "f", false, false), formal(penArray2()  , "data", false, false), formal(primPair(), "initial", false, false), formal(primPair(), "final", false, false), formal(primTransform(), "t", true, false), formal(primBoolean(), "copy", true, false), formal(primBoolean(), "antialias", true, false));
#line 1408 "runtime.in"
  addFunc(ve, run::gen57, primString() , "nativeformat");
#line 1413 "runtime.in"
  addFunc(ve, run::gen58, primBoolean(), "latex");
#line 1418 "runtime.in"
  addFunc(ve, run::gen59, primBoolean(), "pdf");
#line 1423 "runtime.in"
  addFunc(ve, run::gen60, primVoid(), "shipout", formal(primString() , "prefix", true, false), formal(primPicture(), "f", false, false), formal(primPicture(), "preamble", true, false), formal(primString() , "format", true, false), formal(primBoolean(), "wait", true, false), formal(primBoolean(), "view", true, false), formal(transformFunction(), "xform", false, false));
#line 1469 "runtime.in"
  addFunc(ve, run::gen61, primVoid(), "shipout3", formal(primString() , "prefix", false, false), formal(primPicture(), "f", false, false), formal(primString() , "format", true, false), formal(primReal(), "width", false, false), formal(primReal(), "height", false, false), formal(primReal(), "angle", false, false), formal(primTriple(), "m", false, false), formal(primTriple(), "m", false, false), formal(tripleArray(), "lights", false, false), formal(realArray2(), "diffuse", false, false), formal(realArray2(), "ambient", false, false), formal(realArray2(), "specular", false, false), formal(primBoolean(), "viewportlighting", false, false), formal(primBoolean(), "wait", true, false), formal(primBoolean(), "view", true, false));
#line 1491 "runtime.in"
  addFunc(ve, run::gen62, primVoid(), "shipout3", formal(primString() , "prefix", false, false), formal(primPicture(), "f", false, false));
#line 1496 "runtime.in"
  addFunc(ve, run::gen63, primVoid(), "deconstruct", formal(primPicture(), "f", false, false), formal(primPicture(), "preamble", true, false), formal(primReal(), "magnification", true, false), formal(transformFunction(), "xform", false, false));
#line 1630 "runtime.in"
  addFunc(ve, run::gen64, primVoid(), "purge");
#line 1643 "runtime.in"
  addFunc(ve, run::gen66, primBoolean(), "==", formal(primPen(), "a", false, false), formal(primPen(), "b", false, false));
#line 1648 "runtime.in"
  addFunc(ve, run::gen67, primBoolean(), "!=", formal(primPen(), "a", false, false), formal(primPen(), "b", false, false));
#line 1653 "runtime.in"
  addFunc(ve, run::gen68, primPen(), "+", formal(primPen(), "a", false, false), formal(primPen(), "b", false, false));
#line 1658 "runtime.in"
  addFunc(ve, run::gen69, primPen(), "*", formal(primReal(), "a", false, false), formal(primPen(), "b", false, false));
#line 1663 "runtime.in"
  addFunc(ve, run::gen70, primPen(), "*", formal(primPen(), "a", false, false), formal(primReal(), "b", false, false));
#line 1668 "runtime.in"
  addFunc(ve, run::gen71, primPair(), "max", formal(primPen(), "p", false, false));
#line 1673 "runtime.in"
  addFunc(ve, run::gen72, primPair(), "min", formal(primPen(), "p", false, false));
#line 1678 "runtime.in"
  addFunc(ve, run::gen73, primVoid(), "resetdefaultpen");
#line 1684 "runtime.in"
  addFunc(ve, run::gen74, primVoid(), "defaultpen", formal(primPen(), "p", false, false));
#line 1689 "runtime.in"
  addFunc(ve, run::gen75, primPen(), "defaultpen");
#line 1694 "runtime.in"
  addFunc(ve, run::gen76, primBoolean(), "invisible", formal(primPen(), "p", false, false));
#line 1699 "runtime.in"
  addFunc(ve, run::gen77, primPen(), "invisible");
#line 1704 "runtime.in"
  addFunc(ve, run::gen78, primPen(), "gray", formal(primPen(), "p", false, false));
#line 1711 "runtime.in"
  addFunc(ve, run::gen79, primPen(), "rgb", formal(primPen(), "p", false, false));
#line 1718 "runtime.in"
  addFunc(ve, run::gen80, primPen(), "rgb", formal(primReal(), "r", false, false), formal(primReal(), "g", false, false), formal(primReal(), "b", false, false));
#line 1723 "runtime.in"
  addFunc(ve, run::gen81, primPen(), "cmyk", formal(primReal(), "c", false, false), formal(primReal(), "m", false, false), formal(primReal(), "y", false, false), formal(primReal(), "k", false, false));
#line 1728 "runtime.in"
  addFunc(ve, run::gen82, primPen(), "gray", formal(primReal(), "gray", false, false));
#line 1733 "runtime.in"
  addFunc(ve, run::gen83, realArray(), "colors", formal(primPen(), "p", false, false));
#line 1761 "runtime.in"
  addFunc(ve, run::gen84, primString() , "colorspace", formal(primPen(), "p", false, false));
#line 1768 "runtime.in"
  addFunc(ve, run::gen85, primPen(), "pattern", formal(primString(), "s", false, false));
#line 1773 "runtime.in"
  addFunc(ve, run::gen86, primString() , "pattern", formal(primPen(), "p", false, false));
#line 1778 "runtime.in"
  addFunc(ve, run::gen87, primPen(), "fillrule", formal(primInt(), "n", false, false));
#line 1783 "runtime.in"
  addFunc(ve, run::gen88, primInt(), "fillrule", formal(primPen(), "p", false, false));
#line 1788 "runtime.in"
  addFunc(ve, run::gen89, primPen(), "opacity", formal(primReal(), "opacity", true, false), formal(primString() , "blend", true, false));
#line 1798 "runtime.in"
  addFunc(ve, run::gen90, primReal(), "opacity", formal(primPen(), "p", false, false));
#line 1803 "runtime.in"
  addFunc(ve, run::gen91, primString() , "blend", formal(primPen(), "p", false, false));
#line 1808 "runtime.in"
  addFunc(ve, run::gen92, primPen(), "linetype", formal(primString(), "s", false, false), formal(primReal(), "offset", true, false), formal(primBoolean(), "scale", true, false), formal(primBoolean(), "adjust", true, false));
#line 1813 "runtime.in"
  addFunc(ve, run::gen93, primString() , "linetype", formal(primPen(), "p", false, false));
#line 1818 "runtime.in"
  addFunc(ve, run::gen94, primReal(), "offset", formal(primPen(), "p", false, false));
#line 1823 "runtime.in"
  addFunc(ve, run::gen95, primBoolean(), "scale", formal(primPen(), "p", false, false));
#line 1828 "runtime.in"
  addFunc(ve, run::gen96, primBoolean(), "adjust", formal(primPen(), "p", false, false));
#line 1833 "runtime.in"
  addFunc(ve, run::gen97, primPen(), "adjust", formal(primPen(), "p", false, false), formal(primReal(), "arclength", false, false), formal(primBoolean(), "cyclic", false, false));
#line 1838 "runtime.in"
  addFunc(ve, run::gen98, primPen(), "linecap", formal(primInt(), "n", false, false));
#line 1843 "runtime.in"
  addFunc(ve, run::gen99, primInt(), "linecap", formal(primPen(), "p", false, false));
#line 1848 "runtime.in"
  addFunc(ve, run::gen100, primPen(), "linejoin", formal(primInt(), "n", false, false));
#line 1853 "runtime.in"
  addFunc(ve, run::gen101, primInt(), "linejoin", formal(primPen(), "p", false, false));
#line 1858 "runtime.in"
  addFunc(ve, run::gen102, primPen(), "linewidth", formal(primReal(), "x", false, false));
#line 1863 "runtime.in"
  addFunc(ve, run::gen103, primReal(), "linewidth", formal(primPen(), "p", false, false));
#line 1868 "runtime.in"
  addFunc(ve, run::gen104, primPen(), "fontcommand", formal(primString(), "s", false, false));
#line 1873 "runtime.in"
  addFunc(ve, run::gen105, primString() , "font", formal(primPen(), "p", false, false));
#line 1878 "runtime.in"
  addFunc(ve, run::gen106, primPen(), "fontsize", formal(primReal(), "size", false, false), formal(primReal(), "lineskip", false, false));
#line 1884 "runtime.in"
  addFunc(ve, run::gen107, primReal(), "fontsize", formal(primPen(), "p", false, false));
#line 1889 "runtime.in"
  addFunc(ve, run::gen108, primReal(), "lineskip", formal(primPen(), "p", false, false));
#line 1894 "runtime.in"
  addFunc(ve, run::gen109, primPen(), "overwrite", formal(primInt(), "n", false, false));
#line 1900 "runtime.in"
  addFunc(ve, run::gen110, primInt(), "overwrite", formal(primPen(), "p", false, false));
#line 1905 "runtime.in"
  addFunc(ve, run::gen111, primPen(), "basealign", formal(primInt(), "n", false, false));
#line 1910 "runtime.in"
  addFunc(ve, run::gen112, primInt(), "basealign", formal(primPen(), "p", false, false));
#line 1915 "runtime.in"
  addFunc(ve, run::gen113, primTransform(), "transform", formal(primPen(), "p", false, false));
#line 1920 "runtime.in"
  addFunc(ve, run::gen114, primPath(), "nib", formal(primPen(), "p", false, false));
#line 1925 "runtime.in"
  addFunc(ve, run::gen115, primPen(), "makepen", formal(primPath(), "p", false, false));
#line 1930 "runtime.in"
  addFunc(ve, run::gen116, primPen(), "colorless", formal(primPen(), "p", false, false));
#line 1936 "runtime.in"
  addFunc(ve, run::gen117, primBoolean(), "interactive");
#line 1943 "runtime.in"
  addFunc(ve, run::gen118, primBoolean(), "uptodate");
#line 1948 "runtime.in"
  addFunc(ve, run::gen119, primInt(), "system", formal(primString() , "s", false, false));
#line 1958 "runtime.in"
  addFunc(ve, run::gen120, primBoolean(), "view");
#line 1963 "runtime.in"
  addFunc(ve, run::gen121, primString() , "asydir");
#line 1968 "runtime.in"
  addFunc(ve, run::gen122, primString() , "locale", formal(primString() , "s", true, false));
#line 1974 "runtime.in"
  addFunc(ve, run::gen123, primVoid(), "abort", formal(primString() , "s", true, false));
#line 1980 "runtime.in"
  addFunc(ve, run::gen124, primVoid(), "exit");
#line 1985 "runtime.in"
  addFunc(ve, run::gen125, primVoid(), "assert", formal(primBoolean(), "b", false, false), formal(primString() , "s", true, false));
#line 1996 "runtime.in"
  addFunc(ve, run::gen126, primVoid(), "sleep", formal(primInt(), "seconds", false, false));
#line 2002 "runtime.in"
  addFunc(ve, run::gen127, primVoid(), "usleep", formal(primInt(), "microseconds", false, false));
#line 2008 "runtime.in"
  addFunc(ve, run::gen128, primVoid(), "_eval", formal(primString(), "s", false, false), formal(primBoolean(), "embedded", false, false), formal(primBoolean(), "interactivewrite", true, false));
#line 2023 "runtime.in"
  addFunc(ve, run::gen129, primVoid(), "_eval", formal(primCode(), "s", false, false), formal(primBoolean(), "embedded", false, false));
#line 2041 "runtime.in"
  addFunc(ve, run::gen130, primString() , "location");
#line 2053 "runtime.in"
  addFunc(ve, run::gen132, primString() , "cd", formal(primString() , "s", true, false));
#line 2059 "runtime.in"
  addFunc(ve, run::gen133, primVoid(), "list", formal(primString(), "s", false, false), formal(primBoolean(), "imports", true, false));
#line 2076 "runtime.in"
  addFunc(ve, run::gen135, primBoolean(), "==", formal(primPath(), "a", false, false), formal(primPath(), "b", false, false));
#line 2081 "runtime.in"
  addFunc(ve, run::gen136, primBoolean(), "!=", formal(primPath(), "a", false, false), formal(primPath(), "b", false, false));
#line 2086 "runtime.in"
  addFunc(ve, run::gen137, primPair(), "point", formal(primPath(), "p", false, false), formal(primInt(), "t", false, false));
#line 2091 "runtime.in"
  addFunc(ve, run::gen138, primPair(), "point", formal(primPath(), "p", false, false), formal(primReal(), "t", false, false));
#line 2096 "runtime.in"
  addFunc(ve, run::gen139, primPair(), "precontrol", formal(primPath(), "p", false, false), formal(primInt(), "t", false, false));
#line 2101 "runtime.in"
  addFunc(ve, run::gen140, primPair(), "precontrol", formal(primPath(), "p", false, false), formal(primReal(), "t", false, false));
#line 2106 "runtime.in"
  addFunc(ve, run::gen141, primPair(), "postcontrol", formal(primPath(), "p", false, false), formal(primInt(), "t", false, false));
#line 2111 "runtime.in"
  addFunc(ve, run::gen142, primPair(), "postcontrol", formal(primPath(), "p", false, false), formal(primReal(), "t", false, false));
#line 2116 "runtime.in"
  addFunc(ve, run::gen143, primPair(), "dir", formal(primPath(), "p", false, false), formal(primInt(), "t", false, false), formal(primInt(), "sign", true, false), formal(primBoolean(), "normalize", true, false));
#line 2121 "runtime.in"
  addFunc(ve, run::gen144, primPair(), "dir", formal(primPath(), "p", false, false), formal(primReal(), "t", false, false), formal(primBoolean(), "normalize", true, false));
#line 2126 "runtime.in"
  addFunc(ve, run::gen145, primPair(), "accel", formal(primPath(), "p", false, false), formal(primInt(), "t", false, false), formal(primInt(), "sign", true, false));
#line 2131 "runtime.in"
  addFunc(ve, run::gen146, primPair(), "accel", formal(primPath(), "p", false, false), formal(primReal(), "t", false, false));
#line 2136 "runtime.in"
  addFunc(ve, run::gen147, primReal(), "radius", formal(primPath(), "p", false, false), formal(primReal(), "t", false, false));
#line 2148 "runtime.in"
  addFunc(ve, run::gen148, primPath(), "reverse", formal(primPath(), "p", false, false));
#line 2153 "runtime.in"
  addFunc(ve, run::gen149, primPath(), "subpath", formal(primPath(), "p", false, false), formal(primInt(), "a", false, false), formal(primInt(), "b", false, false));
#line 2158 "runtime.in"
  addFunc(ve, run::gen150, primPath(), "subpath", formal(primPath(), "p", false, false), formal(primReal(), "a", false, false), formal(primReal(), "b", false, false));
#line 2163 "runtime.in"
  addFunc(ve, run::gen151, primPath(), "nurb", formal(primPair(), "z0", false, false), formal(primPair(), "z1", false, false), formal(primPair(), "z2", false, false), formal(primPair(), "z3", false, false), formal(primReal(), "w0", false, false), formal(primReal(), "w1", false, false), formal(primReal(), "w2", false, false), formal(primReal(), "w3", false, false), formal(primInt(), "m", false, false));
#line 2169 "runtime.in"
  addFunc(ve, run::gen152, primInt(), "length", formal(primPath(), "p", false, false));
#line 2174 "runtime.in"
  addFunc(ve, run::gen153, primBoolean(), "cyclic", formal(primPath(), "p", false, false));
#line 2179 "runtime.in"
  addFunc(ve, run::gen154, primBoolean(), "straight", formal(primPath(), "p", false, false), formal(primInt(), "t", false, false));
#line 2184 "runtime.in"
  addFunc(ve, run::gen155, primPath(), "unstraighten", formal(primPath(), "p", false, false));
#line 2189 "runtime.in"
  addFunc(ve, run::gen156, primBoolean(), "piecewisestraight", formal(primPath(), "p", false, false));
#line 2194 "runtime.in"
  addFunc(ve, run::gen157, primReal(), "arclength", formal(primPath(), "p", false, false));
#line 2199 "runtime.in"
  addFunc(ve, run::gen158, primReal(), "arctime", formal(primPath(), "p", false, false), formal(primReal(), "dval", false, false));
#line 2204 "runtime.in"
  addFunc(ve, run::gen159, primReal(), "dirtime", formal(primPath(), "p", false, false), formal(primPair(), "z", false, false));
#line 2209 "runtime.in"
  addFunc(ve, run::gen160, realArray(), "intersect", formal(primPath(), "p", false, false), formal(primPath(), "q", false, false), formal(primReal(), "fuzz", true, false));
#line 2225 "runtime.in"
  addFunc(ve, run::gen161, realArray2(), "intersections", formal(primPath(), "p", false, false), formal(primPath(), "q", false, false), formal(primReal(), "fuzz", true, false));
#line 2245 "runtime.in"
  addFunc(ve, run::gen162, realArray(), "intersections", formal(primPath(), "p", false, false), formal(primPair(), "a", false, false), formal(primPair(), "b", false, false), formal(primReal(), "fuzz", true, false));
#line 2260 "runtime.in"
  addFunc(ve, run::gen163, primInt(), "size", formal(primPath(), "p", false, false));
#line 2265 "runtime.in"
  addFunc(ve, run::gen164, primPath(), "&", formal(primPath(), "p", false, false), formal(primPath(), "q", false, false));
#line 2270 "runtime.in"
  addFunc(ve, run::gen165, primPair(), "min", formal(primPath(), "p", false, false));
#line 2275 "runtime.in"
  addFunc(ve, run::gen166, primPair(), "max", formal(primPath(), "p", false, false));
#line 2280 "runtime.in"
  addFunc(ve, run::gen167, realArray(), "mintimes", formal(primPath(), "p", false, false));
#line 2289 "runtime.in"
  addFunc(ve, run::gen168, realArray(), "maxtimes", formal(primPath(), "p", false, false));
#line 2298 "runtime.in"
  addFunc(ve, run::gen169, primReal(), "relativedistance", formal(primReal(), "theta", false, false), formal(primReal(), "phi", false, false), formal(primReal(), "t", false, false), formal(primBoolean(), "atleast", false, false));
#line 2303 "runtime.in"
  addFunc(ve, run::gen170, primInt(), "windingnumber", formal(pathArray()  , "p", false, false), formal(primPair(), "z", false, false));
#line 2308 "runtime.in"
  addFunc(ve, run::gen171, primBoolean(), "inside", formal(pathArray()  , "g", false, true), formal(primPair(), "z", false, false), formal(primPen(), "fillrule", true, false));
#line 2313 "runtime.in"
  addFunc(ve, run::gen172, primBoolean(), "inside", formal(primPath(), "g", false, false), formal(primPair(), "z", false, false), formal(primPen(), "fillrule", true, false));
#line 2318 "runtime.in"
  addFunc(ve, run::gen173, primReal(), "side", formal(primPair(), "a", false, false), formal(primPair(), "b", false, false), formal(primPair(), "c", false, false));
#line 2325 "runtime.in"
  addFunc(ve, run::gen174, primReal(), "incircle", formal(primPair(), "a", false, false), formal(primPair(), "b", false, false), formal(primPair(), "c", false, false), formal(primPair(), "d", false, false));
#line 2333 "runtime.in"
  addFunc(ve, run::gen175, primPath3(), "path3", formal(tripleArray(), "pre", false, false), formal(tripleArray(), "point", false, false), formal(tripleArray(), "post", false, false), formal(boolArray(), "straight", false, false), formal(primBoolean(), "cyclic", false, false));
#line 2358 "runtime.in"
  addFunc(ve, run::gen177, primBoolean(), "==", formal(primPath3(), "a", false, false), formal(primPath3(), "b", false, false));
#line 2363 "runtime.in"
  addFunc(ve, run::gen178, primBoolean(), "!=", formal(primPath3(), "a", false, false), formal(primPath3(), "b", false, false));
#line 2368 "runtime.in"
  addFunc(ve, run::gen179, primTriple(), "point", formal(primPath3(), "p", false, false), formal(primInt(), "t", false, false));
#line 2373 "runtime.in"
  addFunc(ve, run::gen180, primTriple(), "point", formal(primPath3(), "p", false, false), formal(primReal(), "t", false, false));
#line 2378 "runtime.in"
  addFunc(ve, run::gen181, primTriple(), "precontrol", formal(primPath3(), "p", false, false), formal(primInt(), "t", false, false));
#line 2383 "runtime.in"
  addFunc(ve, run::gen182, primTriple(), "precontrol", formal(primPath3(), "p", false, false), formal(primReal(), "t", false, false));
#line 2388 "runtime.in"
  addFunc(ve, run::gen183, primTriple(), "postcontrol", formal(primPath3(), "p", false, false), formal(primInt(), "t", false, false));
#line 2393 "runtime.in"
  addFunc(ve, run::gen184, primTriple(), "postcontrol", formal(primPath3(), "p", false, false), formal(primReal(), "t", false, false));
#line 2398 "runtime.in"
  addFunc(ve, run::gen185, primTriple(), "dir", formal(primPath3(), "p", false, false), formal(primInt(), "t", false, false), formal(primInt(), "sign", true, false), formal(primBoolean(), "normalize", true, false));
#line 2403 "runtime.in"
  addFunc(ve, run::gen186, primTriple(), "dir", formal(primPath3(), "p", false, false), formal(primReal(), "t", false, false), formal(primBoolean(), "normalize", true, false));
#line 2408 "runtime.in"
  addFunc(ve, run::gen187, primTriple(), "accel", formal(primPath3(), "p", false, false), formal(primInt(), "t", false, false), formal(primInt(), "sign", true, false));
#line 2413 "runtime.in"
  addFunc(ve, run::gen188, primTriple(), "accel", formal(primPath3(), "p", false, false), formal(primReal(), "t", false, false));
#line 2418 "runtime.in"
  addFunc(ve, run::gen189, primReal(), "radius", formal(primPath3(), "p", false, false), formal(primReal(), "t", false, false));
#line 2430 "runtime.in"
  addFunc(ve, run::gen190, primPath3(), "reverse", formal(primPath3(), "p", false, false));
#line 2435 "runtime.in"
  addFunc(ve, run::gen191, primPath3(), "subpath", formal(primPath3(), "p", false, false), formal(primInt(), "a", false, false), formal(primInt(), "b", false, false));
#line 2440 "runtime.in"
  addFunc(ve, run::gen192, primPath3(), "subpath", formal(primPath3(), "p", false, false), formal(primReal(), "a", false, false), formal(primReal(), "b", false, false));
#line 2445 "runtime.in"
  addFunc(ve, run::gen193, primInt(), "length", formal(primPath3(), "p", false, false));
#line 2450 "runtime.in"
  addFunc(ve, run::gen194, primBoolean(), "cyclic", formal(primPath3(), "p", false, false));
#line 2455 "runtime.in"
  addFunc(ve, run::gen195, primBoolean(), "straight", formal(primPath3(), "p", false, false), formal(primInt(), "t", false, false));
#line 2460 "runtime.in"
  addFunc(ve, run::gen196, primReal(), "straightness", formal(primPath3(), "p", false, false), formal(primInt(), "t", false, false));
#line 2471 "runtime.in"
  addFunc(ve, run::gen197, primBoolean(), "piecewisestraight", formal(primPath3(), "p", false, false));
#line 2476 "runtime.in"
  addFunc(ve, run::gen198, primReal(), "arclength", formal(primPath3(), "p", false, false));
#line 2481 "runtime.in"
  addFunc(ve, run::gen199, primReal(), "arctime", formal(primPath3(), "p", false, false), formal(primReal(), "dval", false, false));
#line 2486 "runtime.in"
  addFunc(ve, run::gen200, realArray(), "intersect", formal(primPath3(), "p", false, false), formal(primPath3(), "q", false, false), formal(primReal(), "fuzz", true, false));
#line 2502 "runtime.in"
  addFunc(ve, run::gen201, realArray2(), "intersections", formal(primPath3(), "p", false, false), formal(primPath3(), "q", false, false), formal(primReal(), "fuzz", true, false));
#line 2522 "runtime.in"
  addFunc(ve, run::gen202, primInt(), "size", formal(primPath3(), "p", false, false));
#line 2527 "runtime.in"
  addFunc(ve, run::gen203, primPath3(), "&", formal(primPath3(), "p", false, false), formal(primPath3(), "q", false, false));
#line 2532 "runtime.in"
  addFunc(ve, run::gen204, primTriple(), "min", formal(primPath3(), "p", false, false));
#line 2537 "runtime.in"
  addFunc(ve, run::gen205, primTriple(), "max", formal(primPath3(), "p", false, false));
#line 2542 "runtime.in"
  addFunc(ve, run::gen206, realArray(), "mintimes", formal(primPath3(), "p", false, false));
#line 2552 "runtime.in"
  addFunc(ve, run::gen207, realArray(), "maxtimes", formal(primPath3(), "p", false, false));
#line 2562 "runtime.in"
  addFunc(ve, run::gen208, primPath3(), "*", formal(realArray2(), "t", false, false), formal(primPath3(), "g", false, false));
#line 2617 "runtime.in"
  addFunc(ve, run::gen213, primGuide(), "operator cast", formal(primCycleToken(), "tok", false, false));
#line 2624 "runtime.in"
  addFunc(ve, run::gen214, primGuide(), "operator spec", formal(primPair(), "z", false, false), formal(primInt(), "p", false, false));
#line 2632 "runtime.in"
  addFunc(ve, run::gen215, primCurlSpecifier(), "operator curl", formal(primReal(), "gamma", false, false), formal(primInt(), "p", false, false));
#line 2648 "runtime.in"
  addFunc(ve, run::gen218, primGuide(), "operator cast", formal(primCurlSpecifier(), "spec", false, false));
#line 2653 "runtime.in"
  addFunc(ve, run::gen219, primTensionSpecifier(), "operator tension", formal(primReal(), "tout", false, false), formal(primReal(), "tin", false, false), formal(primBoolean(), "atleast", false, false));
#line 2673 "runtime.in"
  addFunc(ve, run::gen223, primGuide(), "operator cast", formal(primTensionSpecifier(), "t", false, false));
#line 2678 "runtime.in"
  addFunc(ve, run::gen224, primGuide(), "operator controls", formal(primPair(), "zout", false, false), formal(primPair(), "zin", false, false));
#line 2683 "runtime.in"
  addFunc(ve, run::gen225, primInt(), "size", formal(primGuide(), "g", false, false));
#line 2690 "runtime.in"
  addFunc(ve, run::gen226, primInt(), "length", formal(primGuide(), "g", false, false));
#line 2697 "runtime.in"
  addFunc(ve, run::gen227, primBoolean(), "cyclic", formal(primGuide(), "g", false, false));
#line 2704 "runtime.in"
  addFunc(ve, run::gen228, primPair(), "point", formal(primGuide(), "g", false, false), formal(primInt(), "t", false, false));
#line 2711 "runtime.in"
  addFunc(ve, run::gen229, pairArray(), "dirSpecifier", formal(primGuide(), "g", false, false), formal(primInt(), "t", false, false));
#line 2728 "runtime.in"
  addFunc(ve, run::gen230, pairArray(), "controlSpecifier", formal(primGuide(), "g", false, false), formal(primInt(), "t", false, false));
#line 2747 "runtime.in"
  addFunc(ve, run::gen231, primTensionSpecifier(), "tensionSpecifier", formal(primGuide(), "g", false, false), formal(primInt(), "t", false, false));
#line 2759 "runtime.in"
  addFunc(ve, run::gen232, realArray(), "curlSpecifier", formal(primGuide(), "g", false, false));
#line 2772 "runtime.in"
  addFunc(ve, run::gen233, primGuide(), "reverse", formal(primGuide(), "g", false, false));
#line 2823 "runtime.in"
  addFunc(ve, run::gen234, primVoid(), "_draw", formal(primPicture(), "f", false, false), formal(primPath3(), "g", false, false), formal(primPen(), "p", false, false));
#line 2831 "runtime.in"
  addFunc(ve, run::gen235, primVoid(), "draw", formal(primPicture(), "f", false, false), formal(tripleArray2(), "g", false, false), formal(primBoolean(), "straight", false, false), formal(penArray()  , "p", false, false), formal(primReal(), "opacity", false, false), formal(primReal(), "shininess", false, false), formal(primReal(), "granularity", false, false), formal(primTriple(), "normal", false, false), formal(primBoolean(), "lighton", false, false), formal(penArray()  , "colors", false, false));
#line 2839 "runtime.in"
  addFunc(ve, run::gen236, primTriple(), "min3", formal(primPicture(), "f", false, false));
#line 2844 "runtime.in"
  addFunc(ve, run::gen237, primTriple(), "max3", formal(primPicture(), "f", false, false));
#line 2849 "runtime.in"
  addFunc(ve, run::gen238, primPair(), "min", formal(primPicture(), "f", false, false), formal(realArray2(), "t", false, false));
#line 2857 "runtime.in"
  addFunc(ve, run::gen239, primPair(), "max", formal(primPicture(), "f", false, false), formal(realArray2(), "t", false, false));
#line 2865 "runtime.in"
  addFunc(ve, run::gen240, primPair(), "minratio", formal(primPicture(), "f", false, false));
#line 2870 "runtime.in"
  addFunc(ve, run::gen241, primPair(), "maxratio", formal(primPicture(), "f", false, false));
#line 2875 "runtime.in"
  addFunc(ve, run::gen242, primReal(), "minbound", formal(realArray(), "a", false, false), formal(primReal(), "b", false, false));
#line 2883 "runtime.in"
  addFunc(ve, run::gen243, primReal(), "maxbound", formal(realArray(), "a", false, false), formal(primReal(), "b", false, false));
#line 2891 "runtime.in"
  addFunc(ve, run::gen244, primPair(), "minbound", formal(tripleArray(), "a", false, false), formal(realArray2(), "t", false, false), formal(primPair(), "b", false, false));
#line 2902 "runtime.in"
  addFunc(ve, run::gen245, primPair(), "maxbound", formal(tripleArray(), "a", false, false), formal(realArray2(), "t", false, false), formal(primPair(), "b", false, false));
#line 2913 "runtime.in"
  addFunc(ve, run::gen246, primPair(), "max", formal(primPath3(), "g", false, false), formal(realArray2(), "t", false, false));
#line 2921 "runtime.in"
  addFunc(ve, run::gen247, primPair(), "min", formal(primPath3(), "g", false, false), formal(realArray2(), "t", false, false));
#line 2929 "runtime.in"
  addFunc(ve, run::gen248, primReal(), "change2", formal(tripleArray2(), "a", false, false));
#line 2951 "runtime.in"
  addFunc(ve, run::gen249, primBoolean(), "is3D", formal(primPicture(), "f", false, false));
#line 2956 "runtime.in"
  addFunc(ve, run::gen250, primTriple(), "bezier", formal(primTriple(), "a", false, false), formal(primTriple(), "b", false, false), formal(primTriple(), "c", false, false), formal(primTriple(), "d", false, false), formal(primReal(), "t", false, false));
#line 2963 "runtime.in"
  addFunc(ve, run::gen251, primTriple(), "bezierP", formal(primTriple(), "a", false, false), formal(primTriple(), "b", false, false), formal(primTriple(), "c", false, false), formal(primTriple(), "d", false, false), formal(primReal(), "t", false, false));
#line 2968 "runtime.in"
  addFunc(ve, run::gen252, primTriple(), "bezierPP", formal(primTriple(), "a", false, false), formal(primTriple(), "b", false, false), formal(primTriple(), "c", false, false), formal(primTriple(), "d", false, false), formal(primReal(), "t", false, false));
#line 2973 "runtime.in"
  addFunc(ve, run::gen253, primTriple(), "bezierPPP", formal(primTriple(), "a", false, false), formal(primTriple(), "b", false, false), formal(primTriple(), "c", false, false), formal(primTriple(), "d", false, false));
#line 2986 "runtime.in"
  addFunc(ve, run::gen255, primInt(), "length", formal(primString(), "s", false, false));
#line 2991 "runtime.in"
  addFunc(ve, run::gen256, primInt(), "find", formal(primString(), "s", false, false), formal(primString() , "t", false, false), formal(primInt(), "pos", true, false));
#line 2997 "runtime.in"
  addFunc(ve, run::gen257, primInt(), "rfind", formal(primString(), "s", false, false), formal(primString() , "t", false, false), formal(primInt(), "pos", true, false));
#line 3003 "runtime.in"
  addFunc(ve, run::gen258, primString() , "reverse", formal(primString() , "s", false, false));
#line 3009 "runtime.in"
  addFunc(ve, run::gen259, primString() , "insert", formal(primString() , "s", false, false), formal(primInt(), "pos", false, false), formal(primString() , "t", false, false));
#line 3016 "runtime.in"
  addFunc(ve, run::gen260, primString() , "substr", formal(primString(), "s", false, false), formal(primInt(), "pos", false, false), formal(primInt(), "n", true, false));
#line 3023 "runtime.in"
  addFunc(ve, run::gen261, primString() , "erase", formal(primString() , "s", false, false), formal(primInt(), "pos", false, false), formal(primInt(), "n", false, false));
#line 3030 "runtime.in"
  addFunc(ve, run::gen262, primString() , "downcase", formal(primString() , "s", false, false));
#line 3036 "runtime.in"
  addFunc(ve, run::gen263, primString() , "upcase", formal(primString() , "s", false, false));
#line 3042 "runtime.in"
  addFunc(ve, run::gen264, primString() , "replace", formal(primString(), "s", false, false), formal(stringArray2(), "translate", false, false));
#line 3069 "runtime.in"
  addFunc(ve, run::gen265, primString() , "format", formal(primString(), "format", false, false), formal(primInt(), "x", false, false));
#line 3084 "runtime.in"
  addFunc(ve, run::gen266, primString() , "format", formal(primString(), "format", false, false), formal(primReal(), "x", false, false), formal(primString() , "locale", true, false));
#line 3201 "runtime.in"
  addFunc(ve, run::gen267, primString() , "string", formal(primInt(), "x", false, false));
#line 3208 "runtime.in"
  addFunc(ve, run::gen268, primString() , "string", formal(primReal(), "x", false, false), formal(primInt(), "digits", true, false));
#line 3216 "runtime.in"
  addFunc(ve, run::gen269, primString() , "time", formal(primString() , "format", true, false));
#line 3227 "runtime.in"
  addFunc(ve, run::gen270, primString() , "time", formal(primInt(), "seconds", false, false), formal(primString() , "format", true, false));
#line 3240 "runtime.in"
  addFunc(ve, run::gen271, primInt(), "seconds", formal(primString() , "t", true, false), formal(primString() , "format", true, false));
#line 3252 "runtime.in"
  addFunc(ve, run::gen272, realArray(), "_cputime");
#line 3266 "runtime.in"
  addFunc(ve, run::gen273, primReal(), "^", formal(primReal(), "x", false, false), formal(primInt(), "y", false, false));
#line 3274 "runtime.in"
  addFunc(ve, run::gen274, primPair(), "^", formal(primPair(), "z", false, false), formal(primInt(), "y", false, false));
#line 3279 "runtime.in"
  addFunc(ve, run::gen275, primInt(), "quotient", formal(primInt(), "x", false, false), formal(primInt(), "y", false, false));
#line 3287 "runtime.in"
  addFunc(ve, run::gen276, primInt(), "abs", formal(primInt(), "x", false, false));
#line 3292 "runtime.in"
  addFunc(ve, run::gen277, primInt(), "sgn", formal(primReal(), "x", false, false));
#line 3297 "runtime.in"
  addFunc(ve, run::gen278, primInt(), "rand");
#line 3302 "runtime.in"
  addFunc(ve, run::gen279, primVoid(), "srand", formal(primInt(), "seed", false, false));
#line 3307 "runtime.in"
  addFunc(ve, run::gen280, primReal(), "unitrand");
#line 3313 "runtime.in"
  addFunc(ve, run::gen281, primInt(), "ceil", formal(primReal(), "x", false, false));
#line 3318 "runtime.in"
  addFunc(ve, run::gen282, primInt(), "floor", formal(primReal(), "x", false, false));
#line 3323 "runtime.in"
  addFunc(ve, run::gen283, primInt(), "round", formal(primReal(), "x", false, false));
#line 3329 "runtime.in"
  addFunc(ve, run::gen284, primInt(), "Ceil", formal(primReal(), "x", false, false));
#line 3334 "runtime.in"
  addFunc(ve, run::gen285, primInt(), "Floor", formal(primReal(), "x", false, false));
#line 3339 "runtime.in"
  addFunc(ve, run::gen286, primInt(), "Round", formal(primReal(), "x", false, false));
#line 3344 "runtime.in"
  addFunc(ve, run::gen287, primReal(), "fmod", formal(primReal(), "x", false, false), formal(primReal(), "y", false, false));
#line 3350 "runtime.in"
  addFunc(ve, run::gen288, primReal(), "atan2", formal(primReal(), "y", false, false), formal(primReal(), "x", false, false));
#line 3355 "runtime.in"
  addFunc(ve, run::gen289, primReal(), "hypot", formal(primReal(), "x", false, false), formal(primReal(), "y", false, false));
#line 3360 "runtime.in"
  addFunc(ve, run::gen290, primReal(), "remainder", formal(primReal(), "x", false, false), formal(primReal(), "y", false, false));
#line 3365 "runtime.in"
  addFunc(ve, run::gen291, primReal(), "J", formal(primInt(), "n", false, false), formal(primReal(), "x", false, false));
#line 3370 "runtime.in"
  addFunc(ve, run::gen292, primReal(), "Y", formal(primInt(), "n", false, false), formal(primReal(), "x", false, false));
#line 3375 "runtime.in"
  addFunc(ve, run::gen293, primReal(), "erf", formal(primReal(), "x", false, false));
#line 3380 "runtime.in"
  addFunc(ve, run::gen294, primReal(), "erfc", formal(primReal(), "x", false, false));
#line 3385 "runtime.in"
  addFunc(ve, run::gen295, primReal(), "gamma", formal(primReal(), "x", false, false));
#line 3395 "runtime.in"
  addFunc(ve, run::gen296, realArray(), "quadraticroots", formal(primReal(), "a", false, false), formal(primReal(), "b", false, false), formal(primReal(), "c", false, false));
#line 3404 "runtime.in"
  addFunc(ve, run::gen297, pairArray(), "quadraticroots", formal(primPair(), "a", false, true), formal(primPair(), "b", false, true), formal(primPair(), "c", false, true));
#line 3413 "runtime.in"
  addFunc(ve, run::gen298, realArray(), "cubicroots", formal(primReal(), "a", false, false), formal(primReal(), "b", false, false), formal(primReal(), "c", false, false), formal(primReal(), "d", false, false));
#line 3423 "runtime.in"
  addFunc(ve, run::gen299, primBoolean(), "==", formal(primTransform(), "a", false, false), formal(primTransform(), "b", false, false));
#line 3431 "runtime.in"
  addFunc(ve, run::gen300, primBoolean(), "!=", formal(primTransform(), "a", false, false), formal(primTransform(), "b", false, false));
#line 3436 "runtime.in"
  addFunc(ve, run::gen301, primTransform(), "+", formal(primTransform(), "a", false, false), formal(primTransform(), "b", false, false));
#line 3441 "runtime.in"
  addFunc(ve, run::gen302, primTransform(), "*", formal(primTransform(), "a", false, false), formal(primTransform(), "b", false, false));
#line 3446 "runtime.in"
  addFunc(ve, run::gen303, primPair(), "*", formal(primTransform(), "t", false, false), formal(primPair(), "z", false, false));
#line 3451 "runtime.in"
  addFunc(ve, run::gen304, primPath(), "*", formal(primTransform(), "t", false, false), formal(primPath(), "g", false, false));
#line 3456 "runtime.in"
  addFunc(ve, run::gen305, primPen(), "*", formal(primTransform(), "t", false, false), formal(primPen(), "p", false, false));
#line 3461 "runtime.in"
  addFunc(ve, run::gen306, primPicture(), "*", formal(primTransform(), "t", false, false), formal(primPicture(), "f", false, false));
#line 3466 "runtime.in"
  addFunc(ve, run::gen307, primPicture(), "*", formal(realArray2(), "t", false, false), formal(primPicture(), "f", false, false));
#line 3471 "runtime.in"
  addFunc(ve, run::gen308, primTransform(), "^", formal(primTransform(), "t", false, false), formal(primInt(), "n", false, false));
#line 3518 "runtime.in"
  addFunc(ve, run::gen316, primTransform(), "shift", formal(primTransform(), "t", false, false));
#line 3523 "runtime.in"
  addFunc(ve, run::gen317, primTransform(), "shiftless", formal(primTransform(), "t", false, false));
#line 3528 "runtime.in"
  addFunc(ve, run::transformIdentity, primTransform(), "identity");
#line 3533 "runtime.in"
  addFunc(ve, run::gen319, primTransform(), "inverse", formal(primTransform(), "t", false, false));
#line 3538 "runtime.in"
  addFunc(ve, run::gen320, primTransform(), "shift", formal(primPair(), "z", false, false));
#line 3543 "runtime.in"
  addFunc(ve, run::gen321, primTransform(), "shift", formal(primReal(), "x", false, false), formal(primReal(), "y", false, false));
#line 3548 "runtime.in"
  addFunc(ve, run::gen322, primTransform(), "xscale", formal(primReal(), "x", false, false));
#line 3553 "runtime.in"
  addFunc(ve, run::gen323, primTransform(), "yscale", formal(primReal(), "y", false, false));
#line 3558 "runtime.in"
  addFunc(ve, run::gen324, primTransform(), "scale", formal(primReal(), "x", false, false));
#line 3563 "runtime.in"
  addFunc(ve, run::gen325, primTransform(), "scale", formal(primReal(), "x", false, false), formal(primReal(), "y", false, false));
#line 3568 "runtime.in"
  addFunc(ve, run::gen326, primTransform(), "slant", formal(primReal(), "s", false, false));
#line 3573 "runtime.in"
  addFunc(ve, run::gen327, primTransform(), "rotate", formal(primReal(), "angle", false, false), formal(primPair(), "z", true, false));
#line 3578 "runtime.in"
  addFunc(ve, run::gen328, primTransform(), "reflect", formal(primPair(), "a", false, false), formal(primPair(), "b", false, false));
#line 3601 "runtime.in"
  addFunc(ve, run::pairXPart, primReal(), "xpart", formal(primPair(), "z", false, false));
#line 3606 "runtime.in"
  addFunc(ve, run::pairYPart, primReal(), "ypart", formal(primPair(), "z", false, false));
#line 3611 "runtime.in"
  addFunc(ve, run::gen334, primReal(), "length", formal(primPair(), "z", false, false));
#line 3616 "runtime.in"
  addFunc(ve, run::gen335, primReal(), "abs", formal(primPair(), "z", false, false));
#line 3621 "runtime.in"
  addFunc(ve, run::gen336, primPair(), "sqrt", formal(primPair(), "z", false, true));
#line 3626 "runtime.in"
  addFunc(ve, run::gen337, primReal(), "angle", formal(primPair(), "z", false, false), formal(primBoolean(), "warn", true, false));
#line 3633 "runtime.in"
  addFunc(ve, run::gen338, primReal(), "degrees", formal(primPair(), "z", false, false), formal(primBoolean(), "warn", true, false));
#line 3640 "runtime.in"
  addFunc(ve, run::gen339, primReal(), "radians", formal(primReal(), "degrees", false, false));
#line 3646 "runtime.in"
  addFunc(ve, run::gen340, primReal(), "degrees", formal(primReal(), "radians", false, false));
#line 3652 "runtime.in"
  addFunc(ve, run::gen341, primReal(), "Degrees", formal(primReal(), "radians", false, false));
#line 3658 "runtime.in"
  addFunc(ve, run::gen342, primReal(), "Sin", formal(primReal(), "deg", false, false));
#line 3663 "runtime.in"
  addFunc(ve, run::gen343, primReal(), "Cos", formal(primReal(), "deg", false, false));
#line 3668 "runtime.in"
  addFunc(ve, run::gen344, primReal(), "Tan", formal(primReal(), "deg", false, false));
#line 3673 "runtime.in"
  addFunc(ve, run::gen345, primReal(), "aSin", formal(primReal(), "x", false, false));
#line 3678 "runtime.in"
  addFunc(ve, run::gen346, primReal(), "aCos", formal(primReal(), "x", false, false));
#line 3683 "runtime.in"
  addFunc(ve, run::gen347, primReal(), "aTan", formal(primReal(), "x", false, false));
#line 3688 "runtime.in"
  addFunc(ve, run::gen348, primPair(), "unit", formal(primPair(), "z", false, false));
#line 3693 "runtime.in"
  addFunc(ve, run::gen349, primPair(), "dir", formal(primReal(), "degrees", false, false));
#line 3698 "runtime.in"
  addFunc(ve, run::gen350, primPair(), "dir", formal(primPair(), "z", false, true));
#line 3703 "runtime.in"
  addFunc(ve, run::gen351, primPair(), "expi", formal(primReal(), "angle", false, false));
#line 3708 "runtime.in"
  addFunc(ve, run::gen352, primPair(), "exp", formal(primPair(), "z", false, true));
#line 3713 "runtime.in"
  addFunc(ve, run::gen353, primPair(), "log", formal(primPair(), "z", false, true));
#line 3718 "runtime.in"
  addFunc(ve, run::gen354, primPair(), "sin", formal(primPair(), "z", false, true));
#line 3723 "runtime.in"
  addFunc(ve, run::gen355, primPair(), "cos", formal(primPair(), "z", false, true));
#line 3728 "runtime.in"
  addFunc(ve, run::gen356, primPair(), "conj", formal(primPair(), "z", false, false));
#line 3733 "runtime.in"
  addFunc(ve, run::gen357, primPair(), "realmult", formal(primPair(), "z", false, false), formal(primPair(), "w", false, false));
#line 3738 "runtime.in"
  addFunc(ve, run::gen358, primTriple(), "realmult", formal(primTriple(), "u", false, false), formal(primTriple(), "v", false, false));
#line 3743 "runtime.in"
  addFunc(ve, run::gen359, primReal(), "dot", formal(primPair(), "z", false, true), formal(primPair(), "w", false, true));
#line 3763 "runtime.in"
  addFunc(ve, run::tripleXPart, primReal(), "xpart", formal(primTriple(), "v", false, false));
#line 3768 "runtime.in"
  addFunc(ve, run::tripleYPart, primReal(), "ypart", formal(primTriple(), "v", false, false));
#line 3773 "runtime.in"
  addFunc(ve, run::tripleZPart, primReal(), "zpart", formal(primTriple(), "v", false, false));
#line 3778 "runtime.in"
  addFunc(ve, run::gen365, primTriple(), "*", formal(primReal(), "x", false, false), formal(primTriple(), "v", false, false));
#line 3783 "runtime.in"
  addFunc(ve, run::gen366, primTriple(), "*", formal(primTriple(), "v", false, false), formal(primReal(), "x", false, false));
#line 3788 "runtime.in"
  addFunc(ve, run::gen367, primTriple(), "/", formal(primTriple(), "v", false, false), formal(primReal(), "x", false, false));
#line 3793 "runtime.in"
  addFunc(ve, run::gen368, primReal(), "length", formal(primTriple(), "v", false, false));
#line 3798 "runtime.in"
  addFunc(ve, run::gen369, primReal(), "abs", formal(primTriple(), "v", false, false));
#line 3803 "runtime.in"
  addFunc(ve, run::gen370, primReal(), "polar", formal(primTriple(), "v", false, false));
#line 3808 "runtime.in"
  addFunc(ve, run::gen371, primReal(), "azimuth", formal(primTriple(), "v", false, false));
#line 3813 "runtime.in"
  addFunc(ve, run::gen372, primReal(), "colatitude", formal(primTriple(), "v", false, false));
#line 3818 "runtime.in"
  addFunc(ve, run::gen373, primReal(), "latitude", formal(primTriple(), "v", false, false));
#line 3823 "runtime.in"
  addFunc(ve, run::gen374, primReal(), "longitude", formal(primTriple(), "v", false, false), formal(primBoolean(), "warn", true, false));
#line 3830 "runtime.in"
  addFunc(ve, run::gen375, primTriple(), "unit", formal(primTriple(), "v", false, false));
#line 3835 "runtime.in"
  addFunc(ve, run::gen376, primReal(), "dot", formal(primTriple(), "u", false, false), formal(primTriple(), "v", false, false));
#line 3840 "runtime.in"
  addFunc(ve, run::gen377, primTriple(), "cross", formal(primTriple(), "u", false, false), formal(primTriple(), "v", false, false));
#line 3845 "runtime.in"
  addFunc(ve, run::gen378, primTriple(), "expi", formal(primReal(), "polar", false, false), formal(primReal(), "azimuth", false, false));
#line 3850 "runtime.in"
  addFunc(ve, run::gen379, primTriple(), "dir", formal(primReal(), "colatitude", false, false), formal(primReal(), "longitude", false, false));
#line 3855 "runtime.in"
  addFunc(ve, run::gen380, primString() , "VERSION");
#line 3863 "runtime.in"
  addFunc(ve, run::gen381, primVoid(), "atupdate", formal(voidFunction(), "f", false, false));
#line 3868 "runtime.in"
  addFunc(ve, run::gen382, voidFunction(), "atupdate");
#line 3873 "runtime.in"
  addFunc(ve, run::gen383, primVoid(), "atexit", formal(voidFunction(), "f", false, false));
#line 3878 "runtime.in"
  addFunc(ve, run::gen384, voidFunction(), "atexit");
#line 3883 "runtime.in"
  addFunc(ve, run::gen385, primVoid(), "atbreakpoint", formal(breakpointFunction(), "f", false, false));
#line 3888 "runtime.in"
  addFunc(ve, run::gen386, primVoid(), "breakpoint", formal(primCode(), "s", true, false));
#line 3893 "runtime.in"
  addFunc(ve, run::gen387, primString() , "locatefile", formal(primString() , "file", false, false));
#line 3898 "runtime.in"
  addFunc(ve, run::gen388, primVoid(), "stop", formal(primString() , "file", false, false), formal(primInt(), "line", false, false), formal(primCode(), "s", true, false));
#line 3906 "runtime.in"
  addFunc(ve, run::gen389, primVoid(), "breakpoints");
#line 3912 "runtime.in"
  addFunc(ve, run::gen390, primVoid(), "clear", formal(primString() , "file", false, false), formal(primInt(), "line", false, false));
#line 3918 "runtime.in"
  addFunc(ve, run::gen391, primVoid(), "clear");
#line 3923 "runtime.in"
  addFunc(ve, run::gen392, primString() , "stripdirectory", formal(primString(), "s", false, false));
#line 3929 "runtime.in"
  addFunc(ve, run::gen393, primString() , "stripextension", formal(primString(), "s", false, false));
#line 3935 "runtime.in"
  addFunc(ve, run::gen394, primInt(), "convert", formal(primString() , "args", true, false), formal(primString() , "file", true, false), formal(primString() , "format", true, false));
#line 3952 "runtime.in"
  addFunc(ve, run::gen395, primInt(), "animate", formal(primString() , "args", true, false), formal(primString() , "file", true, false), formal(primString() , "format", true, false));
#line 3967 "runtime.in"
  addFunc(ve, run::gen396, primInt(), "delete", formal(primString(), "s", false, false));
#line 3977 "runtime.in"
  addFunc(ve, run::gen397, primInt(), "rename", formal(primString(), "from", false, false), formal(primString(), "to", false, false));
#line 4276 "runtime.in"
  addFunc(ve, run::gen428, IntArray(), "complement", formal(IntArray(), "a", false, false), formal(primInt(), "n", false, false));
#line 4308 "runtime.in"
  addFunc(ve, run::gen430, IntArray(), "sequence", formal(primInt(), "n", false, false));
#line 4341 "runtime.in"
  addFunc(ve, run::gen433, primBoolean(), "all", formal(boolArray(), "a", false, false));
#line 4350 "runtime.in"
  addFunc(ve, run::gen434, boolArray(), "!", formal(boolArray(), "a", false, false));
#line 4359 "runtime.in"
  addFunc(ve, run::gen435, primInt(), "sum", formal(boolArray(), "a", false, false));
#line 4522 "runtime.in"
  addFunc(ve, run::gen442, primInt(), "find", formal(boolArray(), "a", false, false), formal(primInt(), "n", true, false));
#line 4542 "runtime.in"
  addFunc(ve, run::gen443, primBoolean(), "==", formal(realArray2(), "a", false, false), formal(realArray2(), "b", false, false));
#line 4587 "runtime.in"
  addFunc(ve, run::gen445, realArray2(), "identity", formal(primInt(), "n", false, false));
#line 4610 "runtime.in"
  addFunc(ve, run::gen447, realArray2(), "inverse", formal(realArray2(), "a", false, false));
#line 4702 "runtime.in"
  addFunc(ve, run::gen448, realArray(), "solve", formal(realArray2(), "a", false, false), formal(realArray(), "b", false, false), formal(primBoolean(), "warn", true, false));
#line 4753 "runtime.in"
  addFunc(ve, run::gen449, realArray2(), "solve", formal(realArray2(), "a", false, false), formal(realArray2(), "b", false, false), formal(primBoolean(), "warn", true, false));
#line 4817 "runtime.in"
  addFunc(ve, run::gen450, primReal(), "determinant", formal(realArray2(), "a", false, false));
#line 4833 "runtime.in"
  addFunc(ve, run::gen451, realArray(), "*", formal(realArray2(), "a", false, false), formal(realArray(), "b", false, false));
#line 4851 "runtime.in"
  addFunc(ve, run::gen452, realArray2(), "*", formal(realArray2(), "a", false, false), formal(realArray2(), "b", false, false));
#line 4886 "runtime.in"
  addFunc(ve, run::gen453, primTriple(), "*", formal(realArray2(), "t", false, false), formal(primTriple(), "v", false, false));
#line 4891 "runtime.in"
  addFunc(ve, run::gen454, primPair(), "project", formal(primTriple(), "v", false, false), formal(realArray2(), "t", false, false));
#line 4916 "runtime.in"
  addFunc(ve, run::gen455, primReal(), "dot", formal(realArray(), "a", false, false), formal(realArray(), "b", false, false));
#line 4926 "runtime.in"
  addFunc(ve, run::gen456, realArray(), "tridiagonal", formal(realArray(), "a", false, false), formal(realArray(), "b", false, false), formal(realArray(), "c", false, false), formal(realArray(), "f", false, false));
#line 5030 "runtime.in"
  addFunc(ve, run::gen457, primReal(), "newton", formal(primInt(), "iterations", true, false), formal(realRealFunction(), "f", false, false), formal(realRealFunction(), "fprime", false, false), formal(primReal(), "x", false, false), formal(primBoolean(), "verbose", true, false));
#line 5077 "runtime.in"
  addFunc(ve, run::gen458, primReal(), "newton", formal(primInt(), "iterations", true, false), formal(realRealFunction(), "f", false, false), formal(realRealFunction(), "fprime", false, false), formal(primReal(), "x1", false, false), formal(primReal(), "x2", false, false), formal(primBoolean(), "verbose", true, false));
#line 5159 "runtime.in"
  addFunc(ve, run::gen459, primReal(), "simpson", formal(realRealFunction(), "f", false, false), formal(primReal(), "a", false, false), formal(primReal(), "b", false, false), formal(primReal(), "acc", true, false), formal(primReal(), "dxmax", true, false));
#line 5201 "runtime.in"
  addFunc(ve, run::gen461, IntArray2(), "triangulate", formal(pairArray(), "z", false, false));
#line 5236 "runtime.in"
  addFunc(ve, run::gen462, primBoolean(), "==", formal(primFile(), "a", false, false), formal(primFile(), "b", false, false));
#line 5244 "runtime.in"
  addFunc(ve, run::gen463, primBoolean(), "!=", formal(primFile(), "a", false, false), formal(primFile(), "b", false, false));
#line 5254 "runtime.in"
  addFunc(ve, run::gen465, primFile(), "input", formal(primString() , "name", false, false), formal(primBoolean(), "check", true, false), formal(primString() , "comment", true, false));
#line 5262 "runtime.in"
  addFunc(ve, run::gen466, primFile(), "output", formal(primString() , "name", false, false), formal(primBoolean(), "update", true, false), formal(primString() , "comment", true, false));
#line 5274 "runtime.in"
  addFunc(ve, run::gen467, primFile(), "xinput", formal(primString() , "name", false, false), formal(primBoolean(), "check", true, false));
#line 5288 "runtime.in"
  addFunc(ve, run::gen468, primFile(), "xoutput", formal(primString() , "name", false, false), formal(primBoolean(), "update", true, false));
#line 5306 "runtime.in"
  addFunc(ve, run::gen469, primFile(), "binput", formal(primString() , "name", false, false), formal(primBoolean(), "check", true, false));
#line 5313 "runtime.in"
  addFunc(ve, run::gen470, primFile(), "boutput", formal(primString() , "name", false, false), formal(primBoolean(), "update", true, false));
#line 5323 "runtime.in"
  addFunc(ve, run::gen471, primBoolean(), "eof", formal(primFile(), "file", false, false));
#line 5328 "runtime.in"
  addFunc(ve, run::gen472, primBoolean(), "eol", formal(primFile(), "file", false, false));
#line 5333 "runtime.in"
  addFunc(ve, run::gen473, primBoolean(), "error", formal(primFile(), "file", false, false));
#line 5338 "runtime.in"
  addFunc(ve, run::gen474, primVoid(), "clear", formal(primFile(), "file", false, false));
#line 5343 "runtime.in"
  addFunc(ve, run::gen475, primVoid(), "close", formal(primFile(), "file", false, false));
#line 5348 "runtime.in"
  addFunc(ve, run::gen476, primInt(), "precision", formal(primFile(), "file", true, false), formal(primInt(), "digits", true, false));
#line 5354 "runtime.in"
  addFunc(ve, run::gen477, primVoid(), "flush", formal(primFile(), "file", false, false));
#line 5359 "runtime.in"
  addFunc(ve, run::gen478, primString() , "getc", formal(primFile(), "file", false, false));
#line 5368 "runtime.in"
  addFunc(ve, run::gen479, primInt(), "tell", formal(primFile(), "file", false, false));
#line 5373 "runtime.in"
  addFunc(ve, run::gen480, primVoid(), "seek", formal(primFile(), "file", false, false), formal(primInt(), "pos", false, false));
#line 5378 "runtime.in"
  addFunc(ve, run::gen481, primVoid(), "seekeof", formal(primFile(), "file", false, false));
#line 5383 "runtime.in"
  addFunc(ve, run::gen482, primFile(), "dimension", formal(primFile(), "file", false, false), formal(primInt(), "nx", false, false));
#line 5390 "runtime.in"
  addFunc(ve, run::gen483, primFile(), "dimension", formal(primFile(), "file", false, false), formal(primInt(), "nx", false, false), formal(primInt(), "ny", false, false));
#line 5396 "runtime.in"
  addFunc(ve, run::gen484, primFile(), "dimension", formal(primFile(), "file", false, false), formal(primInt(), "nx", false, false), formal(primInt(), "ny", false, false), formal(primInt(), "nz", false, false));
#line 5402 "runtime.in"
  addFunc(ve, run::gen485, primFile(), "csv", formal(primFile(), "file", false, false), formal(primBoolean(), "b", true, false));
#line 5409 "runtime.in"
  addFunc(ve, run::gen486, primFile(), "word", formal(primFile(), "file", false, false), formal(primBoolean(), "b", true, false));
#line 5416 "runtime.in"
  addFunc(ve, run::gen487, primFile(), "line", formal(primFile(), "file", false, false), formal(primBoolean(), "b", true, false));
#line 5423 "runtime.in"
  addFunc(ve, run::gen488, primFile(), "single", formal(primFile(), "file", false, false), formal(primBoolean(), "b", true, false));
#line 5431 "runtime.in"
  addFunc(ve, run::gen489, primFile(), "single", formal(primFile(), "file", false, false), formal(primReal(), "x", false, false), formal(primBoolean(), "b", true, false));
#line 5439 "runtime.in"
  addFunc(ve, run::gen490, primFile(), "single", formal(primFile(), "file", false, false), formal(primInt(), "x", false, false), formal(primBoolean(), "b", true, false));
#line 5447 "runtime.in"
  addFunc(ve, run::gen491, primFile(), "read1", formal(primFile(), "file", false, false));
#line 5454 "runtime.in"
  addFunc(ve, run::gen492, primFile(), "read2", formal(primFile(), "file", false, false));
#line 5461 "runtime.in"
  addFunc(ve, run::gen493, primFile(), "read3", formal(primFile(), "file", false, false));
#line 5468 "runtime.in"
  addFunc(ve, run::gen494, stringArray(), "history", formal(primString() , "name", false, false), formal(primInt(), "n", true, false));
#line 5501 "runtime.in"
  addFunc(ve, run::gen495, stringArray(), "history", formal(primInt(), "n", true, false));
#line 5512 "runtime.in"
  addFunc(ve, run::gen496, primString() , "readline", formal(primString() , "prompt", true, false), formal(primString() , "name", true, false), formal(primBoolean(), "tabcompletion", true, false));
#line 5556 "runtime.in"
  addFunc(ve, run::gen497, primVoid(), "saveline", formal(primString() , "name", false, false), formal(primString() , "value", false, false), formal(primBoolean(), "store", true, false));
#line 5584 "runtime.in"
  addFunc(ve, run::gen498, primVoid(), "generate_random_backtrace");
#line 5593 "runtime.in"
  addFunc(ve, run::gen499, primVoid(), "print_random_addresses", formal(primInt(), "n", true, false));
}

} // namespace trans
