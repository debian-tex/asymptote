<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

  <script id="shader-fs" type="x-shader/x-fragment">#version 300 es
    precision mediump float;

    in vec4 vColor;
    in vec3 vNormal;
    out vec4 outColor;

    flat in int vMaterialIndex;

    // can also construct an alternative shader,
    // but would require more work.
    // FIXME: An ad-hoc solution is to use uniforms... 
    uniform int useColor;

    struct Material {
      vec4 baseColor, emissive, specular;
      float roughness, metallic, f0;
    };

    uniform mat4 uMMatrix; // model matrix
    uniform mat4 uPMatrix; // projection matrix
    uniform mat4 uVMatrix; // view matrix

    uniform Material objMaterial[100]; // assuming we are doing multiple materials, 

    // we can upload them one at a time per call.
    // but, we can also make it an array + pass in an index, 
    // say uniform Material objMaterial[$nmat];

    // or, even use Uniform Buffer Objects... 

    // type, for now
    #define POINT_LIGHT 1
    #define DIRECTIONAL_LIGHT 2

    // for direction, parameter is direction
    // for point light, parameter is position (in homoeg coords?)
    // are these given in world coords, or view coords? - I can do both 
    struct Light {
      int type;
      vec3 color;
      float brightness;
      vec4 parameter;
    };

    uniform int unLights; // can be replaced by a constant, or even a fixed array in the final release.
    uniform Light objLights[100]; // again, can be set at will by the asy generator.

    float NDF_TRG(vec3 halfv, vec3 normal, float roughness) {
      float ndoth=max(dot(normal, halfv), 0.0);
      float alpha2=roughness*roughness;
      
      float denom=pow(ndoth*ndoth*(alpha2-1.0)+1.0, 2.0);
      return alpha2/denom;
    }
    
    float GGX_Geom(vec3 v, vec3 normal, float roughness) {
      float ndotv=max(dot(v, normal), 0.0);
      float ap=pow((1.0+roughness), 2.0);
      float k=ap/8.0;
      
      return ndotv/((ndotv*(1.0-k))+k);
    }
    
    float Geom(vec3 v, vec3 l, vec3 normal, float roughness) {
      return GGX_Geom(v,normal,roughness)*GGX_Geom(l,normal,roughness);
    }
    
    float Fresnel(vec3 h, vec3 v, float f0) {
      float hdotv=max(dot(h,v), 0.0);
      return f0+(1.0-f0)*pow((1.0-hdotv),5.0);
    }
    
    // physical based shading using UE4 model.
    vec3 physBDRF(Material material, vec3 normal, vec3 lightdir, vec3 lookdir) {
      vec3 lambertian=material.baseColor.rgb;
      vec3 h=normalize(lightdir+lookdir);
      float omegain=max(dot(lookdir, normal), 0.0);
      float omegali=max(dot(lightdir, normal), 0.0);
      
      float D=NDF_TRG(h, normal, material.roughness*material.roughness);
      float G=Geom(lookdir, lightdir, normal, material.roughness*material.roughness);
      float F=Fresnel(h, lookdir, material.f0);
      
      float denom=4.0*omegain*omegali;
      if (denom == 0.0) {return vec3(0,0,0); }
      
      float rawrefl=(D*G) / denom;
      
      vec3 dielectric=mix(lambertian, rawrefl*material.specular.rgb, F);
      vec3 metal=rawrefl*material.baseColor.rgb;
      
      return mix(dielectric, metal, material.metallic);
    }
    
    void main(void)
    {
      // change later.

      // assuming for now that the headlamp is always on.
      // light dir=+Z, viewDir=+Z,

      float normalSign = gl_FrontFacing ? 1.0 : -1.0;
      
      vec3 normal=normalSign*normalize(vNormal);
      vec3 Z=vec3(0,0,1.0);
      vec3 rawCol = vec3(0.0);

      Material m=objMaterial[vMaterialIndex];

      if (useColor == 1) {
        m.baseColor = vColor;
      }

      for (int i=0;i<unLights;++i) {
        Light Li=objLights[i];
        float cosTheta = 0.0;
        float atteunation = 1.0;
        vec3 lightDirection = vec3(0.0);
        if (Li.type == DIRECTIONAL_LIGHT) {
          lightDirection = Li.parameter.xyz;
          cosTheta = max(dot(normal, lightDirection), 0.0);
        }
        vec3 radiance = cosTheta * Li.color * Li.brightness;
        rawCol += physBDRF(m, normal, lightDirection, Z) * radiance;
      }
      outColor=vec4(rawCol,1);
    }
  </script>

  <script id="shader-vs" type="x-shader/x-vertex">#version 300 es
    precision mediump float;
    in vec3 aVertexPosition;
    in vec4 aVertexColor;
    in vec3 aVertexNormal;
    in int aVertexMaterialIndex;
    
    uniform mat4 uMMatrix; // model matrix
    uniform mat4 uPMatrix; // projection matrix
    uniform mat4 uVMatrix; // view matrix
    
    out vec4 vColor;
    out vec3 vNormal;
    flat out int vMaterialIndex;
    
    mat4 invdual(mat4 invec) {
      return inverse(transpose(invec));
    }
    void main(void) {
      gl_Position=uPMatrix*uVMatrix*uMMatrix*vec4(aVertexPosition,1.0);
      
      mat4 invdualmat=invdual(uVMatrix*uMMatrix);
      vec4 rawNormal=invdualmat*vec4(aVertexNormal, 0);
      
      vNormal=normalize(rawNormal.xyz);
      
      vColor=aVertexColor;
      vMaterialIndex=aVertexMaterialIndex;
    }
    
  </script>

   <script type="text/javascript" src="https://vectorgraphics.github.io/asymptote/webgl/gl-matrix-min-2.3.2.js"></script>
   <script type="text/javascript" src="https://vectorgraphics.github.io/asymptote/webgl/glm-js-min-2.2.2.js"></script>
   <script type="text/javascript" src="https://vectorgraphics.github.io/asymptote/webgl/arcball-min-0.01.js"></script>
  <script type="text/javascript" src="gl.js"></script>
    <script type="text/javascript">
